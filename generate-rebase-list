#!/bin/bash -e

## START CONFIG

# Used to limit the commits we look at
# REBASE_START_POINT=v4.19.61
# REBASE_END_POINT=4.19-extract
# TARGET_BRANCH=android/android-mainline-tracking
# REBASE_ID=rebase53

# REBASE_START_POINT=v4.19
# REBASE_END_POINT=cros/chromeos-4.19
# TARGET_BRANCH=v4.19.61
# REBASE_ID=rebase419

REBASE_START_POINT=v4.19
REBASE_END_POINT=cros/chromeos-4.19
TARGET_BRANCH=android/android-mainline-tracking
REBASE_ID=rebase53

SKIP_ANDROID=1
SKIP_IWL7000=1

## END CONFIG

REBASE_END_POINT_SHA="$(git rev-parse "$REBASE_END_POINT")"
REBASE_START_POINT_SHA="$(git rev-parse "$REBASE_START_POINT")"
TARGET_BRANCH_SHA="$(git rev-parse "$TARGET_BRANCH")"
NEXT_BRANCH=next/master
NEXT_BRANCH_SHA="$(git rev-parse "$NEXT_BRANCH")"

WORK_DIR="$(dirname "${BASH_SOURCE[0]}")"
mkdir -p "$WORK_DIR/change-id"
mkdir -p "$WORK_DIR/type"

REBASE_DIR="$WORK_DIR/$REBASE_ID"
mkdir -p "$REBASE_DIR"
mkdir -p "$REBASE_DIR/orig"
mkdir -p "$REBASE_DIR/patch"
mkdir -p "$REBASE_DIR/pre"
mkdir -p "$REBASE_DIR/skip"
mkdir -p "$REBASE_DIR/log"
mkdir -p "$REBASE_DIR/fixup"

CACHE_DIR="$WORK_DIR/cache"
mkdir -p "$CACHE_DIR"
mkdir -p "$CACHE_DIR/msg"
mkdir -p "$CACHE_DIR/patch-id"
mkdir -p "$CACHE_DIR/commit"
mkdir -p "$CACHE_DIR/squash"


if ! git diff-index --quiet HEAD; then
  echo "Working directory is dirty."
  exit 1
fi

echo "Source: ${REBASE_START_POINT}..${REBASE_END_POINT} (${REBASE_START_POINT_SHA}..${REBASE_END_POINT_SHA})"
echo "Dest: $TARGET_BRANCH ($TARGET_BRANCH_SHA)"

git checkout -q "$TARGET_BRANCH"
LOCAL_BRANCH="$REBASE_ID-$(date +%F-%H)"
if git rev-parse --quiet --verify "$LOCAL_BRANCH"; then
		git branch -D "$LOCAL_BRANCH"
fi
git checkout -b "$LOCAL_BRANCH" "$TARGET_BRANCH"

TARGET_CACHE="$CACHE_DIR/$(git rev-parse HEAD)"
TARGET_CACHE="$CACHE_DIR/${REBASE_START_POINT_SHA}..${TARGET_BRANCH_SHA}/"
mkdir -p "$TARGET_CACHE"

SRC_CACHE="$CACHE_DIR/${REBASE_START_POINT_SHA}..${REBASE_END_POINT_SHA}/"
mkdir -p "$SRC_CACHE"

NEXT_CACHE="$CACHE_DIR/${TARGET_BRANCH_SHA}..${NEXT_BRANCH_SHA}/"
mkdir -p "$NEXT_CACHE"

LAST_UPSTREAM_MERGE="$(git show -s --merges -n 1 --format='%P' \
	--grep '^CHROMIUM: Merge' "$REBASE_END_POINT" | cut -d ' ' -f 2)"

echo "Limit: $LAST_UPSTREAM_MERGE"

sp='/-\|'

GITK_PIDS=()

function kill-gitk() {
	for pid in "${GITK_PIDS[@]}"
	do
		kill "$pid" >/dev/null || true

		wait "$pid" >/dev/null || true
	done
	GITK_PIDS=()
}

function finish {
	kill-gitk
}

trap finish EXIT

function ctrl_c() {
	local answer
	echo "Are you sure you want to exit [Yes/No]?"
	read -r answer
	if [[ "$answer" == "Yes" ]]; then
		exit 1
	fi
}

trap ctrl_c INT


# Returns 0 if $1 is an ancestor of HEAD
function is-ancestor() {
	if [[ -n "${ANCESTOR_COMMITS["$1"]}" ]]; then
		return 0
	else
		return 1
	fi
}

function get-commit-path() {
	local full_sha
	if ! full_sha="$(git rev-parse "$1")"; then
		return 1
	fi

	if [[ ! -e "${CACHE_DIR}/commit/${full_sha}" ]]; then
		if ! git show "$full_sha" > "${CACHE_DIR}/commit/${full_sha}"; then
			return 1
		fi
	fi
	echo "${CACHE_DIR}/commit/${full_sha}"
}

# Returns the commit msg of $1
function get-msg() {
	if [[ ! -e "${CACHE_DIR}/msg/${1}" ]]; then
		# Maybe use git show -s --format=%B
		git show -s --format=%B "${1}" > "${CACHE_DIR}/msg/${1}"
	fi

	cat "${CACHE_DIR}/msg/${1}"
}

function get-subject() {
	get-msg "$1" | head -n 1
}

function pause-script() {
	echo "Pausing script, use fg to resume"
	(kill -STOP $$)
}

function sanitize-subject() {
	sed -E \
		-e 's/(CHROMIUMOS|CHROMIUM|CHROMEOS|FROMLIST|UPSTREAM|FROMGIT|BACKPORT|ANDROID|FIXUP):\s*//g' \
		-e 's/\.$//g' <<< "$1"
}

function get-patch-id() {
	local patch_id="${PATCH_ID_MAP[$1]}"
	if [[ -n "$patch_id" ]]; then
		echo "$patch_id"
	else
		echo "Unexpectedly generating patch-id for $1" >&2
		git show "$1" | git patch-id --stable | cut -d\  -f 1
	fi
}

# $1: COMMIT_SHA
# Sets MATCHING_COMMIT with cherry-picked commit
function try-cherry-pick-original() {
	local CHERRY_PICKED_COMMITS=()

	IFS=' ' read -r -a CHERRY_PICKED_COMMITS <<< "${CHERRY_PICKED_FROM_COMMIT_MAP["$1"]}"
	for CHERRY_PICKED_COMMIT in "${CHERRY_PICKED_COMMITS[@]}"; do
		echo "Trying to cherry-pick $CHERRY_PICKED_COMMIT"
		if git cherry-pick "$CHERRY_PICKED_COMMIT"; then
			echo "Cherry pick was successful"
			local msg
			msg="$(get-msg "$1" | sed -E -e '1 s/\s*BACKPORT:\s*//' \
				-e '$a['"$REBASE_ID"'('"$USER"'): Cherry picked original commit'"$CHERRY_PICKED_COMMIT"']' \
				-e '$aSigned-off-by: '"$(git config user.name)"' <'"$(git config user.email)"'>'
			)"
			git commit --amend --message "$msg"
			MATCHING_COMMIT="$CHERRY_PICKED_COMMIT"
			return 0
		else
			git cherry-pick --abort
		fi
	done

	return 1
}

# $1: left file
# $2: right file
# $3: Prompt
function prompt-difftool() {
	local PS3 opt meldpid

	meld "$1" "$2" &
	meldpid="$!"

	# So it gets killed if we terminate
	GITK_PIDS+=("$meldpid")

	PS3="$3"
	select opt in "Yes" "No"
	do
		if [[ -z "$opt" ]]; then
			echo "Invalid option $opt. Try another one."
			continue
		fi
		break
	done

	if [[ -n "$meldpid" ]]; then
		unset 'GITK_PIDS[-1]'
		kill "$meldpid" 2>/dev/null || true
		wait "$meldpid" 2>/dev/null || true
	fi

	if [[ "$opt" = "Yes" ]]; then
		return 0
	fi

	return 1
}

# $1: COMMIT_SHA
# $2: POSSIBLE_COMMIT_SHA
function prompt-is-commit() {
	local commit_path possible_commit_path

	if ! commit_path="$(get-commit-path "$1")"; then
		echo "Failed to lookup $1" >&2
		return 1
	fi


	if ! possible_commit_path="$(get-commit-path "$2")"; then
		echo "Failed to lookup $2" >&2
		return 1
	fi

	prompt-difftool "$commit_path" "$possible_commit_path" 'Is this commit correct?: '
}

# If a commit is found return 0 and set $POSSIBLE_COMMIT_SHA
# $1: COMMIT_SHA
# $2: SEARCH_STRING
function search-for-possible-commit() {
	local POSSIBLE_COMMITS
	local found=false

	local commit_patch_id
	local possible_commit_patch_id

	commit_patch_id="$(get-patch-id "$1")"
	echo "Patch ID: $commit_patch_id"

	readarray -t POSSIBLE_COMMITS < <(
		git rev-list --no-merges --regexp-ignore-case --fixed-strings --grep "$2" "HEAD")

	for POSSIBLE_COMMIT_SHA in "${POSSIBLE_COMMITS[@]}"; do
		echo "Found $POSSIBLE_COMMIT_SHA: $(get-subject "$POSSIBLE_COMMIT_SHA")"

		possible_commit_patch_id="$(get-patch-id "$POSSIBLE_COMMIT_SHA")"

		# Not really used anymore
		if [[ "$commit_patch_id" = "$possible_commit_patch_id" ]]; then
			echo "Patch IDs ($commit_patch_id) are identical"
			found=true
			break
		fi

		if prompt-is-commit "$1" "$POSSIBLE_COMMIT_SHA"; then
			found=true
			break
		fi
	done

	if [[ "$found" = "true" ]]; then
		return 0
	else
		POSSIBLE_COMMIT_SHA=""
		echo "Failed to find commit"
		return 1
	fi
}

# Generates a squash id
# $1: COMMIT_SHA
# $*: squashed shas
function generate-squash-id() {
	local commit_sha=$1

	shift

	local str
	str=$"$commit_sha"$'\n'"$(git show -s --format='%H' "$@")"

	local squash_id
	squash_id="$(git hash-object --stdin <<< "$str")"

	echo "$squash_id"
}

# Extracts the squash id from stdin
# $1 COMMIT_SHA
function extract-squash-id() {
	local src_shas
	readarray -t src_shas < <(
		sed -E -n -e '/^'"$REBASE_ID"' squashed:/,/^$/{s/^\s+([a-z0-9]+)\s.*$/\1/p}'
	)

	echo "src_shas: ${src_shas[*]}" >&2

	if [[ "${#src_shas[@]}" -eq 0 ]]; then
		return 1
	fi

	generate-squash-id "$1" "${src_shas[@]}"
}

# Generates the patch containing all the squashes
# $1: COMMIT_SHA
# Sets SQUASH_ID on exit
function generate-squashed-patch {
	local commit_sha="$1"
	local src_shas
	IFS=' ' read -r -a src_shas <<< "${SQUASH_MAP["$commit_sha"]}"
	if [[ "${#src_shas[*]}" -eq 0 ]]; then
		echo "No SHAs found to squash for $commit_sha"
		exit 1
	fi

	# Generate a unique squash_id so we can cache the results
	local squash_id
	squash_id="$(generate-squash-id "$commit_sha" "${src_shas[@]}")"

	SQUASH_ID="$squash_id"
	echo "Squash ID: $squash_id" >&2

	if [[ -e "$CACHE_DIR/squash/$squash_id" ]]; then
		echo "Squash already generated, reusing"
		return
	fi

	# echo "Squashing ${src_shas[*]} into $commit_sha"

	local rebase_work

	rebase_work="pick $commit_sha
$(printf "fixup %s\\n" "${src_shas[@]}")
"
	echo "$rebase_work"

	if ! GIT_SEQUENCE_EDITOR="echo '$rebase_work' >" git rebase -i \
			--onto "${commit_sha}~" "${commit_sha}~" "${commit_sha}"; then
		echo "Auto squash failed."
		git rebase --abort
		SQUASH_ID=

		git checkout -q "$LOCAL_BRANCH"
		return 1
	fi

	local msg
	msg="${REBASE_ID} squashed:
$(git show -s --format='	%h %s' "${src_shas[@]}")

Signed-off-by: $(git config user.name) <$(git config user.email)>"

	git commit --amend -m "$(get-msg "$commit_sha")" -m "$msg"

	git format-patch -1 HEAD --stdout > "$CACHE_DIR/squash/$squash_id"

	git checkout -q "$LOCAL_BRANCH"

}
# Prints the arguments in a CSV compliant maner
function print-csv() {
	# This outputs an additional , at the end.
	 printf '"%s",' "${@//\"/\"\"}"
	 printf '\n'
}

# We try and create the list with commits that are more likely to be upstream
# first, and finally chromium specific patches.

declare -A IGNORE_LIST

# Map of SHA => {UPSTREAM, FROMLIST, etc}
declare -A COMMIT_TYPE_MAP

# Map of SHA => Change-Id
declare -A CHANGE_ID_MAP

# Map of Local SHAS to their upstream commits' that were already merged
declare -A MERGED_UPSTREAM_COMMIT_MAP

# Map of Local SHAS to their cherry-picked from commits. The commits are space
# separated.
declare -A CHERRY_PICKED_FROM_COMMIT_MAP

declare -A REVERT_COMMIT_MAP
declare -A COMMIT_REVERTED_MAP

# Map of Commit Subject => SHA
# FIXUP commits use the subject as the key
# If there are duplicate titles, the latest commit is always used.
# This makes sense if there is a cherry-pick, revert and cherry-pick of a new
# version with the same name.
# The subject is stripped of any tags and trailing . because a lot of the
# commits don't use the same title as the original commit.
declare -A COMMITS_BY_CLEAN_SUBJECT

# Map of Src SHA => Dest SHA
declare -A SQUASH_INTO_MAP

# Map of Dest SHA => List<Src SHA>
declare -A SQUASH_MAP

# Map of SHA => Patch ID
declare -A PATCH_ID_MAP

# Ordered list of commits
declare -a UPSTREAM_COMMIT_LIST
declare -a FROMLIST_COMMIT_LIST
declare -a FROMGIT_COMMIT_LIST
declare -a CHROMIUM_COMMIT_LIST
declare -a REVERT_COMMIT_LIST

# We need to care about the order for the newer commits because the might
# not have been backported...
declare -a NON_CHROMIUM_COMMIT_LIST

# UPSTREAM patches need to be added first
# git log --pretty=oneline --grep "UPSTREAM:" --no-merges --reverse m/master > "$FILE"

# Loop through all of the commits and check if they are present in the current
# tree.

# git rev-list --grep "UPSTREAM:" --no-merges m/master > "$FILE"

if [[ ! -e "$SRC_CACHE/ALL_COMMITS" ]]; then
	# Adding Change-Id in here is unfortunate... but we need to do it
	# because there are some CLs that were submitted without any tags :(
	git rev-list --no-merges "${REBASE_END_POINT}" "^${LAST_UPSTREAM_MERGE}" \
		--reverse > "$SRC_CACHE/ALL_COMMITS"

	xargs git show -s --format=oneline > "$SRC_CACHE/ALL_COMMITS.txt" < \
		"$SRC_CACHE/ALL_COMMITS"
fi

readarray -t ALL_COMMITS < "$SRC_CACHE/ALL_COMMITS"

if [[ ! -e "$SRC_CACHE/PATCH_IDS" ]]; then
	echo "Generating local patch-ids"

	git show --no-merges "${REBASE_END_POINT}" "^${LAST_UPSTREAM_MERGE}" | \
		git patch-id --stable > "$SRC_CACHE/PATCH_IDS.tmp"

	mv "$SRC_CACHE/PATCH_IDS.tmp" "$SRC_CACHE/PATCH_IDS"
fi

while IFS=" " read -r PATCH_ID COMMIT_SHA; do
	PATCH_ID_MAP[$COMMIT_SHA]="$PATCH_ID"
done < "$SRC_CACHE/PATCH_IDS"

declare -A ANCESTOR_COMMITS

if [[ ! -e "$TARGET_CACHE/ANCESTOR_COMMITS" ]]; then
	echo "Locating ancestor commits"
	# There is no reason to look at anything older than the fork point when
	# determining if a commit has been merged.
	git rev-list --no-merges "$REBASE_START_POINT"..HEAD > "$TARGET_CACHE/ANCESTOR_COMMITS"
	xargs git show -s --format=oneline > "$TARGET_CACHE/ANCESTOR_COMMITS.txt" < \
		"$TARGET_CACHE/ANCESTOR_COMMITS"
fi

while read -r COMMIT_SHA; do
	ANCESTOR_COMMITS["$COMMIT_SHA"]=1
done < "$TARGET_CACHE/ANCESTOR_COMMITS"

if [[ ! -e "$TARGET_CACHE/ANCESTOR_PATCH_IDS" ]]; then
	echo "Generating ancestor patch-ids"

	git show --no-merges "$REBASE_START_POINT"..HEAD | git patch-id --stable \
		> "$TARGET_CACHE/ANCESTOR_PATCH_IDS.tmp"

	mv "$TARGET_CACHE/ANCESTOR_PATCH_IDS.tmp" "$TARGET_CACHE/ANCESTOR_PATCH_IDS"
fi

declare -A ANCESTOR_PATCH_IDS
while IFS=" " read -r PATCH_ID COMMIT_SHA; do
	PATCH_ID_MAP[$COMMIT_SHA]="$PATCH_ID"

	if [[ -n "${ANCESTOR_PATCH_IDS[$PATCH_ID]}" ]]; then
		# echo "Duplicate PATCH ID $PATCH_ID"
		# echo "Commits: $COMMIT_SHA ${ANCESTOR_PATCH_IDS[$PATCH_ID]}"
		ANCESTOR_PATCH_IDS["$PATCH_ID"]="$COMMIT_SHA ${ANCESTOR_PATCH_IDS[$PATCH_ID]}"
	else
		ANCESTOR_PATCH_IDS["$PATCH_ID"]="$COMMIT_SHA"
	fi
done < "$TARGET_CACHE/ANCESTOR_PATCH_IDS"

if [[ ! -e "$NEXT_CACHE/NEXT_PATCH_IDS" ]]; then
	echo "Generating next patch-ids"

	git show --no-merges "$TARGET_BRANCH".."$NEXT_BRANCH" | \
		git patch-id --stable > "$NEXT_CACHE/NEXT_PATCH_IDS.tmp"

	mv "$NEXT_CACHE/NEXT_PATCH_IDS.tmp" "$NEXT_CACHE/NEXT_PATCH_IDS"
fi

declare -A NEXT_PATCH_IDS
while IFS=" " read -r PATCH_ID COMMIT_SHA; do
	if [[ -n "${NEXT_PATCH_IDS[$PATCH_ID]}" ]]; then
		NEXT_PATCH_IDS["$PATCH_ID"]="$COMMIT_SHA ${NEXT_PATCH_IDS[$PATCH_ID]}"
	else
		NEXT_PATCH_IDS["$PATCH_ID"]="$COMMIT_SHA"
	fi
done < "$NEXT_CACHE/NEXT_PATCH_IDS"

echo "Processing metadata"
i=0
for COMMIT_SHA in "${ALL_COMMITS[@]}"; do
	printf '\b%s' "${sp:i++%${#sp}:1}"

	if [[ -n "${IGNORE_LIST[$COMMIT_SHA]}" ]]; then
		echo "Ignoring $COMMIT_SHA: ${IGNORE_LIST[$COMMIT_SHA]}"
		continue
	fi

	if ! COMMIT_MSG="$(get-msg "$COMMIT_SHA")"; then
		echo "Failed to get commit message for $COMMIT_SHA"
		exit 1
	fi


	# Generate a map of COMMIT_SHA=>List<Upstream SHA>
	readarray -t UPSTREAM_SHAS < <(
		sed -n -E -e 's/\s*\(cherry[- ]picked from commit (commit )?([a-z0-9]+).*/\2/p' \
			<<< "$COMMIT_MSG")

	for UPSTREAM_SHA in "${UPSTREAM_SHAS[@]}"; do
		if ! git cat-file -e "${UPSTREAM_SHA}"; then
			# echo "Commit specified upstream hash '$UPSTREAM_SHA', but it was not found"
			continue
		fi

		CHERRY_PICKED_COMMITS="${CHERRY_PICKED_FROM_COMMIT_MAP["$COMMIT_SHA"]}"
		if [[ -z "$CHERRY_PICKED_COMMITS" ]]; then
			CHERRY_PICKED_FROM_COMMIT_MAP["$COMMIT_SHA"]="$UPSTREAM_SHA"
		else
			CHERRY_PICKED_FROM_COMMIT_MAP["$COMMIT_SHA"]="$CHERRY_PICKED_COMMITS $UPSTREAM_SHA"
		fi
	done

	if [[ -e "${WORK_DIR}/change-id/${COMMIT_SHA}" ]]; then
		CHANGE_ID="$(<"${WORK_DIR}/change-id/${COMMIT_SHA}")"
	else
		readarray -t CHANGE_IDS < <(
			sed -En -e 's/^Change-Id: ([A-Za-z0-9]+)$/\1/p' <<<"$COMMIT_MSG")

			if [[ "${#CHANGE_IDS[@]}" -eq 0 ]]; then
				# Use the cherry-pick from sha to make the change id.
				# This improves the probability of them matching.
				IFS=' ' read -r -a UPSTREAM_SHAS <<< "${CHERRY_PICKED_FROM_COMMIT_MAP["$COMMIT_SHA"]}"
				if [[ -z "${UPSTREAM_SHAS[0]}" ]]; then
					CHANGE_ID="I${COMMIT_SHA}"
				else
					CHANGE_ID="I${UPSTREAM_SHAS[0]}"
				fi
				echo "Commit $COMMIT_SHA was missing Change-Id, using $CHANGE_ID"
				echo "$CHANGE_ID" > "${WORK_DIR}/change-id/${COMMIT_SHA}"
			elif [[ "${#CHANGE_IDS[@]}" -eq 1 ]]; then
				CHANGE_ID="${CHANGE_IDS[0]}"
			else
				# echo "Multiple Change-Ids found for $COMMIT_SHA: ${CHANGE_IDS[*]}"
				CHANGE_ID="${CHANGE_IDS[0]}"
				# echo "Using: $CHANGE_ID"
				# echo "Please select the one you want to use:"
				# PS3='Change-Id: '
				# select opt in "${CHANGE_IDS[@]}"
				# do
				#   if [[ -z "$opt" ]]; then
				#     echo "Invalid option $opt. Try another one."
				#     continue
				#   fi
				#   break
				# done
				# CHANGE_ID="$opt"
				# echo "$CHANGE_ID" > "${WORK_DIR}/change-id/${COMMIT_SHA}"
			fi
	fi

	CHANGE_ID_MAP["$COMMIT_SHA"]="$CHANGE_ID"

	COMMIT_SUBJECT="$(head -n 1 <<< "$COMMIT_MSG")"

	CLEAN_COMMIT_SUBJECT="$(sanitize-subject "$COMMIT_SUBJECT")"

	# Link FIXUPS to their target commits
	if [[ "$COMMIT_SUBJECT" == "FIXUP: "* ]]; then

		if [[ -e "$REBASE_DIR/fixup/$COMMIT_SHA" ]]; then
			TARGET_SHA="$(<"$REBASE_DIR/fixup/$COMMIT_SHA")"
		else
			TARGET_SHA="${COMMITS_BY_CLEAN_SUBJECT[${CLEAN_COMMIT_SUBJECT%.}]}"
			if [[ -z "$TARGET_SHA" ]]; then
				echo "Processing: $COMMIT_SHA $COMMIT_SUBJECT"
				echo "Error: Fixup unable to locate: '$CLEAN_COMMIT_SUBJECT'"
				echo "Manually lookup the commit and enter the SHA"
				echo -n "Fixup Target SHA: "
				read -r TARGET_SHA

				if [[ -z "$TARGET_SHA" ]]; then
					echo "No SHA specified, treating as normal commit..."
					# Write down the fact that this commit isn't a FIXUP.
					# We will apply it like normal
					touch "$REBASE_DIR/fixup/$COMMIT_SHA"
				else
					TARGET_SHA="$(git rev-parse "$TARGET_SHA")"

					echo "$TARGET_SHA" > "$REBASE_DIR/fixup/$COMMIT_SHA"
				fi
			fi
		fi

		if [[ -n "$TARGET_SHA" ]]; then
			SQUASH_INTO_MAP[$COMMIT_SHA]="$TARGET_SHA"

			if [[ -z "${SQUASH_MAP[$TARGET_SHA]}" ]]; then
				SQUASH_MAP[$TARGET_SHA]="$COMMIT_SHA"
			else
				SQUASH_MAP[$TARGET_SHA]="${SQUASH_MAP[$TARGET_SHA]} $COMMIT_SHA"
			fi
		fi
	else
		COMMITS_BY_CLEAN_SUBJECT[$CLEAN_COMMIT_SUBJECT]="$COMMIT_SHA"
	fi


	COMMIT_TYPE=""
	while [[ -z "$COMMIT_TYPE" ]]; do
		OVERRIDE_TYPE=""

		# Detect commit type
		if [[ -e "${WORK_DIR}/type/${CHANGE_ID}" ]]; then
			COMMIT_TYPE="$(<"${WORK_DIR}/type/${CHANGE_ID}")"
		elif [[ -e "${WORK_DIR}/type/${COMMIT_SHA}" ]]; then
			# Migrate to the new format
			mv "${WORK_DIR}/type/${COMMIT_SHA}" "${WORK_DIR}/type/${CHANGE_ID}"
			COMMIT_TYPE="$(<"${WORK_DIR}/type/${CHANGE_ID}")"
		elif [[ $COMMIT_SUBJECT == "Revert \""* ]]; then
			COMMIT_TYPE="REVERT"
		elif [[ $COMMIT_SUBJECT == *"ANDROID:"* ]]; then
			COMMIT_TYPE="CHROMIUM"
		elif [[ $COMMIT_SUBJECT == *"UPSTREAM:"* ]]; then
			COMMIT_TYPE="UPSTREAM"
		elif [[ $COMMIT_SUBJECT == *"FROMGIT:"* ]]; then
			COMMIT_TYPE="FROMGIT"
		elif [[ $COMMIT_SUBJECT == *"FROMLIST:"* ]]; then
			COMMIT_TYPE="FROMLIST"
		elif [[ $COMMIT_SUBJECT == *"CHROMIUM:"* \
						|| $COMMIT_SUBJECT == *"CHROMIUMOS:"* \
						|| $COMMIT_SUBJECT == *"CHROMEOS:"* ]]; then
			COMMIT_TYPE="CHROMIUM"
		elif [[ $COMMIT_SUBJECT == *"BACKPORT:"* ]]; then
			readarray -t UPSTREAM_SHAS < <(
				sed -n -E -e 's/\s*\(cherry[- ]picked from commit (commit )?([a-z0-9]+)\)/\2/p' \
					<<< "$COMMIT_MSG")

			# sometimes BACKPORT: is missing UPSTREAM:
			if [[ "${#UPSTREAM_SHAS[@]}" -gt 0 ]]; then
				COMMIT_TYPE="UPSTREAM"
			fi
		fi

		# Validate the COMMIT_TYPE otherwise clear it out
		if [[ "$COMMIT_TYPE" = "UPSTREAM" || "$COMMIT_TYPE" = "FROMGIT" ]]; then

			UPSTREAM_SHA_FOUND=0
			ALREADY_MERGED=0
			IFS=' ' read -r -a UPSTREAM_SHAS <<< "${CHERRY_PICKED_FROM_COMMIT_MAP["$COMMIT_SHA"]}"
			for UPSTREAM_SHA in "${UPSTREAM_SHAS[@]}"; do
				UPSTREAM_SHA_FOUND=1

				if is-ancestor "$UPSTREAM_SHA"; then
					ALREADY_MERGED=1
					break
				fi
			done

			if [[ $ALREADY_MERGED -eq 1 ]]; then
				MERGED_UPSTREAM_COMMIT_MAP["$COMMIT_SHA"]="$UPSTREAM_SHA"
			elif [[ $UPSTREAM_SHA_FOUND -eq 0 && "$COMMIT_TYPE" != "FROMGIT" ]]; then
				echo "The following UPSTREAM hashes were not found: ${UPSTREAM_SHAS[*]}"
				echo "Is the commit misclassified?"
				COMMIT_TYPE=
			fi
		elif [[ "$COMMIT_TYPE" = "REVERT" ]]; then
			REVERTS_COMMIT="$(sed -n -E -e 's/\s*This reverts commit ([a-z0-9]+).*/\1/p' <<< "$COMMIT_MSG")"
			if [[ -z "$REVERTS_COMMIT" ]]; then
				echo "Failed to extract reverted commit: "
				COMMIT_TYPE=
			else
				REVERT_COMMIT_MAP["$COMMIT_SHA"]="$REVERTS_COMMIT"
				COMMIT_REVERTED_MAP["$REVERTS_COMMIT"]="$COMMIT_SHA"
			fi
		fi

		if [[ -n "$COMMIT_TYPE" ]]; then
			COMMIT_TYPE_MAP["$COMMIT_SHA"]="$COMMIT_TYPE"
			# Assign commit to the correct lists
			if [[ $COMMIT_TYPE == "REVERT" ]]; then
				REVERT_COMMIT_LIST+=("$COMMIT_SHA")
			elif [[ $COMMIT_TYPE == "UPSTREAM" ]]; then
				UPSTREAM_COMMIT_LIST+=("$COMMIT_SHA")
				NON_CHROMIUM_COMMIT_LIST+=("$COMMIT_SHA")
			elif [[ $COMMIT_TYPE == "FROMGIT" ]]; then
				FROMGIT_COMMIT_LIST+=("$COMMIT_SHA")
				NON_CHROMIUM_COMMIT_LIST+=("$COMMIT_SHA")
			elif [[ $COMMIT_TYPE == "FROMLIST" ]]; then
				FROMLIST_COMMIT_LIST+=("$COMMIT_SHA")
				NON_CHROMIUM_COMMIT_LIST+=("$COMMIT_SHA")
			elif [[ $COMMIT_TYPE == "CHROMIUM" ]]; then
				CHROMIUM_COMMIT_LIST+=("$COMMIT_SHA")
			else
				echo "Unknown COMMIT TYPE '$COMMIT_TYPE' for $COMMIT_SHA"
				exit 1
			fi
		else
			# Clear any bad type information
			rm -f "${WORK_DIR}/type/${COMMIT_SHA}"
			rm -f "${WORK_DIR}/type/${CHANGE_ID}"

			echo "Count: $i"
			echo "Unable to determine the type of commit ($COMMIT_SHA):"
			echo "$COMMIT_MSG"

			PS3='Commit type: '
			select OVERRIDE_TYPE in "UPSTREAM" "FROMGIT" "FROMLIST" "CHROMIUM"
			do
				if [[ -n "$OVERRIDE_TYPE" ]]; then
					break
				fi
				echo "Invalid option $OVERRIDE_TYPE. Try another one."
			done

			# We loop around
			echo "$OVERRIDE_TYPE" > "${WORK_DIR}/type/${CHANGE_ID}"
		fi
	done
done

for ARRAY_NAME in "ALL_COMMITS" "UPSTREAM_COMMIT_LIST" "FROMLIST_COMMIT_LIST" "FROMGIT_COMMIT_LIST" "CHROMIUM_COMMIT_LIST" "REVERT_COMMIT_LIST" "NON_CHROMIUM_COMMIT_LIST"; do
	declare -n ARRAY_REF="$ARRAY_NAME"
	xargs git show -s --format=oneline > "$REBASE_DIR/log/${ARRAY_NAME}.txt" <<< "${ARRAY_REF[@]}"
done

git_empty_message="The previous cherry-pick is now empty"


# Map of SHA=>Applied
declare -A POSSIBLE_PATCHES
while read -r SHA
do
	POSSIBLE_PATCHES[$SHA]=0
done < <(find "$REBASE_DIR/patch/" -type f -printf '%P\n')

# Map of SHA=>Applied
declare -A POSSIBLE_SKIP
while read -r SHA
do
	POSSIBLE_SKIP[$SHA]=0
done < <(find "$REBASE_DIR/skip/" -type f -printf '%P\n')

WORKLOG_FILE="$REBASE_DIR/work.log"
rm -f "$WORKLOG_FILE"

echo "# Source: ${REBASE_START_POINT}..${REBASE_END_POINT} ($(git rev-parse "${REBASE_START_POINT}")..$(git rev-parse "${REBASE_END_POINT}"))" >> "$WORKLOG_FILE"
echo "# Dest: $TARGET_BRANCH ($(git rev-parse "${TARGET_BRANCH}")" >> "$WORKLOG_FILE"

# src sha -> new sha
COMMIT_MAP_FILE="$REBASE_DIR/commit-map.log"
rm -f "$COMMIT_MAP_FILE"

EXISTS_IDENTICAL_FILE="$REBASE_DIR/log/exists-identical.csv"
print-csv "Local SHA" "Local Subject" "Patch ID" "Upstream SHA" "Upstream Subject" > "$EXISTS_IDENTICAL_FILE"

EXISTS_DIFFERENT_FILE="$REBASE_DIR/log/exists-different.csv"
print-csv "Local SHA" "Local Subject" "Local Patch ID" "Upstream SHA" "Upstream Subject" "Upstream Patch ID" > "$EXISTS_DIFFERENT_FILE"

EXISTS_MANUAL_FILE="$REBASE_DIR/log/exists-manual.csv"
print-csv "Local SHA" "Local Subject" "Local Patch ID" "Upstream SHA" "Upstream Subject" "Upstream Patch ID" > "$EXISTS_MANUAL_FILE"

# $1: COMMIT_SHA
# $2: UPSTREAM_SHA
function log-exists-manual() {
	local commit_sha="$1" upstream_sha="$2"
	echo "exists-manual $commit_sha as $upstream_sha" >> "$WORKLOG_FILE"

	LOCAL_PATCH_ID="$(get-patch-id "$commit_sha")"
	UPSTREAM_PATCH_ID="$(get-patch-id "$upstream_sha")"

	print-csv "$commit_sha" "$(get-subject "$commit_sha")" \
		"$LOCAL_PATCH_ID" "$upstream_sha" \
		"$(get-subject "$upstream_sha")" "$UPSTREAM_PATCH_ID" \
		>> "$EXISTS_MANUAL_FILE"
}

EXISTS_PATCH_ID_FILE="$REBASE_DIR/log/exists-patch-id.csv"
print-csv "Local SHA" "Local Subject" "Patch ID" "Commits" > "$EXISTS_PATCH_ID_FILE"

CHERRY_PICKED_FILE="$REBASE_DIR/log/cherry-picked.csv"
print-csv "Local SHA" "Local Subject" > "$CHERRY_PICKED_FILE"

CHERRY_PICKED_EMPTY_FILE="$REBASE_DIR/log/cherry-picked-empty.csv"
print-csv "Local SHA" "Local Subject" > "$CHERRY_PICKED_EMPTY_FILE"

CHERRY_PICKED_SQUASHED_FILE="$REBASE_DIR/log/cherry-picked-squashed.csv"
print-csv "Local SHA" "Local Subject" "Squashed Commits" > "$CHERRY_PICKED_SQUASHED_FILE"

REPLACE_NEXT_IDENTICAL_FILE="$REBASE_DIR/log/replace-next-identical.csv"
print-csv "Local SHA" "Local Subject" "Next Commits" > "$REPLACE_NEXT_IDENTICAL_FILE"

PATCHED_FILE="$REBASE_DIR/log/patched.csv"
print-csv "Local SHA" "Local Subject" > "$PATCHED_FILE"

SKIPPED_AUTOMATIC_FILE="$REBASE_DIR/log/skipped-automatic.csv"
print-csv "Local SHA" "Local Subject" "Reason" > "$SKIPPED_AUTOMATIC_FILE"

SKIPPED_FILE="$REBASE_DIR/log/skipped.csv"
print-csv "Local SHA" "Local Subject" "Reason" > "$SKIPPED_FILE"

i=0

# TODO: Remove this. Only so we can start after all non-chromium
# NON_CHROMIUM_COMMIT_LIST=()
# HEAD_COMMIT="2ce91fd773450954d03aee397423a8eed0373067"
# git reset --hard "$HEAD_COMMIT"

echo "Cherry picking ${#NON_CHROMIUM_COMMIT_LIST[@]} non-CHROMIUM patches. "
echo "Cherry picking ${#CHROMIUM_COMMIT_LIST[@]} CHROMIUM patches. "
for COMMIT_SHA in "${NON_CHROMIUM_COMMIT_LIST[@]}" "${CHROMIUM_COMMIT_LIST[@]}"; do
	i=$((i+1))
	echo "Processing $i: $COMMIT_SHA"

	if [[ -n "${IGNORE_LIST[$COMMIT_SHA]}" ]]; then
		echo "Ignoring $COMMIT_SHA: ${IGNORE_LIST[$COMMIT_SHA]}" >> "$WORKLOG_FILE"
		continue
	fi

	if [[ -n "${REVERT_COMMIT_MAP[$COMMIT_SHA]}" ]]; then
		echo "Skipping revert"
		echo "skip-revert $COMMIT_SHA" >> "$WORKLOG_FILE"
		continue
	fi

	if [[ -n "${COMMIT_REVERTED_MAP[$COMMIT_SHA]}" ]]; then
		echo "Skipping reverted commit"
		echo "skip-reverted $COMMIT_SHA by ${COMMIT_REVERTED_MAP[$COMMIT_SHA]}" >> "$WORKLOG_FILE"
		continue
	fi

	if [[ -e "$REBASE_DIR/upstream/$COMMIT_SHA" ]]; then
		UPSTREAM_COMMIT_SHA="$(<"$REBASE_DIR/upstream/$COMMIT_SHA")"
		log-exists-manual "$COMMIT_SHA" "$UPSTREAM_COMMIT_SHA"
		continue
	fi

	if [[ -n "${MERGED_UPSTREAM_COMMIT_MAP[$COMMIT_SHA]}" ]]; then
		UPSTREAM_COMMIT_SHA="${MERGED_UPSTREAM_COMMIT_MAP["$COMMIT_SHA"]}"
		echo "exists $COMMIT_SHA as $UPSTREAM_COMMIT_SHA" >> "$WORKLOG_FILE"

		LOCAL_PATCH_ID="$(get-patch-id "$COMMIT_SHA")"
		UPSTREAM_PATCH_ID="$(get-patch-id "$UPSTREAM_COMMIT_SHA")"

		if [[ "$LOCAL_PATCH_ID" = "$UPSTREAM_PATCH_ID" ]]; then
			print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
				"$LOCAL_PATCH_ID" "$UPSTREAM_COMMIT_SHA" \
				"$(get-subject "$UPSTREAM_COMMIT_SHA")" >> "$EXISTS_IDENTICAL_FILE"
		else
			print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
				"$LOCAL_PATCH_ID" "$UPSTREAM_COMMIT_SHA" \
				"$(get-subject "$UPSTREAM_COMMIT_SHA")" "$UPSTREAM_PATCH_ID" \
				>> "$EXISTS_DIFFERENT_FILE"
		fi
		continue;
	fi

	if [[ -n "${SQUASH_INTO_MAP[$COMMIT_SHA]}" ]]; then
		echo "Squashed, skipping"
		echo "squashed $COMMIT_SHA into ${SQUASH_INTO_MAP["$COMMIT_SHA"]}" >> "$WORKLOG_FILE"

		print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
					"squashed into ${SQUASH_INTO_MAP[$COMMIT_SHA]}" \
					>> "$SKIPPED_AUTOMATIC_FILE"
		continue;
	fi

	CHANGE_ID="${CHANGE_ID_MAP["$COMMIT_SHA"]}"
	if [[ -z "$CHANGE_ID" ]]; then
		echo "Failed to get Change-Id for $COMMIT_SHA"
		exit 1
	fi

	if ! COMMIT_MSG="$(get-msg "$COMMIT_SHA")"; then
		echo "Failed to get commit message for $COMMIT_SHA"
		exit 1
	fi

	COMMIT_TYPE="${COMMIT_TYPE_MAP["$COMMIT_SHA"]}"
	COMMIT_SUBJECT="$(get-subject "$COMMIT_SHA")"

	if [[ -e "$REBASE_DIR/skip/$COMMIT_SHA" ]]; then
		SKIP_REASON="$(<"$REBASE_DIR/skip/$COMMIT_SHA")"
		echo "skip $COMMIT_SHA $SKIP_REASON" >> "$WORKLOG_FILE"
		POSSIBLE_SKIP[$COMMIT_SHA]=1

		print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" "$SKIP_REASON" \
			>> "$SKIPPED_FILE"
		continue
	fi

	if [[ "$SKIP_ANDROID" -eq 1 && "$COMMIT_TYPE" == "CHROMIUM" && \
			"$COMMIT_SUBJECT" == *"ANDROID:"* ]]; then
		echo "skip-android $COMMIT_SHA Skipping all ANDROID changes" >> "$WORKLOG_FILE"

		print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" "ANDROID" \
			>> "$SKIPPED_AUTOMATIC_FILE"
		continue
	fi

	if [[ "$SKIP_IWL7000" -eq 1 && "$COMMIT_TYPE" == "CHROMIUM" && \
			"$COMMIT_SUBJECT" == *"iwl7000:"* ]]; then
		echo "skip-iwl7000 $COMMIT_SHA Skipping all IWL7000 changes" >> "$WORKLOG_FILE"

		print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" "IWL7000" \
			>> "$SKIPPED_AUTOMATIC_FILE"
		continue
	fi

	NEXT_COMMIT_SHAS=
	if [[ "$COMMIT_TYPE" = "FROMLIST" || "$COMMIT_TYPE" = "FROMGIT" ]]; then
		PATCH_ID="$(get-patch-id "$COMMIT_SHA")"

		if [[ -n "${ANCESTOR_PATCH_IDS["$PATCH_ID"]}" ]]; then
			echo "found $COMMIT_SHA as ${ANCESTOR_PATCH_IDS[$PATCH_ID]}"
			echo "found $COMMIT_SHA as ${ANCESTOR_PATCH_IDS[$PATCH_ID]} with patch id $PATCH_ID" >> "$WORKLOG_FILE"

			IFS=' ' read -r -a PATCH_ID_SHAS <<< "${ANCESTOR_PATCH_IDS[$PATCH_ID]}"

			print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
				"$PATCH_ID" "$(git show -s --format=oneline "${PATCH_ID_SHAS[@]}")" \
				>> "$EXISTS_PATCH_ID_FILE"
			continue
		elif [[ -n "${NEXT_PATCH_IDS["$PATCH_ID"]}" ]]; then
			NEXT_COMMIT_SHAS="${NEXT_PATCH_IDS["$PATCH_ID"]}"
		fi
	fi

	# Apply a patch before we can process the current patch.
	# Typically used to insert a commit before another one
	if [[ -e "$REBASE_DIR/pre/$COMMIT_SHA" ]]; then
		if ! git am "$REBASE_DIR/pre/$COMMIT_SHA"; then
			echo "Patch failed to apply: $REBASE_DIR/pre/$COMMIT_SHA"
			pause-script
		fi
	fi

	IFS=' ' read -r -a SQUASH_SHAS <<< "${SQUASH_MAP[$COMMIT_SHA]}"
	SQUASH_ID=

	# We have patches that could be squashed into this commit
	if [[ "${#SQUASH_SHAS[@]}" -gt 0 ]]; then
		if [[ -e "$REBASE_DIR/patch/$COMMIT_SHA" ]]; then
			# If we found a patch, we don't want to auto squash any commits.
			# The reason being that the conflict resolution and auditing gets a little
			# tricky. So we only apply the squashed commit if it applies cleanly.
			unset SQUASH_MAP["$COMMIT_SHA"]
			for SQUASH_SHA in "${SQUASH_SHAS[@]}"; do
				unset SQUASH_INTO_MAP["$SQUASH_SHA"]
			done
		else
			# This sets SQUASH_ID on completion
			if ! generate-squashed-patch "$COMMIT_SHA"; then
				# If we can't auto generate the squash then skip it
				unset SQUASH_MAP["$COMMIT_SHA"]
				for SQUASH_SHA in "${SQUASH_SHAS[@]}"; do
					unset SQUASH_INTO_MAP["$SQUASH_SHA"]
				done
			fi
		fi
	fi

	APPLIED=0

	GIT_ABORT_CMD=()

	if [[ -e "$REBASE_DIR/patch/$COMMIT_SHA" ]]; then
		GIT_ABORT_CMD=(am --abort)
		if ! git am "$REBASE_DIR/patch/$COMMIT_SHA"; then
			echo "Patch failed to apply: $REBASE_DIR/patch/$COMMIT_SHA"
			echo "Moving patch to $REBASE_DIR/patch/$COMMIT_SHA.bad"
			mv "$REBASE_DIR/patch/$COMMIT_SHA" "$REBASE_DIR/patch/$COMMIT_SHA.bad"
		else
			echo "am $COMMIT_SHA using ./$REBASE_ID/patch/$COMMIT_SHA" >> "$WORKLOG_FILE"

			print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
				>> "$PATCHED_FILE"

			POSSIBLE_PATCHES[$COMMIT_SHA]=1
			APPLIED=1
		fi
	else
		if [[ -n "$SQUASH_ID" ]]; then
			GIT_ABORT_CMD=(am --abort)
			if git am -3 "$CACHE_DIR/squash/$SQUASH_ID"; then
				echo "cherry-pick-squash $COMMIT_SHA squashed ${SQUASH_SHAS[*]}" >> "$WORKLOG_FILE"

				print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
					"$(git show -s --format=oneline "${SQUASH_SHAS[@]}")" \
					>> "$CHERRY_PICKED_SQUASHED_FILE"

				APPLIED=1
			else
				echo "Squash patch failed to apply: $CACHE_DIR/squash/$SQUASH_ID"
				echo "Dropping squashed patch and applying original"
				git "${GIT_ABORT_CMD[@]}"

				SQUASH_ID=
				unset SQUASH_MAP["$COMMIT_SHA"]
				for SQUASH_SHA in "${SQUASH_SHAS[@]}"; do
					unset SQUASH_INTO_MAP["$SQUASH_SHA"]
				done
			fi
		fi

		if [[ $APPLIED -eq 0 ]]; then
			GIT_ABORT_CMD=(cherry-pick --abort)
			if out="$(git cherry-pick "$COMMIT_SHA" 2>&1)"; then
				echo "$out"

				if [[ -z "$NEXT_COMMIT_SHAS" ]]; then
					echo "cherry-pick $COMMIT_SHA" >> "$WORKLOG_FILE"
					print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
						>> "$CHERRY_PICKED_FILE"
				else
					# Since the patch IDs are identical, this is really just for
					# tracking what has already been accepted by the maintainers
					echo "replace-next $COMMIT_SHA with identical $NEXT_COMMIT_SHAS" >> "$WORKLOG_FILE"

					IFS=' ' read -r -a NEXT_COMMIT_SHA_LIST <<< "${NEXT_COMMIT_SHAS}"

					print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
						"$(git show -s --format=oneline "${NEXT_COMMIT_SHA_LIST[@]}")" \
						>> "$REPLACE_NEXT_IDENTICAL_FILE"
				fi
				APPLIED=1
			elif [[ $out = *"$git_empty_message"* ]]; then
				echo "$COMMIT_SHA has already been applied"
				echo "skip-empty $COMMIT_SHA" >> "$WORKLOG_FILE"
				print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
					>> "$CHERRY_PICKED_EMPTY_FILE"
				continue
			else
				echo "$out"
			fi
		fi
	fi

	if [[ $APPLIED -eq 0 ]]; then
		# cherry-pick failed
		echo "---------"

		if [[ "$COMMIT_TYPE" = "CHROMIUM" ]]; then
			# iwl7000 cls seem to be cherry picked multiple times in different branches
			echo "Checking to see if commit was already merged."
			readarray -t CHANGE_IDS < <(
				sed -n -E -e 's/^\s*Change-Id: ([a-zA-Z0-9]+)\s*$/\1/p' <<< "$COMMIT_MSG")

			MATCHING_COMMIT=""
			for CHANGE_ID in "${CHANGE_IDS[@]}"; do
				echo "Searching for Change-Id: $CHANGE_ID"

				if search-for-possible-commit "$COMMIT_SHA" "$CHANGE_ID"; then
					MATCHING_COMMIT="$POSSIBLE_COMMIT_SHA"
					break
				fi
			done

			if [[ -n "$MATCHING_COMMIT" ]]; then
				git "${GIT_ABORT_CMD[@]}"
				reason="duplicate of $MATCHING_COMMIT"
				echo "$reason" > "$REBASE_DIR/skip/$COMMIT_SHA"
				echo "skip $COMMIT_SHA $reason" >> "$WORKLOG_FILE"
				continue
			else
				echo "Please merge manually."
			fi
		else
			echo "Checking to see if commit was already merged."
			COMMIT_MSG_HEADER="$(sanitize-subject "$(head -n 1 <<< "$COMMIT_MSG")")"

			MATCHING_COMMIT=""
			if search-for-possible-commit "$COMMIT_SHA" "$COMMIT_MSG_HEADER"; then
				MATCHING_COMMIT="$POSSIBLE_COMMIT_SHA"
			fi

			if [[ -n "$MATCHING_COMMIT" ]]; then
				git "${GIT_ABORT_CMD[@]}"
				echo "$MATCHING_COMMIT" > "$REBASE_DIR/upstream/$COMMIT_SHA"
				log-exists-manual "$COMMIT_SHA" "$MATCHING_COMMIT"
				continue
			elif [[ "$COMMIT_TYPE" == "FROMGIT" && "$COMMIT_SUBJECT" == *"BACKPORT:"* ]]; then
				echo "Failed to automatically find commit upstream"
				echo "Going to try to cherry-pick original commit"
				git "${GIT_ABORT_CMD[@]}"

				if try-cherry-pick-original "$COMMIT_SHA"; then
					reason="replace $COMMIT_SHA with $MATCHING_COMMIT"
					echo "$reason"
					echo "reason" >> "$WORKLOG_FILE"

					git format-patch -1 HEAD --stdout > "$REBASE_DIR/patch/$COMMIT_SHA"
					git format-patch -1 "$COMMIT_SHA" --stdout > "$REBASE_DIR/orig/$COMMIT_SHA"

					APPLIED=1
				else
					echo "Failed to cherry-pick original"
					echo "Going to cherry-pick the BACKPORT commit so you can fix it"
					GIT_ABORT_CMD=(cherry-pick --abort)

					# TODO(rrangel): This wrong since we might have had a patch
					git cherry-pick "$COMMIT_SHA" || true
				fi
			else
				echo "Failed to automatically find commit upstream"
			fi
		fi
	fi

	# Automatically locating the commit failed.
	# Prompt for an upstream commit SHA if one exists.
	if [[ $APPLIED -eq 0 ]]; then

		readarray -t CONFLICTING_FILES < <(git diff --name-only --diff-filter=U)

		gitk "$COMMIT_SHA" &
		GITK_PIDS+=($!)
		sleep 0.1 # Just so the windows open in some kind of order

		for RESOLVED_PATH in "${CONFLICTING_FILES[@]}"; do
			gitk "$REBASE_END_POINT" -- "$RESOLVED_PATH" &
			GITK_PIDS+=($!)
			sleep 0.1

			gitk "HEAD" -- "$RESOLVED_PATH" &
			GITK_PIDS+=($!)
		done

		UPSTREAM_SHA=
		if [[ "$COMMIT_TYPE" != "CHROMIUM" ]]; then
			git status
			echo "Enter the upstream commit if there is one, otherwise leave blank to manually handle the conflict"
			echo -n "Upstream SHA: "
			read -r UPSTREAM_SHA

			if [[ -n "$UPSTREAM_SHA" ]]; then
				if prompt-is-commit "$COMMIT_SHA" "$UPSTREAM_SHA"; then
					kill-gitk
					git "${GIT_ABORT_CMD[@]}"

					echo "$UPSTREAM_SHA" > "$REBASE_DIR/upstream/$COMMIT_SHA"
					log-exists-manual "$COMMIT_SHA" "$UPSTREAM_SHA"

					APPLIED=1
				fi
			fi
		fi
	fi

	# Manually handle the conflict
	if [[ $APPLIED -eq 0 ]]; then
		MERGE_MSG="$(git rev-parse --git-path MERGE_MSG)"
		if [[ -z "$MERGE_MSG" ]]; then
			echo "Failed to modify MERGE_MSG, please do it manually"
		else
			cat <<-EOF >> "$MERGE_MSG"
				[${REBASE_ID}($USER):
				* Conflicts:
				$(printf "  * %s\\n" "${CONFLICTING_FILES[@]}")
				]
			EOF
			if ! grep -q '^Change-Id:' "$MERGE_MSG"; then
				echo -e "Change-Id: $CHANGE_ID" >> "$MERGE_MSG"
			fi
			echo "Signed-off-by: $(git config user.name) <$(git config user.email)>" >> "$MERGE_MSG"
		fi

		pause-script

		while git status| grep -q cherry-picking; do
			echo "Cherry pick still in progress."
			pause-script
		done

		kill-gitk

		PS3='Result: '
		select opt in "Backport" "Skip" "Wrong Type" "Fixed" "Quit"
		do
			if [[ -z "$opt" ]]; then
				echo "Invalid option $opt. Try another one."
				continue
			fi

			case $opt in
				"Backport")
					git format-patch -1 HEAD --stdout > "$REBASE_DIR/patch/$COMMIT_SHA"
					if [[ ! -e "$REBASE_DIR/orig/$COMMIT_SHA" ]]; then
						git format-patch -1 "$COMMIT_SHA" --stdout > "$REBASE_DIR/orig/$COMMIT_SHA"
					fi

					if ! prompt-difftool "$REBASE_DIR/orig/$COMMIT_SHA" \
							"$REBASE_DIR/patch/$COMMIT_SHA" \
							"Does the patch look correct? "; then
						echo "Fix the commit and then \`git commit --amend\`"
						pause-script
						continue
					fi

					echo "backport $COMMIT_SHA from $REBASE_DIR/patch/$COMMIT_SHA" >> "$WORKLOG_FILE"
					POSSIBLE_PATCHES[$COMMIT_SHA]=1

					print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" \
						>> "$PATCHED_FILE"

					APPLIED=1
					break
					;;
				"Upstream")
					echo -n "Upstream SHA: "
					read -r UPSTREAM_SHA

					if [[ -n "$UPSTREAM_SHA" ]]; then
						if prompt-is-commit "$COMMIT_SHA" "$UPSTREAM_SHA"; then
							kill-gitk
							git "${GIT_ABORT_CMD[@]}"

							echo "$UPSTREAM_SHA" > "$REBASE_DIR/upstream/$COMMIT_SHA"
							log-exists-manual "$COMMIT_SHA" "$UPSTREAM_SHA"
						else
							continue
						fi
					else
						continue
					fi
					break
					;;
				"Skip")
					read -r -p 'reason: ' reason
					echo "$reason" > "$REBASE_DIR/skip/$COMMIT_SHA"
					echo "skip $COMMIT_SHA $reason" >> "$WORKLOG_FILE"

					print-csv "$COMMIT_SHA" "$(get-subject "$COMMIT_SHA")" "$reason" \
						>> "$SKIPPED_FILE"
					break
					;;
				"Wrong Type")
					read -r -p 'new type: ' OVERRIDE_TYPE
					echo "$OVERRIDE_TYPE" > "${WORK_DIR}/type/${CHANGE_ID}"
					break
					;;
				"Fixed")
					break
					;;
				"Quit")
					exit 1
					;;
				*)
					echo "Unknown option: '$opt'"
					exit 1
					;;
			esac
		done
	fi

	if [[ $APPLIED -eq 1 ]]; then
		echo "$COMMIT_SHA $(git rev-parse HEAD)" >> "$COMMIT_MAP_FILE"

		# TODO(rrangel): We can add a build test here
	fi
done

for COMMIT_SHA in "${!POSSIBLE_PATCHES[@]}"
do
	if [[ "${POSSIBLE_PATCHES[$COMMIT_SHA]}" -eq 0 ]]; then
		echo "rm $REBASE_DIR/patch/$COMMIT_SHA $REBASE_DIR/patch/${COMMIT_SHA}.orig"
	fi
done

for COMMIT_SHA in "${!POSSIBLE_SKIP[@]}"
do
	if [[ "${POSSIBLE_SKIP[$COMMIT_SHA]}" -eq 0 ]]; then
		echo "rm $REBASE_DIR/skip/$COMMIT_SHA"
	fi
done


echo "Done!"

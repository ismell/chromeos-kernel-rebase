From 65cd67231ce06e5f562f68e9367839fcb81d4edc Mon Sep 17 00:00:00 2001
From: Micah Morton <mortonm@chromium.org>
Date: Fri, 11 May 2018 13:35:16 -0700
Subject: [PATCH] CHROMIUM: Add process mgmt security policies to chromiumos
 LSM

Enable support for configuring per-user policies in CrOS that restrict
which UIDs can be switched to by processes running under that user
(process must first have CAP_SETUID).

doc:
https://docs.google.com/document/d/1yYpayuOsZ_v-Ey8AZJoUAOVaxpKhojLad7PidCndjRM/edit?pli=1#

Following this CL, we will add support for similar exceptions for the
setgid() and kill() syscalls, which will use same whitelist to allow
exceptions to be made for these syscalls in similar process management situations.

NOTE: corresponding CLs in same topic are listed below.
init - CL:1062656
autotest - CL:1064698
overlays - CL:1068077
shill - CL:1222569, CL:1222788

BUG=chromium:845640, chromium:649417
TEST=autotest in CL:1064698 passes. also tested as part of larger shill
sandbox debug CL

Change-Id: Ie0d6b1534606b0016310a369f0ec34cffb553b14
Signed-off-by: Micah Morton <mortonm@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/1321178
Reviewed-by: Dmitry Torokhov <dtor@chromium.org>
---
 security/chromiumos/alt-syscall.c             |   3 -
 security/chromiumos/lsm.c                     | 328 +++++++++++++-
 security/chromiumos/process_management.h      |  38 ++
 security/chromiumos/process_tree_whitelists.h | 407 ------------------
 security/chromiumos/securityfs.c              | 159 +++++++
 5 files changed, 520 insertions(+), 415 deletions(-)
 create mode 100644 security/chromiumos/process_management.h
 delete mode 100644 security/chromiumos/process_tree_whitelists.h

diff --git a/security/chromiumos/alt-syscall.c b/security/chromiumos/alt-syscall.c
index 4fc09240ce08..29d567ad9557 100644
--- a/security/chromiumos/alt-syscall.c
+++ b/security/chromiumos/alt-syscall.c
@@ -25,7 +25,6 @@
 
 #include "alt-syscall.h"
 #include "android_whitelists.h"
-#include "process_tree_whitelists.h"
 #include "read_write_test_whitelists.h"
 #include "third_party_whitelists.h"
 
@@ -393,8 +392,6 @@ static struct syscall_whitelist whitelists[] = {
 	PERMISSIVE_SYSCALL_WHITELIST(android),
 	SYSCALL_WHITELIST(third_party),
 	PERMISSIVE_SYSCALL_WHITELIST(third_party),
-	SYSCALL_WHITELIST(process_tree),
-	PERMISSIVE_SYSCALL_WHITELIST(process_tree)
 };
 
 static int alt_syscall_apply_whitelist(const struct syscall_whitelist *wl,
diff --git a/security/chromiumos/lsm.c b/security/chromiumos/lsm.c
index 0274caf233a1..bc124982c403 100644
--- a/security/chromiumos/lsm.c
+++ b/security/chromiumos/lsm.c
@@ -19,19 +19,59 @@
 
 #define pr_fmt(fmt) "Chromium OS LSM: " fmt
 
-#include <linux/module.h>
-#include <linux/security.h>
-#include <linux/lsm_hooks.h>
-#include <linux/sched.h>	/* current and other task related stuff */
-#include <linux/namei.h>	/* for nameidata_get_total_link_count */
+#include <asm/syscall.h>
+#include <linux/cred.h>
 #include <linux/fs.h>
 #include <linux/fs_struct.h>
+#include <linux/hashtable.h>
+#include <linux/lsm_hooks.h>
+#include <linux/module.h>
 #include <linux/mount.h>
+#include <linux/namei.h>	/* for nameidata_get_total_link_count */
 #include <linux/path.h>
+#include <linux/ptrace.h>
+#include <linux/sched/task_stack.h>
+#include <linux/sched.h>	/* current and other task related stuff */
+#include <linux/security.h>
 
 #include "inode_mark.h"
+#include "process_management.h"
 #include "utils.h"
 
+#define NUM_BITS 8 // 128 buckets in hash table
+
+static DEFINE_HASHTABLE(process_setuid_policy_hashtable, NUM_BITS);
+
+/*
+ * Bool signifying whether to disable fixups for process management related
+ * routines in the kernel (setuid, setgid, kill). Default value is false. Can
+ * be overridden by 'disable_process_management_policies' flag. Static vars get
+ * initialized to 0/false since in BSS.
+ **/
+static bool disable_process_management_policies;
+
+/* Disable process management policies if flag passed */
+static int set_disable_process_management_policies(char *str)
+{
+	disable_process_management_policies = true;
+	return 1;
+}
+__setup("disable_process_management_policies=",
+	set_disable_process_management_policies);
+
+/*
+ * Hash table entry to store process management policy signifying that 'parent'
+ * user can use 'child' user for process management (for now that just means
+ * 'parent' can set*uid() to 'child'). Will be adding exceptions for set*gid()
+ * and kill() in the future.
+ */
+struct entry {
+	struct hlist_node next;
+	struct hlist_node dlist; /* for deletion cleanup */
+	uint64_t parent_kuid;
+	uint64_t child_kuid;
+};
+
 #if defined(CONFIG_SECURITY_CHROMIUMOS_NO_UNPRIVILEGED_UNSAFE_MOUNTS) || \
 	defined(CONFIG_SECURITY_CHROMIUMOS_NO_SYMLINK_MOUNT)
 static void report(const char *origin, const struct path *path, char *operation)
@@ -145,6 +185,8 @@ static int chromiumos_security_sb_mount(const char *dev_name,
 	return 0;
 }
 
+static DEFINE_SPINLOCK(process_setuid_policy_hashtable_spinlock);
+
 static int chromiumos_security_inode_follow_link(struct dentry *dentry,
 						 struct inode *inode, bool rcu)
 {
@@ -196,12 +238,288 @@ static int chromiumos_security_file_open(struct file *file)
 	return policy == CHROMIUMOS_INODE_POLICY_BLOCK ? -EACCES : 0;
 }
 
+bool chromiumos_check_setuid_policy_hashtable_key(kuid_t parent)
+{
+	struct entry *entry;
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu(process_setuid_policy_hashtable,
+				   entry, next, __kuid_val(parent)) {
+		if (entry->parent_kuid == __kuid_val(parent)) {
+			rcu_read_unlock();
+			return true;
+		}
+	}
+	rcu_read_unlock();
+
+	/*
+	 * Using RCU, its possible that a policy gets added in between the time
+	 * we check above and when we return false here. This is fine, since
+	 * policy updates only happen during system startup, well before
+	 * sandboxed system services start running and the policies need to be
+	 * queried.
+	 */
+	return false;
+}
+
+bool chromiumos_check_setuid_policy_hashtable_key_value(kuid_t parent,
+							kuid_t child)
+{
+	struct entry *entry;
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu(process_setuid_policy_hashtable,
+				   entry, next, __kuid_val(parent)) {
+		if (entry->parent_kuid == __kuid_val(parent) &&
+		    entry->child_kuid == __kuid_val(child)) {
+			rcu_read_unlock();
+			return true;
+		}
+	}
+	rcu_read_unlock();
+
+	/*
+	 * Using RCU, its possible that a policy gets added in between the time
+	 * we check above and when we return false here. This is fine, since
+	 * policy updates only happen during system startup, well before
+	 * sandboxed system services start running and the policies need to be
+	 * queried.
+	 */
+	return false;
+}
+
+bool setuid_syscall(int num)
+{
+#ifdef CONFIG_X86_64
+	if (!(num == __NR_setreuid ||
+	      num == __NR_setuid ||
+	      num == __NR_setresuid ||
+	      num == __NR_setfsuid))
+		return false;
+#elif defined CONFIG_ARM64
+	if (!(num == __NR_compat_setuid ||
+	      num == __NR_compat_setreuid ||
+	      num == __NR_compat_setfsuid ||
+	      num == __NR_compat_setresuid ||
+	      num == __NR_compat_setreuid32 ||
+	      num == __NR_compat_setresuid32 ||
+	      num == __NR_compat_setuid32 ||
+	      num == __NR_compat_setfsuid32))
+		return false;
+#else /* CONFIG_ARM */
+	if (!(num == __NR_setreuid32 ||
+	      num == __NR_setuid32 ||
+	      num == __NR_setresuid32 ||
+	      num == __NR_setfsuid32))
+		return false;
+#endif
+	return true;
+}
+
+int chromiumos_security_capable(const struct cred *cred,
+				struct user_namespace *ns,
+				int cap,
+				unsigned int opts)
+{
+	/* The current->mm check will fail if this is a kernel thread. */
+	if (!disable_process_management_policies &&
+	    cap == CAP_SETUID &&
+	    current->mm &&
+	    chromiumos_check_setuid_policy_hashtable_key(cred->uid)) {
+		// syscall_get_nr can theoretically return 0 or -1, but that
+		// would signify that the syscall is being aborted due to a
+		// signal, so we don't need to check for this case here.
+		if (!(opts & CAP_OPT_INSETID))
+			// Deny if we're not in a set*uid() syscall to avoid
+			// giving powers gated by CAP_SETUID that are related
+			// to functionality other than calling set*uid() (e.g.
+			// allowing user to set up userns uid mappings).
+			return -1;
+	}
+	return 0;
+}
+
+/*
+ * Emit a warning when no entry found in whitelist. These will show up in
+ * kernel warning reports collected by the crash reporter, so we have some
+ * insight regarding failures that need addressing.
+ */
+void chromiumos_setuid_policy_warning(kuid_t parent, kuid_t child)
+{
+	WARN(1,
+	     "UID %u is restricted to using certain whitelisted UIDs for process management, and %u is not in the whitelist.\n",
+	     __kuid_val(parent),
+	     __kuid_val(child));
+}
+
+int chromiumos_check_uid_transition(kuid_t parent, kuid_t child)
+{
+	if (chromiumos_check_setuid_policy_hashtable_key_value(parent, child))
+		return 0;
+	chromiumos_setuid_policy_warning(parent, child);
+	return -1;
+}
+
+/*
+ * Check whether there is either an exception for user under old cred struct to
+ * use user under new cred struct, or the UID transition is allowed (by Linux
+ * set*uid rules) even without CAP_SETUID.
+ */
+int chromiumos_security_task_fix_setuid(struct cred *new,
+					const struct cred *old, int flags)
+{
+
+	/*
+	 * Do nothing if feature is turned off by kernel compile flag or there
+	 * are no setuid restrictions for this UID.
+	 */
+	if (disable_process_management_policies ||
+	    !chromiumos_check_setuid_policy_hashtable_key(old->uid))
+		return 0;
+
+	switch (flags) {
+	case LSM_SETID_RE:
+		/*
+		 * Users for which setuid restrictions exist can only set the
+		 * real UID to the real UID or the effective UID, unless an
+		 * explicit whitelist policy allows the transition.
+		 */
+		if (!uid_eq(old->uid, new->uid) &&
+			!uid_eq(old->euid, new->uid)) {
+			return chromiumos_check_uid_transition(old->uid,
+								new->uid);
+		}
+		/*
+		 * Users for which setuid restrictions exist can only set the
+		 * effective UID to the real UID, the effective UID, or the
+		 * saved set-UID, unless an explicit whitelist policy allows
+		 * the transition.
+		 */
+		if (!uid_eq(old->uid, new->euid) &&
+			!uid_eq(old->euid, new->euid) &&
+			!uid_eq(old->suid, new->euid)) {
+			return chromiumos_check_uid_transition(old->euid,
+								new->euid);
+		}
+		break;
+	case LSM_SETID_ID:
+		/*
+		 * Users for which setuid restrictions exist cannot change the
+		 * real UID or saved set-UID unless an explicit whitelist
+		 * policy allows the transition.
+		 */
+		if (!uid_eq(old->uid, new->uid)) {
+			return chromiumos_check_uid_transition(old->uid,
+								new->uid);
+		}
+		if (!uid_eq(old->suid, new->suid)) {
+			return chromiumos_check_uid_transition(old->suid,
+								new->suid);
+		}
+		break;
+	case LSM_SETID_RES:
+		/*
+		 * Users for which setuid restrictions exist cannot change the
+		 * real UID, effective UID, or saved set-UID to anything but
+		 * one of: the current real UID, the current effective UID or
+		 * the current saved set-user-ID unless an explicit whitelist
+		 * policy allows the transition.
+		 */
+		if (!uid_eq(new->uid, old->uid) &&
+			!uid_eq(new->uid, old->euid) &&
+			!uid_eq(new->uid, old->suid)) {
+			return chromiumos_check_uid_transition(old->uid,
+								new->uid);
+		}
+		if (!uid_eq(new->euid, old->uid) &&
+			!uid_eq(new->euid, old->euid) &&
+			!uid_eq(new->euid, old->suid)) {
+			return chromiumos_check_uid_transition(old->euid,
+								new->euid);
+		}
+		if (!uid_eq(new->suid, old->uid) &&
+			!uid_eq(new->suid, old->euid) &&
+			!uid_eq(new->suid, old->suid)) {
+			return chromiumos_check_uid_transition(old->suid,
+								new->suid);
+		}
+		break;
+	case LSM_SETID_FS:
+		/*
+		 * Users for which setuid restrictions exist cannot change the
+		 * filesystem UID to anything but one of: the current real UID,
+		 * the current effective UID or the current saved set-UID
+		 * unless an explicit whitelist policy allows the transition.
+		 */
+		if (!uid_eq(new->fsuid, old->uid)  &&
+			!uid_eq(new->fsuid, old->euid)  &&
+			!uid_eq(new->fsuid, old->suid) &&
+			!uid_eq(new->fsuid, old->fsuid)) {
+			return chromiumos_check_uid_transition(old->fsuid,
+								new->fsuid);
+		}
+		break;
+	}
+	return 0;
+}
+
 static struct security_hook_list chromiumos_security_hooks[] = {
 	LSM_HOOK_INIT(sb_mount, chromiumos_security_sb_mount),
 	LSM_HOOK_INIT(inode_follow_link, chromiumos_security_inode_follow_link),
 	LSM_HOOK_INIT(file_open, chromiumos_security_file_open),
+	LSM_HOOK_INIT(capable, chromiumos_security_capable),
+	LSM_HOOK_INIT(task_fix_setuid, chromiumos_security_task_fix_setuid),
 };
 
+/* Add process management policy to hash table */
+int chromiumos_add_process_management_entry(kuid_t parent, kuid_t child)
+{
+	struct entry *new;
+
+	/* Return if entry already exists */
+	if (chromiumos_check_setuid_policy_hashtable_key_value(parent,
+							       child))
+		return 0;
+
+	new = kzalloc(sizeof(struct entry), GFP_KERNEL);
+	if (!new)
+		return -ENOMEM;
+	new->parent_kuid = __kuid_val(parent);
+	new->child_kuid = __kuid_val(child);
+	spin_lock(&process_setuid_policy_hashtable_spinlock);
+	hash_add_rcu(process_setuid_policy_hashtable,
+		     &new->next,
+		     __kuid_val(parent));
+	spin_unlock(&process_setuid_policy_hashtable_spinlock);
+	return 0;
+}
+
+void chromiumos_flush_process_management_entries(void)
+{
+	struct entry *entry;
+	struct hlist_node *hlist_node;
+	unsigned int bkt_loop_cursor;
+	HLIST_HEAD(free_list);
+
+	/*
+	 * Could probably use hash_for_each_rcu here instead, but this should
+	 * be fine as well.
+	 */
+	spin_lock(&process_setuid_policy_hashtable_spinlock);
+	hash_for_each_safe(process_setuid_policy_hashtable, bkt_loop_cursor,
+			   hlist_node, entry, next) {
+		hash_del_rcu(&entry->next);
+		hlist_add_head(&entry->dlist, &free_list);
+	}
+	spin_unlock(&process_setuid_policy_hashtable_spinlock);
+	synchronize_rcu();
+	hlist_for_each_entry_safe(entry, hlist_node, &free_list, dlist) {
+		hlist_del(&entry->dlist);
+		kfree(entry);
+	}
+}
+
 static int __init chromiumos_security_init(void)
 {
 	security_add_hooks(chromiumos_security_hooks,
diff --git a/security/chromiumos/process_management.h b/security/chromiumos/process_management.h
new file mode 100644
index 000000000000..85538fc2d83e
--- /dev/null
+++ b/security/chromiumos/process_management.h
@@ -0,0 +1,38 @@
+/*
+ * Linux Security Module for Chromium OS
+ *
+ * Copyright 2018 Google LLC. All Rights Reserved
+ *
+ * Author:
+ *      Micah Morton       <mortonm@chromium.org>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SECURITY_PROCESS_MANAGEMENT_H
+#define _SECURITY_PROCESS_MANAGEMENT_H
+
+#include <linux/types.h>
+
+/* Function type. */
+enum chromiumos_process_management_file_write_type {
+	CHROMIUMOS_PROCESS_MANAGEMENT_ADD, /* Add whitelist policy. */
+	CHROMIUMOS_PROCESS_MANAGEMENT_FLUSH, /* Flush whitelist policies. */
+};
+
+/*
+ * Add entry to chromiumos process management policies to allow user 'parent'
+ * to use user 'child' for process management.
+ */
+int chromiumos_add_process_management_entry(kuid_t parent, kuid_t child);
+
+void chromiumos_flush_process_management_entries(void);
+
+#endif /* _SECURITY_PROCESS_MANAGEMENT_H */
diff --git a/security/chromiumos/process_tree_whitelists.h b/security/chromiumos/process_tree_whitelists.h
deleted file mode 100644
index b5213b231991..000000000000
--- a/security/chromiumos/process_tree_whitelists.h
+++ /dev/null
@@ -1,407 +0,0 @@
-/*
- * Linux Security Module for Chromium OS
- *
- * Copyright 2018 Google LLC. All Rights Reserved
- *
- * Authors:
- *      Micah Morton <mortonm@chromium.org>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef PROCESS_TREE_WHITELISTS_H
-#define PROCESS_TREE_WHITELISTS_H
-
-/*
- * NOTE: the purpose of this header is only to pull out the definition of this
- * array from alt-syscall.c for the purposes of readability. It should not be
- * included in other .c files.
- */
-
-#include "alt-syscall.h"
-
-static struct syscall_whitelist_entry process_tree_whitelist[] = {
-	/* Syscalls wired up on ARM32/ARM64 and x86_64. */
-	SYSCALL_ENTRY(accept),
-	SYSCALL_ENTRY(accept4),
-	SYSCALL_ENTRY(acct),
-	SYSCALL_ENTRY(add_key),
-	SYSCALL_ENTRY(adjtimex),
-	SYSCALL_ENTRY(bind),
-	SYSCALL_ENTRY(brk),
-	SYSCALL_ENTRY(capget),
-	SYSCALL_ENTRY(capset),
-	SYSCALL_ENTRY(chdir),
-	SYSCALL_ENTRY(chroot),
-	SYSCALL_ENTRY(clock_adjtime),
-	SYSCALL_ENTRY(clock_getres),
-	SYSCALL_ENTRY(clock_gettime),
-	SYSCALL_ENTRY(clock_nanosleep),
-	SYSCALL_ENTRY(clock_settime),
-	SYSCALL_ENTRY(clone),
-	SYSCALL_ENTRY(close),
-	SYSCALL_ENTRY(connect),
-	SYSCALL_ENTRY(copy_file_range),
-	SYSCALL_ENTRY(delete_module),
-	SYSCALL_ENTRY(dup),
-	SYSCALL_ENTRY(dup3),
-	SYSCALL_ENTRY(epoll_create1),
-	SYSCALL_ENTRY(epoll_ctl),
-	SYSCALL_ENTRY(epoll_pwait),
-	SYSCALL_ENTRY(eventfd2),
-	SYSCALL_ENTRY(execve),
-	SYSCALL_ENTRY(exit),
-	SYSCALL_ENTRY(exit_group),
-	SYSCALL_ENTRY(faccessat),
-	SYSCALL_ENTRY(fallocate),
-	SYSCALL_ENTRY(fanotify_init),
-	SYSCALL_ENTRY(fanotify_mark),
-	SYSCALL_ENTRY(fchdir),
-	SYSCALL_ENTRY(fchmod),
-	SYSCALL_ENTRY(fchmodat),
-	SYSCALL_ENTRY(fchown),
-	SYSCALL_ENTRY(fchownat),
-	SYSCALL_ENTRY(fcntl),
-	SYSCALL_ENTRY(fdatasync),
-	SYSCALL_ENTRY(fgetxattr),
-	SYSCALL_ENTRY(finit_module),
-	SYSCALL_ENTRY(flistxattr),
-	SYSCALL_ENTRY(flock),
-	SYSCALL_ENTRY(fremovexattr),
-	SYSCALL_ENTRY(fsetxattr),
-	SYSCALL_ENTRY(fstatfs),
-	SYSCALL_ENTRY(fsync),
-	SYSCALL_ENTRY(ftruncate),
-	SYSCALL_ENTRY(futex),
-	SYSCALL_ENTRY(getcpu),
-	SYSCALL_ENTRY(getcwd),
-	SYSCALL_ENTRY(getdents64),
-	SYSCALL_ENTRY(getegid),
-	SYSCALL_ENTRY(geteuid),
-	SYSCALL_ENTRY(getgid),
-	SYSCALL_ENTRY(getgroups),
-	SYSCALL_ENTRY(getitimer),
-	SYSCALL_ENTRY(get_mempolicy),
-	SYSCALL_ENTRY(getpeername),
-	SYSCALL_ENTRY(getpgid),
-	SYSCALL_ENTRY(getpid),
-	SYSCALL_ENTRY(getppid),
-	SYSCALL_ENTRY(getpriority),
-	SYSCALL_ENTRY(getrandom),
-	SYSCALL_ENTRY(getresgid),
-	SYSCALL_ENTRY(getresuid),
-	SYSCALL_ENTRY(getrlimit),
-	SYSCALL_ENTRY(get_robust_list),
-	SYSCALL_ENTRY(getrusage),
-	SYSCALL_ENTRY(getsid),
-	SYSCALL_ENTRY(getsockname),
-	SYSCALL_ENTRY(getsockopt),
-	SYSCALL_ENTRY(gettid),
-	SYSCALL_ENTRY(gettimeofday),
-	SYSCALL_ENTRY(getuid),
-	SYSCALL_ENTRY(getxattr),
-	SYSCALL_ENTRY(init_module),
-	SYSCALL_ENTRY(inotify_add_watch),
-	SYSCALL_ENTRY(inotify_init1),
-	SYSCALL_ENTRY(inotify_rm_watch),
-	SYSCALL_ENTRY(io_cancel),
-	SYSCALL_ENTRY(ioctl),
-	SYSCALL_ENTRY(io_destroy),
-	SYSCALL_ENTRY(io_getevents),
-	SYSCALL_ENTRY(ioprio_get),
-	SYSCALL_ENTRY(ioprio_set),
-	SYSCALL_ENTRY(io_setup),
-	SYSCALL_ENTRY(io_submit),
-	SYSCALL_ENTRY(kcmp),
-	SYSCALL_ENTRY(kexec_load),
-	SYSCALL_ENTRY(keyctl),
-	SYSCALL_ENTRY(kill),
-	SYSCALL_ENTRY(lgetxattr),
-	SYSCALL_ENTRY(linkat),
-	SYSCALL_ENTRY(listen),
-	SYSCALL_ENTRY(listxattr),
-	SYSCALL_ENTRY(llistxattr),
-	SYSCALL_ENTRY(lookup_dcookie),
-	SYSCALL_ENTRY(lremovexattr),
-	SYSCALL_ENTRY(lseek),
-	SYSCALL_ENTRY(lsetxattr),
-	SYSCALL_ENTRY(madvise),
-	SYSCALL_ENTRY(mbind),
-	SYSCALL_ENTRY(memfd_create),
-	SYSCALL_ENTRY(mincore),
-	SYSCALL_ENTRY(mkdirat),
-	SYSCALL_ENTRY(mknodat),
-	SYSCALL_ENTRY(mlock),
-	SYSCALL_ENTRY(mlockall),
-	SYSCALL_ENTRY(mount),
-	SYSCALL_ENTRY(move_pages),
-	SYSCALL_ENTRY(mprotect),
-	SYSCALL_ENTRY(mq_getsetattr),
-	SYSCALL_ENTRY(mq_notify),
-	SYSCALL_ENTRY(mq_open),
-	SYSCALL_ENTRY(mq_timedreceive),
-	SYSCALL_ENTRY(mq_timedsend),
-	SYSCALL_ENTRY(mq_unlink),
-	SYSCALL_ENTRY(mremap),
-	SYSCALL_ENTRY(msgctl),
-	SYSCALL_ENTRY(msgget),
-	SYSCALL_ENTRY(msgrcv),
-	SYSCALL_ENTRY(msgsnd),
-	SYSCALL_ENTRY(msync),
-	SYSCALL_ENTRY(munlock),
-	SYSCALL_ENTRY(munlockall),
-	SYSCALL_ENTRY(munmap),
-	SYSCALL_ENTRY(name_to_handle_at),
-	SYSCALL_ENTRY(nanosleep),
-	SYSCALL_ENTRY(openat),
-	SYSCALL_ENTRY(open_by_handle_at),
-	SYSCALL_ENTRY(perf_event_open),
-	SYSCALL_ENTRY(personality),
-	SYSCALL_ENTRY(pipe2),
-	SYSCALL_ENTRY(pivot_root),
-	SYSCALL_ENTRY(pkey_alloc),
-	SYSCALL_ENTRY(pkey_free),
-	SYSCALL_ENTRY(pkey_mprotect),
-	SYSCALL_ENTRY(ppoll),
-	SYSCALL_ENTRY_ALT(prctl, alt_sys_prctl),
-	SYSCALL_ENTRY(pread64),
-	SYSCALL_ENTRY(preadv),
-	SYSCALL_ENTRY(preadv2),
-	SYSCALL_ENTRY(pwritev2),
-	SYSCALL_ENTRY(prlimit64),
-	SYSCALL_ENTRY(process_vm_readv),
-	SYSCALL_ENTRY(process_vm_writev),
-	SYSCALL_ENTRY(pselect6),
-	SYSCALL_ENTRY(ptrace),
-	SYSCALL_ENTRY(pwrite64),
-	SYSCALL_ENTRY(pwritev),
-	SYSCALL_ENTRY(quotactl),
-	SYSCALL_ENTRY(read),
-	SYSCALL_ENTRY(readahead),
-	SYSCALL_ENTRY(readlinkat),
-	SYSCALL_ENTRY(readv),
-	SYSCALL_ENTRY(reboot),
-	SYSCALL_ENTRY(recvfrom),
-	SYSCALL_ENTRY(recvmmsg),
-	SYSCALL_ENTRY(recvmsg),
-	SYSCALL_ENTRY(remap_file_pages),
-	SYSCALL_ENTRY(removexattr),
-	SYSCALL_ENTRY(renameat),
-	SYSCALL_ENTRY(request_key),
-	SYSCALL_ENTRY(restart_syscall),
-	SYSCALL_ENTRY(rt_sigaction),
-	SYSCALL_ENTRY(rt_sigpending),
-	SYSCALL_ENTRY(rt_sigprocmask),
-	SYSCALL_ENTRY(rt_sigqueueinfo),
-	SYSCALL_ENTRY(rt_sigsuspend),
-	SYSCALL_ENTRY(rt_sigtimedwait),
-	SYSCALL_ENTRY(rt_tgsigqueueinfo),
-	SYSCALL_ENTRY(sched_getaffinity),
-	SYSCALL_ENTRY(sched_getattr),
-	SYSCALL_ENTRY(sched_getparam),
-	SYSCALL_ENTRY(sched_get_priority_max),
-	SYSCALL_ENTRY(sched_get_priority_min),
-	SYSCALL_ENTRY(sched_getscheduler),
-	SYSCALL_ENTRY(sched_rr_get_interval),
-	SYSCALL_ENTRY(sched_setaffinity),
-	SYSCALL_ENTRY(sched_setattr),
-	SYSCALL_ENTRY(sched_setparam),
-	SYSCALL_ENTRY(sched_setscheduler),
-	SYSCALL_ENTRY(sched_yield),
-	SYSCALL_ENTRY(seccomp),
-	SYSCALL_ENTRY(semctl),
-	SYSCALL_ENTRY(semget),
-	SYSCALL_ENTRY(semop),
-	SYSCALL_ENTRY(semtimedop),
-	SYSCALL_ENTRY(sendfile),
-	SYSCALL_ENTRY(sendmmsg),
-	SYSCALL_ENTRY(sendmsg),
-	SYSCALL_ENTRY(sendto),
-	SYSCALL_ENTRY(setdomainname),
-	SYSCALL_ENTRY(setfsgid),
-	SYSCALL_ENTRY(setfsuid),
-	SYSCALL_ENTRY(setgid),
-	SYSCALL_ENTRY(setgroups),
-	SYSCALL_ENTRY(sethostname),
-	SYSCALL_ENTRY(setitimer),
-	SYSCALL_ENTRY(set_mempolicy),
-	SYSCALL_ENTRY(setns),
-	SYSCALL_ENTRY(setpgid),
-	SYSCALL_ENTRY(setpriority),
-	SYSCALL_ENTRY(setregid),
-	SYSCALL_ENTRY(setresgid),
-	SYSCALL_ENTRY(setresuid),
-	SYSCALL_ENTRY(setreuid),
-	SYSCALL_ENTRY(setrlimit),
-	SYSCALL_ENTRY(set_robust_list),
-	SYSCALL_ENTRY(setsid),
-	SYSCALL_ENTRY(setsockopt),
-	SYSCALL_ENTRY(set_tid_address),
-	SYSCALL_ENTRY(settimeofday),
-	SYSCALL_ENTRY(setuid),
-	SYSCALL_ENTRY(setxattr),
-	SYSCALL_ENTRY(shmat),
-	SYSCALL_ENTRY(shmctl),
-	SYSCALL_ENTRY(shmdt),
-	SYSCALL_ENTRY(shmget),
-	SYSCALL_ENTRY(shutdown),
-	SYSCALL_ENTRY(sigaltstack),
-	SYSCALL_ENTRY(signalfd4),
-	SYSCALL_ENTRY(socket),
-	SYSCALL_ENTRY(socketpair),
-	SYSCALL_ENTRY(splice),
-	SYSCALL_ENTRY(statfs),
-	SYSCALL_ENTRY(statx),
-	SYSCALL_ENTRY(swapoff),
-	SYSCALL_ENTRY(swapon),
-	SYSCALL_ENTRY(symlinkat),
-	SYSCALL_ENTRY(sync),
-	SYSCALL_ENTRY(syncfs),
-	SYSCALL_ENTRY(sysinfo),
-	SYSCALL_ENTRY(syslog),
-	SYSCALL_ENTRY(tee),
-	SYSCALL_ENTRY(tgkill),
-	SYSCALL_ENTRY(timer_create),
-	SYSCALL_ENTRY(timer_delete),
-	SYSCALL_ENTRY(timerfd_create),
-	SYSCALL_ENTRY(timerfd_gettime),
-	SYSCALL_ENTRY(timerfd_settime),
-	SYSCALL_ENTRY(timer_getoverrun),
-	SYSCALL_ENTRY(timer_gettime),
-	SYSCALL_ENTRY(timer_settime),
-	SYSCALL_ENTRY(times),
-	SYSCALL_ENTRY(tkill),
-	SYSCALL_ENTRY(truncate),
-	SYSCALL_ENTRY(umask),
-	SYSCALL_ENTRY(unlinkat),
-	SYSCALL_ENTRY(unshare),
-	SYSCALL_ENTRY(utimensat),
-	SYSCALL_ENTRY(vhangup),
-	SYSCALL_ENTRY(vmsplice),
-	SYSCALL_ENTRY(wait4),
-	SYSCALL_ENTRY(waitid),
-	SYSCALL_ENTRY(write),
-	SYSCALL_ENTRY(writev),
-
-	/* Exist for x86_64 and ARM32 but not ARM64. */
-#ifndef CONFIG_ARM64
-	SYSCALL_ENTRY(access),
-	SYSCALL_ENTRY(alarm),
-	SYSCALL_ENTRY(chmod),
-	SYSCALL_ENTRY(chown),
-	SYSCALL_ENTRY(creat),
-	SYSCALL_ENTRY(dup2),
-	SYSCALL_ENTRY(epoll_create),
-	SYSCALL_ENTRY(epoll_wait),
-	SYSCALL_ENTRY(eventfd),
-	SYSCALL_ENTRY(fork),
-	SYSCALL_ENTRY(futimesat),
-	SYSCALL_ENTRY(getdents),
-	SYSCALL_ENTRY(getpgrp),
-	SYSCALL_ENTRY(inotify_init),
-	SYSCALL_ENTRY(lchown),
-	SYSCALL_ENTRY(link),
-	SYSCALL_ENTRY(mkdir),
-	SYSCALL_ENTRY(mknod),
-	SYSCALL_ENTRY(open),
-	SYSCALL_ENTRY(pause),
-	SYSCALL_ENTRY(pipe),
-	SYSCALL_ENTRY(poll),
-	SYSCALL_ENTRY(readlink),
-	SYSCALL_ENTRY(rename),
-	SYSCALL_ENTRY(rmdir),
-	SYSCALL_ENTRY(select),
-	SYSCALL_ENTRY(signalfd),
-	SYSCALL_ENTRY(symlink),
-	SYSCALL_ENTRY(sysfs),
-	SYSCALL_ENTRY(time),
-	SYSCALL_ENTRY(unlink),
-	SYSCALL_ENTRY(ustat),
-	SYSCALL_ENTRY(utime),
-	SYSCALL_ENTRY(utimes),
-	SYSCALL_ENTRY(vfork),
-#endif
-
-	/* Exist for x86_64 and ARM64 but not ARM32 */
-#if !defined(CONFIG_ARM) && (defined(CONFIG_ARM64) || defined(CONFIG_X86_64))
-	SYSCALL_ENTRY(fadvise64),
-	SYSCALL_ENTRY(fstat),
-	SYSCALL_ENTRY(migrate_pages),
-	SYSCALL_ENTRY(mmap),
-	SYSCALL_ENTRY(rt_sigreturn),
-	SYSCALL_ENTRY(sync_file_range),
-	SYSCALL_ENTRY(umount2),
-	SYSCALL_ENTRY(uname),
-#endif
-
-	/* Unique to ARM32. */
-#if defined(CONFIG_ARM) && !defined(CONFIG_ARM64)
-	SYSCALL_ENTRY(arm_fadvise64_64),
-	SYSCALL_ENTRY(bdflush),
-	SYSCALL_ENTRY(fcntl64),
-	SYSCALL_ENTRY(fstat64),
-	SYSCALL_ENTRY(fstatat64),
-	SYSCALL_ENTRY(ftruncate64),
-	SYSCALL_ENTRY(ipc),
-	SYSCALL_ENTRY(lstat64),
-	SYSCALL_ENTRY(mmap2),
-	SYSCALL_ENTRY(nice),
-	SYSCALL_ENTRY(pciconfig_iobase),
-	SYSCALL_ENTRY(pciconfig_read),
-	SYSCALL_ENTRY(pciconfig_write),
-	SYSCALL_ENTRY(recv),
-	SYSCALL_ENTRY(send),
-	SYSCALL_ENTRY(sendfile64),
-	SYSCALL_ENTRY(sigaction),
-	SYSCALL_ENTRY(sigpending),
-	SYSCALL_ENTRY(sigprocmask),
-	SYSCALL_ENTRY(sigsuspend),
-	SYSCALL_ENTRY(socketcall),
-	SYSCALL_ENTRY(stat64),
-	SYSCALL_ENTRY(stime),
-	SYSCALL_ENTRY(syscall),
-	SYSCALL_ENTRY(truncate64),
-	SYSCALL_ENTRY(umount),
-	SYSCALL_ENTRY(uselib),
-#endif
-
-	/* Unique to x86_64. */
-#ifdef CONFIG_X86_64
-	SYSCALL_ENTRY(arch_prctl),
-	SYSCALL_ENTRY(ioperm),
-	SYSCALL_ENTRY(iopl),
-	SYSCALL_ENTRY(kexec_file_load),
-	SYSCALL_ENTRY(lstat),
-	SYSCALL_ENTRY(modify_ldt),
-	SYSCALL_ENTRY(newfstatat),
-	SYSCALL_ENTRY(stat),
-	SYSCALL_ENTRY(_sysctl),
-#endif
-
-	/* Unique to ARM64. */
-#if defined(CONFIG_ARM64) && !defined(CONFIG_ARM)
-	SYSCALL_ENTRY(nfsservctl),
-	SYSCALL_ENTRY(renameat2),
-#endif
-}; /* end process_tree_whitelist */
-
-#ifdef CONFIG_COMPAT
-/*
- * process_tree syscall table does not need to have 32-bit-compatible whitelist
- * filled out, since it will not be used to run 32 bit android code. Since we
- * are not whitelisting any compat syscalls here, a call into the compat
- * section of the process_tree alt syscall table will be redirected to
- * block_syscall() (unless the permissive mode is used in which case the call
- * will be redirected to warn_compat_syscall()).
- */
-static struct syscall_whitelist_entry process_tree_compat_whitelist[] = {};
-#endif /* CONFIG_COMPAT */
-
-#endif /* PROCESS_TREE_WHITELISTS_H */
diff --git a/security/chromiumos/securityfs.c b/security/chromiumos/securityfs.c
index 4bd566f07344..0dee9990b148 100644
--- a/security/chromiumos/securityfs.c
+++ b/security/chromiumos/securityfs.c
@@ -17,17 +17,21 @@
  */
 
 #include <linux/capability.h>
+#include <linux/cred.h>
 #include <linux/dcache.h>
 #include <linux/fs.h>
 #include <linux/namei.h>
+#include <linux/sched.h>
 #include <linux/security.h>
 #include <linux/string.h>
 #include <linux/uaccess.h>
 
 #include "inode_mark.h"
+#include "process_management.h"
 
 static struct dentry *chromiumos_dir;
 static struct dentry *chromiumos_inode_policy_dir;
+static struct dentry *chromiumos_process_management_policy_dir;
 
 struct chromiumos_inode_policy_file_entry {
 	const char *name;
@@ -38,6 +42,12 @@ struct chromiumos_inode_policy_file_entry {
 	struct dentry *dentry;
 };
 
+struct chromiumos_process_management_file_entry {
+	const char *name;
+	enum chromiumos_process_management_file_write_type type;
+	struct dentry *dentry;
+};
+
 static int chromiumos_inode_policy_file_write(
 	struct chromiumos_inode_policy_file_entry *file_entry,
 	struct dentry *dentry)
@@ -87,6 +97,14 @@ static struct chromiumos_inode_policy_file_entry
 	 .handle_write = &chromiumos_inode_policy_file_flush_write},
 };
 
+static struct chromiumos_process_management_file_entry
+		chromiumos_process_management_files[] = {
+	{.name = "add_whitelist_policy",
+	 .type = CHROMIUMOS_PROCESS_MANAGEMENT_ADD},
+	{.name = "flush_whitelist_policies",
+	 .type = CHROMIUMOS_PROCESS_MANAGEMENT_FLUSH},
+};
+
 static int chromiumos_resolve_path(const char __user *buf, size_t len,
 				   struct path *path)
 {
@@ -176,10 +194,118 @@ static ssize_t chromiumos_inode_file_write(
 	return ret < 0 ? ret : len;
 }
 
+/*
+ * In the case the input buffer contains one or more invalid UIDS, the kuid_t
+ * variables pointed to by 'parent' and 'child' will get updated but this
+ * function will return an error.
+ */
+static int chromiumos_parse_process_management_policy(const char __user *buf,
+						      size_t len,
+						      kuid_t *parent,
+						      kuid_t *child)
+{
+	char *kern_buf;
+	char *parent_buf;
+	char *child_buf;
+	const char separator[] = ":";
+	int ret;
+	size_t first_substring_length;
+	long parsed_parent;
+	long parsed_child;
+
+	/* Duplicate string from user memory and NULL-terminate */
+	kern_buf = memdup_user_nul(buf, len);
+	if (IS_ERR(kern_buf))
+		return PTR_ERR(kern_buf);
+
+	/*
+	 * Format of |buf| string should be <UID>:<UID>.
+	 * Find location of ":" in kern_buf (copied from |buf|).
+	 */
+	first_substring_length = strcspn(kern_buf, separator);
+	if (first_substring_length == 0 || first_substring_length == len) {
+		ret = -EINVAL;
+		goto free_kern;
+	}
+
+	parent_buf = kmemdup_nul(kern_buf, first_substring_length, GFP_KERNEL);
+	if (!parent_buf) {
+		ret = -ENOMEM;
+		goto free_kern;
+	}
+
+	ret = kstrtol(parent_buf, 0, &parsed_parent);
+	if (ret)
+		goto free_both;
+
+	child_buf = kern_buf + first_substring_length + 1;
+	ret = kstrtol(child_buf, 0, &parsed_child);
+	if (ret)
+		goto free_both;
+
+	*parent = make_kuid(current_user_ns(), parsed_parent);
+	if (!uid_valid(*parent)) {
+		ret = -EINVAL;
+		goto free_both;
+	}
+
+	*child = make_kuid(current_user_ns(), parsed_child);
+	if (!uid_valid(*child)) {
+		ret = -EINVAL;
+		goto free_both;
+	}
+
+free_both:
+	kfree(parent_buf);
+free_kern:
+	kfree(kern_buf);
+	return ret;
+}
+
+static ssize_t chromiumos_process_management_file_write(struct file *file,
+							const char __user *buf,
+							size_t len,
+							loff_t *ppos)
+{
+	struct chromiumos_process_management_file_entry *file_entry =
+		file->f_inode->i_private;
+	kuid_t parent;
+	kuid_t child;
+	int ret;
+
+	if (!ns_capable(current_user_ns(), CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (*ppos != 0)
+		return -EINVAL;
+
+	if (file_entry->type == CHROMIUMOS_PROCESS_MANAGEMENT_FLUSH) {
+		chromiumos_flush_process_management_entries();
+		return len;
+	}
+
+	/* file_entry->type must equal CHROMIUMOS_PROCESS_MANAGEMENT_ADD */
+	ret = chromiumos_parse_process_management_policy(buf, len, &parent,
+							 &child);
+	if (ret)
+		return ret;
+
+	ret = chromiumos_add_process_management_entry(parent, child);
+	if (ret)
+		return ret;
+
+	/* Return len on success so caller won't keep trying to write */
+	return len;
+}
+
 static const struct file_operations chromiumos_inode_policy_file_fops = {
 	.write = chromiumos_inode_file_write,
 };
 
+static const struct file_operations chromiumos_process_management_file_fops = {
+	.write = chromiumos_process_management_file_write,
+};
+
 static void chromiumos_shutdown_securityfs(void)
 {
 	int i;
@@ -191,9 +317,19 @@ static void chromiumos_shutdown_securityfs(void)
 		entry->dentry = NULL;
 	}
 
+	for (i = 0; i < ARRAY_SIZE(chromiumos_process_management_files); ++i) {
+		struct chromiumos_process_management_file_entry *entry =
+			&chromiumos_process_management_files[i];
+		securityfs_remove(entry->dentry);
+		entry->dentry = NULL;
+	}
+
 	securityfs_remove(chromiumos_inode_policy_dir);
 	chromiumos_inode_policy_dir = NULL;
 
+	securityfs_remove(chromiumos_process_management_policy_dir);
+	chromiumos_process_management_policy_dir = NULL;
+
 	securityfs_remove(chromiumos_dir);
 	chromiumos_dir = NULL;
 }
@@ -230,6 +366,29 @@ static int chromiumos_init_securityfs(void)
 		}
 	}
 
+	chromiumos_process_management_policy_dir =
+		securityfs_create_dir(
+			"process_management_policies",
+			chromiumos_dir);
+	if (!chromiumos_process_management_policy_dir) {
+		ret = PTR_ERR(chromiumos_process_management_policy_dir);
+		goto error;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(chromiumos_process_management_files); ++i) {
+		struct chromiumos_process_management_file_entry *entry =
+			&chromiumos_process_management_files[i];
+		entry->dentry = securityfs_create_file(
+			entry->name,
+			0200,
+			chromiumos_process_management_policy_dir,
+			entry, &chromiumos_process_management_file_fops);
+		if (IS_ERR(entry->dentry)) {
+			ret = PTR_ERR(entry->dentry);
+			goto error;
+		}
+	}
+
 	return 0;
 
 error:
-- 
2.22.0.770.g0f2c4a37fd-goog


From 31e48ca2503ce8a195ea04acbd6260c65f25a5d9 Mon Sep 17 00:00:00 2001
From: Gwendal Grignou <gwendal@chromium.org>
Date: Mon, 8 Jan 2018 11:49:02 -0800
Subject: [PATCH] CHROMIUM: cros-ec: Update cros_ec_commands header to latest
 version

BUG=b:67743747
TEST=`emerge-cyan chromeos-kernel-4_14`

Change-Id: Icb007e0a591021d4ada3b7db73e7743c6cfde525
Signed-off-by: Gwendal Grignou <gwendal@chromium.org>

Conflicts:
	include/linux/mfd/cros_ec_commands.h

[rebase419(groeck): Context conflicts; improved alignment with chromeos-4.14]
Signed-off-by: Guenter Roeck <groeck@chromium.org>
---
 include/linux/mfd/cros_ec_commands.h | 806 ++++++++++++++++++++++++---
 1 file changed, 723 insertions(+), 83 deletions(-)

diff --git a/include/linux/mfd/cros_ec_commands.h b/include/linux/mfd/cros_ec_commands.h
index c63234a7bf3d..07fe4ea0361d 100644
--- a/include/linux/mfd/cros_ec_commands.h
+++ b/include/linux/mfd/cros_ec_commands.h
@@ -85,8 +85,7 @@
 /* Unused 0x28 - 0x2f */
 #define EC_MEMMAP_SWITCHES         0x30	/* 8 bits */
 /* Unused 0x31 - 0x33 */
-#define EC_MEMMAP_HOST_EVENTS      0x34 /* 32 bits */
-/* Reserve 0x38 - 0x3f for additional host event-related stuff */
+#define EC_MEMMAP_HOST_EVENTS      0x34 /* 64 bits */
 /* Battery values are all 32 bits */
 #define EC_MEMMAP_BATT_VOLT        0x40 /* Battery Present Voltage */
 #define EC_MEMMAP_BATT_RATE        0x44 /* Battery Present Rate */
@@ -327,6 +326,27 @@
 #define EC_ACPI_MEM_DEVICE_ORIENTATION 0x09
 #define EC_ACPI_MEM_DEVICE_TABLET_MODE 0x01
 
+/*
+ * Report device features. Uses the same format as the host command, except:
+ *
+ * bit 0 (EC_FEATURE_LIMITED) changes meaning from "EC code has a limited set
+ * of features", which is of limited interest when the system is already
+ * interpreting ACPI bytecode, to "EC_FEATURES[0-7] is not supported". Since
+ * these are supported, it defaults to 0.
+ * This allows detecting the presence of this field since older versions of
+ * the EC codebase would simply return 0xff to that unknown address. Check
+ * FEATURES0 != 0xff (or FEATURES0[0] == 0) to make sure that the other bits
+ * are valid.
+ */
+#define EC_ACPI_MEM_DEVICE_FEATURES0 0x0a
+#define EC_ACPI_MEM_DEVICE_FEATURES1 0x0b
+#define EC_ACPI_MEM_DEVICE_FEATURES2 0x0c
+#define EC_ACPI_MEM_DEVICE_FEATURES3 0x0d
+#define EC_ACPI_MEM_DEVICE_FEATURES4 0x0e
+#define EC_ACPI_MEM_DEVICE_FEATURES5 0x0f
+#define EC_ACPI_MEM_DEVICE_FEATURES6 0x10
+#define EC_ACPI_MEM_DEVICE_FEATURES7 0x11
+
 /*
  * ACPI addresses 0x20 - 0xff map to EC_MEMMAP offset 0x00 - 0xdf.  This data
  * is read-only from the AP.  Added in EC_ACPI_MEM_VERSION 2.
@@ -464,7 +484,9 @@
 #define EC_LPC_STATUS_BUSY_MASK \
 	(EC_LPC_STATUS_FROM_HOST | EC_LPC_STATUS_PROCESSING)
 
-/* Host command response codes */
+/* Host command response codes (16-bit).  Note that response codes should be
+ * stored in a uint16_t rather than directly in a value of this type.
+ */
 enum ec_status {
 	EC_RES_SUCCESS = 0,
 	EC_RES_INVALID_COMMAND = 1,
@@ -481,8 +503,12 @@ enum ec_status {
 	EC_RES_INVALID_HEADER = 12,     /* Header contains invalid data */
 	EC_RES_REQUEST_TRUNCATED = 13,  /* Didn't get the entire request */
 	EC_RES_RESPONSE_TOO_BIG = 14,   /* Response was too big to handle */
-	EC_RES_BUS_ERROR = 15,          /* Communications bus error */
-	EC_RES_BUSY = 16                /* Up but too busy.  Should retry */
+	EC_RES_BUS_ERROR = 15,		/* Communications bus error */
+	EC_RES_BUSY = 16,		/* Up but too busy.  Should retry */
+	EC_RES_INVALID_HEADER_VERSION = 17,  /* Header version invalid */
+	EC_RES_INVALID_HEADER_CRC = 18,      /* Header CRC invalid */
+	EC_RES_INVALID_DATA_CRC = 19,        /* Data CRC invalid */
+	EC_RES_DUP_UNAVAILABLE = 20,         /* Can't resend response */
 };
 
 /*
@@ -502,7 +528,8 @@ enum host_event_code {
 	EC_HOST_EVENT_BATTERY_CRITICAL = 7,
 	EC_HOST_EVENT_BATTERY = 8,
 	EC_HOST_EVENT_THERMAL_THRESHOLD = 9,
-	EC_HOST_EVENT_THERMAL_OVERLOAD = 10,
+	/* Event generated by a device attached to the EC */
+	EC_HOST_EVENT_DEVICE = 10,
 	EC_HOST_EVENT_THERMAL = 11,
 	EC_HOST_EVENT_USB_CHARGER = 12,
 	EC_HOST_EVENT_KEY_PRESSED = 13,
@@ -557,12 +584,6 @@ enum host_event_code {
 	/* Keyboard recovery combo with hardware reinitialization */
 	EC_HOST_EVENT_KEYBOARD_RECOVERY_HW_REINIT = 30,
 
-	/*
-	 * Reserve this last bit to indicate that at least one bit in a
-	 * secondary host event word is set.  See crbug.com/633646.
-	 */
-	EC_HOST_EVENT_EXTENDED = 31,
-
 	/*
 	 * The high bit of the event mask is not used as a host event code.  If
 	 * it reads back as set, then the entire event mask should be
@@ -573,7 +594,7 @@ enum host_event_code {
 	EC_HOST_EVENT_INVALID = 32
 };
 /* Host event mask */
-#define EC_HOST_EVENT_MASK(event_code) (1UL << ((event_code) - 1))
+#define EC_HOST_EVENT_MASK(event_code) (1ULL << ((event_code) - 1))
 
 /* Arguments at EC_LPC_ADDR_HOST_ARGS */
 struct __ec_align4 ec_lpc_host_args {
@@ -788,6 +809,136 @@ struct __ec_align4 ec_host_response {
 	uint16_t reserved;
 };
 
+/*****************************************************************************/
+
+/*
+ * Host command protocol V4.
+ *
+ * Packets always start with a request or response header.  They are followed
+ * by data_len bytes of data.  If the data_crc_present flag is set, the data
+ * bytes are followed by a CRC-8 of that data, using using x^8 + x^2 + x + 1
+ * polynomial.
+ *
+ * Host algorithm when sending a request q:
+ *
+ * 101) tries_left=(some value, e.g. 3);
+ * 102) q.seq_num++
+ * 103) q.seq_dup=0
+ * 104) Calculate q.header_crc.
+ * 105) Send request q to EC.
+ * 106) Wait for response r.  Go to 201 if received or 301 if timeout.
+ *
+ * 201) If r.struct_version != 4, go to 301.
+ * 202) If r.header_crc mismatches calculated CRC for r header, go to 301.
+ * 203) If r.data_crc_present and r.data_crc mismatches, go to 301.
+ * 204) If r.seq_num != q.seq_num, go to 301.
+ * 205) If r.seq_dup == q.seq_dup, return success.
+ * 207) If r.seq_dup == 1, go to 301.
+ * 208) Return error.
+ *
+ * 301) If --tries_left <= 0, return error.
+ * 302) If q.seq_dup == 1, go to 105.
+ * 303) q.seq_dup = 1
+ * 304) Go to 104.
+ *
+ * EC algorithm when receiving a request q.
+ * EC has response buffer r, error buffer e.
+ *
+ * 101) If q.struct_version != 4, set e.result = EC_RES_INVALID_HEADER_VERSION
+ *      and go to 301
+ * 102) If q.header_crc mismatches calculated CRC, set e.result =
+ *      EC_RES_INVALID_HEADER_CRC and go to 301
+ * 103) If q.data_crc_present, calculate data CRC.  If that mismatches the CRC
+ *      byte at the end of the packet, set e.result = EC_RES_INVALID_DATA_CRC
+ *      and go to 301.
+ * 104) If q.seq_dup == 0, go to 201.
+ * 105) If q.seq_num != r.seq_num, go to 201.
+ * 106) If q.seq_dup == r.seq_dup, go to 205, else go to 203.
+ *
+ * 201) Process request q into response r.
+ * 202) r.seq_num = q.seq_num
+ * 203) r.seq_dup = q.seq_dup
+ * 204) Calculate r.header_crc
+ * 205) If r.data_len > 0 and data is no longer available, set e.result =
+ *      EC_RES_DUP_UNAVAILABLE and go to 301.
+ * 206) Send response r.
+ *
+ * 301) e.seq_num = q.seq_num
+ * 302) e.seq_dup = q.seq_dup
+ * 303) Calculate e.header_crc.
+ * 304) Send error response e.
+ */
+
+/* Version 4 request from host */
+struct __ec_align4 ec_host_request4 {
+	/*
+	 * bits 0-3: struct_version: Structure version (=4)
+	 * bit    4: is_response: Is response (=0)
+	 * bits 5-6: seq_num: Sequence number
+	 * bit    7: seq_dup: Sequence duplicate flag
+	 */
+	uint8_t fields0;
+
+	/*
+	 * bits 0-4: command_version: Command version
+	 * bits 5-6: Reserved (set 0, ignore on read)
+	 * bit    7: data_crc_present: Is data CRC present after data
+	 */
+	uint8_t fields1;
+
+	/* Command code (EC_CMD_*) */
+	uint16_t command;
+
+	/* Length of data which follows this header (not including data CRC) */
+	uint16_t data_len;
+
+	/* Reserved (set 0, ignore on read) */
+	uint8_t reserved;
+
+	/* CRC-8 of above fields, using x^8 + x^2 + x + 1 polynomial */
+	uint8_t header_crc;
+};
+
+/* Version 4 response from EC */
+struct __ec_align4 ec_host_response4 {
+	/*
+	 * bits 0-3: struct_version: Structure version (=4)
+	 * bit    4: is_response: Is response (=1)
+	 * bits 5-6: seq_num: Sequence number
+	 * bit    7: seq_dup: Sequence duplicate flag
+	 */
+	uint8_t fields0;
+
+	/*
+	 * bits 0-6: Reserved (set 0, ignore on read)
+	 * bit    7: data_crc_present: Is data CRC present after data
+	 */
+	uint8_t fields1;
+
+	/* Result code (EC_RES_*) */
+	uint16_t result;
+
+	/* Length of data which follows this header (not including data CRC) */
+	uint16_t data_len;
+
+	/* Reserved (set 0, ignore on read) */
+	uint8_t reserved;
+
+	/* CRC-8 of above fields, using x^8 + x^2 + x + 1 polynomial */
+	uint8_t header_crc;
+};
+
+/* Fields in fields0 byte */
+#define EC_PACKET4_0_STRUCT_VERSION_MASK	0x0f
+#define EC_PACKET4_0_IS_RESPONSE_MASK		0x10
+#define EC_PACKET4_0_SEQ_NUM_SHIFT		5
+#define EC_PACKET4_0_SEQ_NUM_MASK		0x60
+#define EC_PACKET4_0_SEQ_DUP_MASK		0x80
+
+/* Fields in fields1 byte */
+#define EC_PACKET4_1_COMMAND_VERSION_MASK	0x1f  /* (request only) */
+#define EC_PACKET4_1_DATA_CRC_PRESENT_MASK	0x80
+
 /*****************************************************************************/
 /*
  * Notes on commands:
@@ -1084,6 +1235,14 @@ enum ec_feature_code {
 	EC_FEATURE_FINGERPRINT = 28,
 	/* The MCU exposes a Touchpad */
 	EC_FEATURE_TOUCHPAD = 29,
+	/* The MCU has RWSIG task enabled */
+	EC_FEATURE_RWSIG = 30,
+	/* EC has device events support */
+	EC_FEATURE_DEVICE_EVENT = 31,
+	/* EC supports the unified wake masks for LPC/eSPI systems */
+	EC_FEATURE_UNIFIED_WAKE_MASKS = 32,
+	/* EC supports 64-bit host events */
+	EC_FEATURE_HOST_EVENT64 = 33,
 	/* EC supports CEC commands */
 	EC_FEATURE_CEC = 35,
 };
@@ -1094,11 +1253,23 @@ struct __ec_align4 ec_response_get_features {
 	uint32_t flags[2];
 };
 
+/*****************************************************************************/
+/* Get the board's SKU ID from EC */
+#define EC_CMD_GET_SKU_ID 0x000E
+
+/* Set SKU ID from AP */
+#define EC_CMD_SET_SKU_ID 0x000F
+
+struct __ec_align4 ec_sku_id_info {
+	uint32_t sku_id;
+};
+
 /*****************************************************************************/
 /* Flash commands */
 
 /* Get flash info */
 #define EC_CMD_FLASH_INFO 0x0010
+#define EC_VER_FLASH_INFO 2
 
 /* Version 0 returns these fields */
 struct __ec_align4 ec_response_flash_info {
@@ -1125,6 +1296,13 @@ struct __ec_align4 ec_response_flash_info {
 /* EC flash erases bits to 0 instead of 1 */
 #define EC_FLASH_INFO_ERASE_TO_0 (1 << 0)
 
+/* Flash must be selected for read/write/erase operations to succeed.  This may
+ * be necessary on a chip where write/erase can be corrupted by other board
+ * activity, or where the chip needs to enable some sort of programming voltage,
+ * or where the read/write/erase operations require cleanly suspending other
+ * chip functionality. */
+#define EC_FLASH_INFO_SELECT_REQUIRED (1 << 1)
+
 /*
  * Version 1 returns the same initial fields as version 0, with additional
  * fields following.
@@ -1132,6 +1310,12 @@ struct __ec_align4 ec_response_flash_info {
  * gcc anonymous structs don't seem to get along with the __packed directive;
  * if they did we'd define the version 0 structure as a sub-structure of this
  * one.
+ *
+ * Version 2 supports flash banks of different sizes:
+ * The caller specified the number of banks it has preallocated
+ * (num_banks_desc)
+ * The EC returns the number of banks describing the flash memory.
+ * It adds banks descriptions up to num_banks_desc.
  */
 struct __ec_align4 ec_response_flash_info_1 {
 	/* Version 0 fields; see above for description */
@@ -1153,6 +1337,42 @@ struct __ec_align4 ec_response_flash_info_1 {
 	uint32_t flags;
 };
 
+struct __ec_align4 ec_params_flash_info_2 {
+	/* Number of banks to describe */
+	uint16_t num_banks_desc;
+	/* Reserved; set 0; ignore on read */
+	uint8_t reserved[2];
+};
+
+struct ec_flash_bank {
+	/* Number of sector is in this bank. */
+	uint16_t count;
+	/* Size in power of 2 of each sector (8 --> 256 bytes) */
+	uint8_t size_exp;
+	/* Minimal write size for the sectors in this bank */
+	uint8_t write_size_exp;
+	/* Erase size for the sectors in this bank */
+	uint8_t erase_size_exp;
+	/* Size for write protection, usually identical to erase size. */
+	uint8_t protect_size_exp;
+	/* Reserved; set 0; ignore on read */
+	uint8_t reserved[2];
+};
+
+struct __ec_align4 ec_response_flash_info_2 {
+	/* Total flash in the EC. */
+	uint32_t flash_size;
+	/* Flags; see EC_FLASH_INFO_* */
+	uint32_t flags;
+	/* Maximum size to use to send data to write to the EC. */
+	uint32_t write_ideal_size;
+	/* Number of banks present in the EC. */
+	uint16_t num_banks_total;
+	/* Number of banks described in banks array. */
+	uint16_t num_banks_desc;
+	struct ec_flash_bank banks[0];
+};
+
 /*
  * Read flash
  *
@@ -1181,11 +1401,47 @@ struct __ec_align4 ec_params_flash_write {
 /* Erase flash */
 #define EC_CMD_FLASH_ERASE 0x0013
 
+/* v0 */
 struct __ec_align4 ec_params_flash_erase {
 	uint32_t offset;   /* Byte offset to erase */
 	uint32_t size;     /* Size to erase in bytes */
 };
 
+
+#define EC_VER_FLASH_WRITE 1
+/* v1 add async erase:
+ * subcommands can returns:
+ * EC_RES_SUCCESS : erased (see ERASE_SECTOR_ASYNC case below).
+ * EC_RES_INVALID_PARAM : offset/size are not aligned on a erase boundary.
+ * EC_RES_ERROR : other errors.
+ * EC_RES_BUSY : an existing erase operation is in progress.
+ * EC_RES_ACCESS_DENIED: Trying to erase running image.
+ *
+ * When ERASE_SECTOR_ASYNC returns EC_RES_SUCCESS, the operation is just
+ * properly queued. The user must call ERASE_GET_RESULT subcommand to get
+ * the proper result.
+ * When ERASE_GET_RESULT returns EC_RES_BUSY, the caller must wait and send
+ * ERASE_GET_RESULT again to get the result of ERASE_SECTOR_ASYNC.
+ * ERASE_GET_RESULT command may timeout on EC where flash access is not
+ * permitted while erasing. (For instance, STM32F4).
+ */
+enum ec_flash_erase_cmd {
+	FLASH_ERASE_SECTOR,     /* Erase and wait for result */
+	FLASH_ERASE_SECTOR_ASYNC,  /* Erase and return immediately. */
+	FLASH_ERASE_GET_RESULT,  /* Ask for last erase result */
+};
+
+struct __ec_align4 ec_params_flash_erase_v1 {
+	/* One of ec_flash_erase_cmd. */
+	uint8_t  cmd;
+	/* Pad byte; currently always contains 0 */
+	uint8_t  reserved;
+	/* No flags defined yet; set to 0 */
+	uint16_t flag;
+	/* Same as v0 parameters. */
+	struct ec_params_flash_erase params;
+};
+
 /*
  * Get/set flash protection.
  *
@@ -1260,16 +1516,29 @@ struct __ec_align4 ec_response_flash_protect {
 enum ec_flash_region {
 	/* Region which holds read-only EC image */
 	EC_FLASH_REGION_RO = 0,
-	/* Region which holds rewritable EC image */
-	EC_FLASH_REGION_RW,
+	/*
+	 * Region which holds active RW image. 'Active' is different from
+	 * 'running'. Active means 'scheduled-to-run'. Since RO image always
+	 * scheduled to run, active/non-active applies only to RW images (for
+	 * the same reason 'update' applies only to RW images. It's a state of
+	 * an image on a flash. Running image can be RO, RW_A, RW_B but active
+	 * image can only be RW_A or RW_B. In recovery mode, an active RW image
+	 * doesn't enter 'running' state but it's still active on a flash.
+	 */
+	EC_FLASH_REGION_ACTIVE,
 	/*
 	 * Region which should be write-protected in the factory (a superset of
 	 * EC_FLASH_REGION_RO)
 	 */
 	EC_FLASH_REGION_WP_RO,
+	/* Region which holds updatable (non-active) RW image */
+	EC_FLASH_REGION_UPDATE,
 	/* Number of regions */
 	EC_FLASH_REGION_COUNT,
 };
+/* 'RW' is vague if there are multiple RW images; we mean the active one,
+ * so the old constant is deprecated */
+#define EC_FLASH_REGION_RW EC_FLASH_REGION_ACTIVE
 
 struct __ec_align4 ec_params_flash_region_info {
 	uint32_t region;  /* enum ec_flash_region */
@@ -1317,6 +1586,16 @@ struct __ec_align1 ec_response_flash_spi_info {
 	uint8_t sr1, sr2;
 };
 
+
+/* Select flash during flash operations */
+#define EC_CMD_FLASH_SELECT 0x0019
+
+struct __ec_align4 ec_params_flash_select {
+	/* 1 to select flash, 0 to deselect flash */
+	uint8_t select;
+};
+
+
 /*****************************************************************************/
 /* PWM commands */
 
@@ -1581,13 +1860,17 @@ struct __ec_todo_unpacked lightbar_program {
 struct __ec_todo_packed ec_params_lightbar {
 	uint8_t cmd;		      /* Command (see enum lightbar_command) */
 	union {
-		struct __ec_todo_unpacked {
-			/* no args */
-		} dump, off, on, init, get_seq, get_params_v0, get_params_v1,
-			version, get_brightness, get_demo, suspend, resume,
-			get_params_v2_timing, get_params_v2_tap,
-			get_params_v2_osc, get_params_v2_bright,
-			get_params_v2_thlds, get_params_v2_colors;
+		/*
+		 * The following commands have no args:
+		 *
+		 * dump, off, on, init, get_seq, get_params_v0, get_params_v1,
+		 * version, get_brightness, get_demo, suspend, resume,
+		 * get_params_v2_timing, get_params_v2_tap, get_params_v2_osc,
+		 * get_params_v2_bright, get_params_v2_thlds,
+		 * get_params_v2_colors
+		 *
+		 * Don't use an empty struct, because C++ hates that.
+		 */
 
 		struct __ec_todo_unpacked {
 			uint8_t num;
@@ -1657,14 +1940,15 @@ struct __ec_todo_packed ec_response_lightbar {
 			uint8_t red, green, blue;
 		} get_rgb;
 
-		struct __ec_todo_unpacked {
-			/* no return params */
-		} off, on, init, set_brightness, seq, reg, set_rgb,
-			demo, set_params_v0, set_params_v1,
-			set_program, manual_suspend_ctrl, suspend, resume,
-			set_v2par_timing, set_v2par_tap,
-			set_v2par_osc, set_v2par_bright, set_v2par_thlds,
-			set_v2par_colors;
+		/*
+		 * The following commands have no response:
+		 *
+		 * off, on, init, set_brightness, seq, reg, set_rgb, demo,
+		 * set_params_v0, set_params_v1, set_program,
+		 * manual_suspend_ctrl, suspend, resume, set_v2par_timing,
+		 * set_v2par_tap, set_v2par_osc, set_v2par_bright,
+		 * set_v2par_thlds, set_v2par_colors
+		 */
 	};
 };
 
@@ -1726,6 +2010,10 @@ enum ec_led_id {
 	EC_LED_ID_LEFT_LED,
 	/* LED to indicate right side */
 	EC_LED_ID_RIGHT_LED,
+	/* LED to indicate recovery mode with HW_REINIT */
+	EC_LED_ID_RECOVERY_HW_REINIT_LED,
+	/* LED to indicate sysrq debug mode. */
+	EC_LED_ID_SYSRQ_DEBUG_LED,
 
 	EC_LED_ID_COUNT
 };
@@ -1816,8 +2104,13 @@ enum ec_vboot_hash_status {
  * If one of these is specified, the EC will automatically update offset and
  * size to the correct values for the specified image (RO or RW).
  */
-#define EC_VBOOT_HASH_OFFSET_RO 0xfffffffe
-#define EC_VBOOT_HASH_OFFSET_RW 0xfffffffd
+#define EC_VBOOT_HASH_OFFSET_RO		0xfffffffe
+#define EC_VBOOT_HASH_OFFSET_ACTIVE	0xfffffffd
+#define EC_VBOOT_HASH_OFFSET_UPDATE	0xfffffffc
+
+/* 'RW' is vague if there are multiple RW images; we mean the active one,
+ * so the old constant is deprecated */
+#define EC_VBOOT_HASH_OFFSET_RW EC_VBOOT_HASH_OFFSET_ACTIVE
 
 /*****************************************************************************/
 /*
@@ -1952,6 +2245,7 @@ enum motionsensor_type {
 	MOTIONSENSE_TYPE_LIGHT = 4,
 	MOTIONSENSE_TYPE_ACTIVITY = 5,
 	MOTIONSENSE_TYPE_BARO = 6,
+	MOTIONSENSE_TYPE_SYNC = 7,
 	MOTIONSENSE_TYPE_MAX,
 };
 
@@ -1959,6 +2253,7 @@ enum motionsensor_type {
 enum motionsensor_location {
 	MOTIONSENSE_LOC_BASE = 0,
 	MOTIONSENSE_LOC_LID = 1,
+	MOTIONSENSE_LOC_CAMERA = 2,
 	MOTIONSENSE_LOC_MAX,
 };
 
@@ -1975,6 +2270,17 @@ enum motionsensor_chip {
 	MOTIONSENSE_CHIP_BMA255 = 8,
 	MOTIONSENSE_CHIP_BMP280 = 9,
 	MOTIONSENSE_CHIP_OPT3001 = 10,
+	MOTIONSENSE_CHIP_BH1730 = 11,
+	MOTIONSENSE_CHIP_GPIO = 12,
+};
+
+/* List of orientation positions */
+enum motionsensor_orientation {
+	MOTIONSENSE_ORIENTATION_LANDSCAPE = 0,
+	MOTIONSENSE_ORIENTATION_PORTRAIT = 1,
+	MOTIONSENSE_ORIENTATION_UPSIDE_DOWN_PORTRAIT = 2,
+	MOTIONSENSE_ORIENTATION_UPSIDE_DOWN_LANDSCAPE = 3,
+	MOTIONSENSE_ORIENTATION_UNKNOWN = 4,
 };
 
 struct __ec_todo_packed ec_response_motion_sensor_data {
@@ -1986,7 +2292,7 @@ struct __ec_todo_packed ec_response_motion_sensor_data {
 	union {
 		int16_t             data[3];
 		struct __ec_todo_packed {
-			uint16_t    rsvd;
+			uint16_t    reserved;
 			uint32_t    timestamp;
 		};
 		struct __ec_todo_unpacked {
@@ -2021,6 +2327,7 @@ enum motionsensor_activity {
 	MOTIONSENSE_ACTIVITY_RESERVED = 0,
 	MOTIONSENSE_ACTIVITY_SIG_MOTION = 1,
 	MOTIONSENSE_ACTIVITY_DOUBLE_TAP = 2,
+	MOTIONSENSE_ACTIVITY_ORIENTATION = 3,
 };
 
 struct __ec_todo_unpacked ec_motion_sense_activity {
@@ -2103,7 +2410,7 @@ struct __ec_todo_packed ec_params_motion_sense {
 		struct __ec_todo_unpacked {
 			uint8_t sensor_num;
 		} info, info_3, data, fifo_flush, perform_calib,
-			list_activities;
+				list_activities;
 
 		/*
 		 * Used for MOTIONSENSE_CMD_EC_RATE, MOTIONSENSE_CMD_SENSOR_ODR
@@ -2151,8 +2458,7 @@ struct __ec_todo_packed ec_params_motion_sense {
 		} sensor_offset;
 
 		/* Used for MOTIONSENSE_CMD_FIFO_INFO */
-		struct __ec_todo_unpacked {
-		} fifo_info;
+		/* (no params) */
 
 		/* Used for MOTIONSENSE_CMD_FIFO_READ */
 		struct __ec_todo_unpacked {
@@ -2166,8 +2472,7 @@ struct __ec_todo_packed ec_params_motion_sense {
 		struct ec_motion_sense_activity set_activity;
 
 		/* Used for MOTIONSENSE_CMD_LID_ANGLE */
-		struct __ec_todo_unpacked {
-		} lid_angle;
+		/* (no params) */
 
 		/* Used for MOTIONSENSE_CMD_FIFO_INT_ENABLE */
 		struct __ec_todo_unpacked {
@@ -2186,7 +2491,7 @@ struct __ec_todo_packed ec_params_motion_sense {
 			uint8_t spoof_enable;
 
 			/* Ignored, used for alignment. */
-			uint8_t rsvd;
+			uint8_t reserved;
 
 			/* Individual component values to spoof. */
 			int16_t components[3];
@@ -2223,7 +2528,7 @@ struct __ec_todo_packed ec_response_motion_sense {
 			uint8_t chip;
 		} info;
 
-		/* Used for MOTIONSENSE_CMD_INFO v3 */
+		/* Used for MOTIONSENSE_CMD_INFO version 3 */
 		struct __ec_todo_unpacked {
 			/* Should be element of enum motionsensor_type. */
 			uint8_t type;
@@ -2276,8 +2581,7 @@ struct __ec_todo_packed ec_response_motion_sense {
 			uint32_t disabled;
 		} list_activities;
 
-		struct __ec_todo_unpacked {
-		} set_activity;
+		/* No params for set activity */
 
 		/* Used for MOTIONSENSE_CMD_LID_ANGLE */
 		struct __ec_todo_unpacked {
@@ -2515,11 +2819,27 @@ enum ec_temp_thresholds {
  * Thermal configuration for one temperature sensor. Temps are in degrees K.
  * Zero values will be silently ignored by the thermal task.
  *
+ * Set 'temp_host' value allows thermal task to trigger some event with 1 degree
+ * hysteresis.
+ * For example,
+ *	temp_host[EC_TEMP_THRESH_HIGH] = 300 K
+ *	temp_host_release[EC_TEMP_THRESH_HIGH] = 0 K
+ * EC will throttle ap when temperature >= 301 K, and release throttling when
+ * temperature <= 299 K.
+ *
+ * Set 'temp_host_release' value allows thermal task has a custom hysteresis.
+ * For example,
+ *	temp_host[EC_TEMP_THRESH_HIGH] = 300 K
+ *	temp_host_release[EC_TEMP_THRESH_HIGH] = 295 K
+ * EC will throttle ap when temperature >= 301 K, and release throttling when
+ * temperature <= 294 K.
+ *
  * Note that this structure is a sub-structure of
  * ec_params_thermal_set_threshold_v1, but maintains its alignment there.
  */
 struct __ec_align4 ec_thermal_config {
 	uint32_t temp_host[EC_TEMP_THRESH_COUNT]; /* levels of hotness */
+	uint32_t temp_host_release[EC_TEMP_THRESH_COUNT]; /* release levels */
 	uint32_t temp_fan_off;		/* no active cooling needed */
 	uint32_t temp_fan_max;		/* max active cooling needed */
 };
@@ -2835,6 +3155,12 @@ enum ec_mkbp_event {
 	 */
 	EC_MKBP_EVENT_SYSRQ = 6,
 
+	/*
+	 * New 64-bit host event.
+	 * The event data is 8 bytes of host event flags.
+	 */
+	EC_MKBP_EVENT_HOST_EVENT64 = 7,
+
 	/* Notify the AP that something happened on CEC */
 	EC_MKBP_EVENT_CEC_EVENT = 8,
 
@@ -2850,6 +3176,7 @@ union __ec_align_offset1 ec_response_get_next_data {
 
 	/* Unaligned */
 	uint32_t host_event;
+	uint64_t host_event64;
 
 	uint32_t   buttons;
 	uint32_t   switches;
@@ -2862,7 +3189,7 @@ union __ec_align_offset1 ec_response_get_next_data_v1 {
 
 	struct __ec_todo_unpacked {
 		/* For aligning the fifo_info */
-		uint8_t rsvd[3];
+		uint8_t reserved[3];
 		struct ec_response_motion_sense_fifo_info info;
 	} sensor_fifo;
 
@@ -2883,17 +3210,18 @@ struct __ec_align1 ec_response_get_next_event {
 	union ec_response_get_next_data data;
 };
 
-struct ec_response_get_next_event_v1 {
+struct __ec_align1 ec_response_get_next_event_v1 {
 	uint8_t event_type;
 	/* Followed by event data if any */
 	union ec_response_get_next_data_v1 data;
-} __packed;
+};
 
 /* Bit indices for buttons and switches.*/
 /* Buttons */
 #define EC_MKBP_POWER_BUTTON	0
 #define EC_MKBP_VOL_UP		1
 #define EC_MKBP_VOL_DOWN	2
+#define EC_MKBP_RECOVERY	3
 
 /* Switches */
 #define EC_MKBP_LID_OPEN	0
@@ -2906,6 +3234,12 @@ struct __ec_align2 ec_response_keyboard_factory_test {
 	uint16_t shorted;	/* Keyboard pins are shorted */
 };
 
+/* Fingerprint events in 'fp_events' for EC_MKBP_EVENT_FINGERPRINT */
+#define EC_MKBP_FP_RAW_EVENT(fp_events) ((fp_events) & 0x00FFFFFF)
+#define EC_MKBP_FP_FINGER_DOWN          (1 << 29)
+#define EC_MKBP_FP_FINGER_UP            (1 << 30)
+#define EC_MKBP_FP_IMAGE_READY          (1 << 31)
+
 /*****************************************************************************/
 /* Temperature sensor commands */
 
@@ -2932,6 +3266,8 @@ struct __ec_align1 ec_response_temp_sensor_get_info {
 /*****************************************************************************/
 /* Host event commands */
 
+
+/* Obsolete. New implementation should use EC_CMD_HOST_EVENT instead */
 /*
  * Host event mask params and response structures, shared by all of the host
  * event commands below.
@@ -2957,6 +3293,86 @@ struct __ec_align4 ec_response_host_event_mask {
 #define EC_CMD_HOST_EVENT_SET_WAKE_MASK 0x008E
 #define EC_CMD_HOST_EVENT_CLEAR_B       0x008F
 
+/*
+ * Unified host event programming interface - Should be used by newer versions
+ * of BIOS/OS to program host events and masks
+ */
+
+struct __ec_align4 ec_params_host_event {
+
+	/* Action requested by host - one of enum ec_host_event_action. */
+	uint8_t action;
+
+	/*
+	 * Mask type that the host requested the action on - one of
+	 * enum ec_host_event_mask_type.
+	 */
+	uint8_t mask_type;
+
+	/* Set to 0, ignore on read */
+	uint16_t reserved;
+
+	/* Value to be used in case of set operations. */
+	uint64_t value;
+};
+
+/*
+ * Response structure returned by EC_CMD_HOST_EVENT.
+ * Update the value on a GET request. Set to 0 on GET/CLEAR
+ */
+
+struct __ec_align4 ec_response_host_event {
+
+	/* Mask value in case of get operation */
+	uint64_t value;
+};
+
+enum ec_host_event_action {
+	/*
+	 * params.value is ignored. Value of mask_type populated
+	 * in response.value
+	 */
+	EC_HOST_EVENT_GET,
+
+	/* Bits in params.value are set */
+	EC_HOST_EVENT_SET,
+
+	/* Bits in params.value are cleared */
+	EC_HOST_EVENT_CLEAR,
+};
+
+enum ec_host_event_mask_type {
+
+	/* Main host event copy */
+	EC_HOST_EVENT_MAIN,
+
+	/* Copy B of host events */
+	EC_HOST_EVENT_B,
+
+	/* SCI Mask */
+	EC_HOST_EVENT_SCI_MASK,
+
+	/* SMI Mask */
+	EC_HOST_EVENT_SMI_MASK,
+
+	/* Mask of events that should be always reported in hostevents */
+	EC_HOST_EVENT_ALWAYS_REPORT_MASK,
+
+	/* Active wake mask */
+	EC_HOST_EVENT_ACTIVE_WAKE_MASK,
+
+	/* Lazy wake mask for S0ix */
+	EC_HOST_EVENT_LAZY_WAKE_MASK_S0IX,
+
+	/* Lazy wake mask for S3 */
+	EC_HOST_EVENT_LAZY_WAKE_MASK_S3,
+
+	/* Lazy wake mask for S5 */
+	EC_HOST_EVENT_LAZY_WAKE_MASK_S5,
+};
+
+#define EC_CMD_HOST_EVENT       0x00A4
+
 /*****************************************************************************/
 /* Switch commands */
 
@@ -3347,15 +3763,22 @@ enum charge_state_params {
 	CS_PARAM_CUSTOM_PROFILE_MIN = 0x10000,
 	CS_PARAM_CUSTOM_PROFILE_MAX = 0x1ffff,
 
+	/* Range for CONFIG_CHARGE_STATE_DEBUG params */
+	CS_PARAM_DEBUG_MIN = 0x20000,
+	CS_PARAM_DEBUG_CTL_MODE = 0x20000,
+	CS_PARAM_DEBUG_MANUAL_MODE,
+	CS_PARAM_DEBUG_SEEMS_DEAD,
+	CS_PARAM_DEBUG_SEEMS_DISCONNECTED,
+	CS_PARAM_DEBUG_BATT_REMOVED,
+	CS_PARAM_DEBUG_MAX = 0x2ffff,
+
 	/* Other custom param ranges go here... */
 };
 
 struct __ec_todo_packed ec_params_charge_state {
 	uint8_t cmd;				/* enum charge_state_command */
 	union {
-		struct __ec_align1 {
-			/* no args */
-		} get_state;
+		/* get_state has no args */
 
 		struct __ec_todo_unpacked {
 			uint32_t param;		/* enum charge_state_param */
@@ -3381,9 +3804,8 @@ struct __ec_align4 ec_response_charge_state {
 		struct __ec_align4 {
 			uint32_t value;
 		} get_param;
-		struct __ec_align4 {
-			/* no return values */
-		} set_param;
+
+		/* set_param returns no args */
 	};
 };
 
@@ -3391,11 +3813,11 @@ struct __ec_align4 ec_response_charge_state {
 /*
  * Set maximum battery charging current.
  */
-#define EC_CMD_CHARGE_CURRENT_LIMIT 0xa1
+#define EC_CMD_CHARGE_CURRENT_LIMIT 0x00A1
 
-struct ec_params_current_limit {
+struct __ec_align4 ec_params_current_limit {
 	uint32_t limit; /* in mA */
-} __packed;
+};
 
 /*
  * Set maximum external voltage / current.
@@ -3403,13 +3825,23 @@ struct ec_params_current_limit {
 #define EC_CMD_EXTERNAL_POWER_LIMIT 0x00A2
 
 /* Command v0 is used only on Spring and is obsolete + unsupported */
-struct ec_params_external_power_limit_v1 {
+struct __ec_align2 ec_params_external_power_limit_v1 {
 	uint16_t current_lim; /* in mA, or EC_POWER_LIMIT_NONE to clear limit */
 	uint16_t voltage_lim; /* in mV, or EC_POWER_LIMIT_NONE to clear limit */
-} __packed;
+};
 
 #define EC_POWER_LIMIT_NONE 0xffff
 
+/*
+ * Set maximum voltage & current of a dedicated charge port
+ */
+#define EC_CMD_OVERRIDE_DEDICATED_CHARGER_LIMIT 0x00A3
+
+struct __ec_align2 ec_params_dedicated_charger_limit {
+	uint16_t current_lim; /* in mA */
+	uint16_t voltage_lim; /* in mV */
+};
+
 /*****************************************************************************/
 /* Hibernate/Deep Sleep Commands */
 
@@ -3451,13 +3883,45 @@ enum host_sleep_event {
 	HOST_SLEEP_EVENT_S3_SUSPEND   = 1,
 	HOST_SLEEP_EVENT_S3_RESUME    = 2,
 	HOST_SLEEP_EVENT_S0IX_SUSPEND = 3,
-	HOST_SLEEP_EVENT_S0IX_RESUME  = 4
+	HOST_SLEEP_EVENT_S0IX_RESUME  = 4,
+	/* S3 suspend with additional enabled wake sources */
+	HOST_SLEEP_EVENT_S3_WAKEABLE_SUSPEND = 5,
 };
 
 struct __ec_align1 ec_params_host_sleep_event {
 	uint8_t sleep_event;
 };
 
+/*****************************************************************************/
+/* Device events */
+#define EC_CMD_DEVICE_EVENT 0x00AA
+
+enum ec_device_event {
+	EC_DEVICE_EVENT_TRACKPAD,
+	EC_DEVICE_EVENT_DSP,
+	EC_DEVICE_EVENT_WIFI,
+};
+
+enum ec_device_event_param {
+	/* Get and clear pending device events */
+	EC_DEVICE_EVENT_PARAM_GET_CURRENT_EVENTS,
+	/* Get device event mask */
+	EC_DEVICE_EVENT_PARAM_GET_ENABLED_EVENTS,
+	/* Set device event mask */
+	EC_DEVICE_EVENT_PARAM_SET_ENABLED_EVENTS,
+};
+
+#define EC_DEVICE_EVENT_MASK(event_code) (1UL << (event_code % 32))
+
+struct __ec_align_size1 ec_params_device_event {
+	uint32_t event_mask;
+	uint8_t param;
+};
+
+struct __ec_align4 ec_response_device_event {
+	uint32_t event_mask;
+};
+
 /*****************************************************************************/
 /* Smart battery pass-through */
 
@@ -3554,9 +4018,7 @@ struct __ec_align4 ec_params_sb_fw_update {
 		/* EC_SB_FW_UPDATE_END      = 0x4 */
 		/* EC_SB_FW_UPDATE_STATUS   = 0x5 */
 		/* EC_SB_FW_UPDATE_PROTECT  = 0x6 */
-		struct __ec_align4 {
-			/* no args */
-		} dummy;
+		/* Those have no args */
 
 		/* EC_SB_FW_UPDATE_WRITE    = 0x3 */
 		struct __ec_align4 {
@@ -3628,16 +4090,18 @@ struct __ec_align1 ec_response_i2c_passthru_protect {
 enum ec_reboot_cmd {
 	EC_REBOOT_CANCEL = 0,        /* Cancel a pending reboot */
 	EC_REBOOT_JUMP_RO = 1,       /* Jump to RO without rebooting */
-	EC_REBOOT_JUMP_RW = 2,       /* Jump to RW without rebooting */
+	EC_REBOOT_JUMP_RW = 2,       /* Jump to active RW without rebooting */
 	/* (command 3 was jump to RW-B) */
 	EC_REBOOT_COLD = 4,          /* Cold-reboot */
 	EC_REBOOT_DISABLE_JUMP = 5,  /* Disable jump until next reboot */
-	EC_REBOOT_HIBERNATE = 6      /* Hibernate EC */
+	EC_REBOOT_HIBERNATE = 6,     /* Hibernate EC */
+	EC_REBOOT_HIBERNATE_CLEAR_AP_OFF = 7, /* and clears AP_OFF flag */
 };
 
 /* Flags for ec_params_reboot_ec.reboot_flags */
 #define EC_REBOOT_FLAG_RESERVED0      (1 << 0)  /* Was recovery request */
 #define EC_REBOOT_FLAG_ON_AP_SHUTDOWN (1 << 1)  /* Reboot after AP shutdown */
+#define EC_REBOOT_FLAG_SWITCH_RW_SLOT (1 << 2)  /* Switch RW slot */
 
 struct __ec_align1 ec_params_reboot_ec {
 	uint8_t cmd;           /* enum ec_reboot_cmd */
@@ -3818,6 +4282,7 @@ enum usb_pd_control_role {
 	USB_PD_CTRL_ROLE_TOGGLE_OFF = 2,
 	USB_PD_CTRL_ROLE_FORCE_SINK = 3,
 	USB_PD_CTRL_ROLE_FORCE_SOURCE = 4,
+	USB_PD_CTRL_ROLE_FREEZE = 5,
 	USB_PD_CTRL_ROLE_COUNT
 };
 
@@ -3858,28 +4323,28 @@ struct __ec_align1 ec_params_usb_pd_control {
 #define PD_CTRL_RESP_ROLE_USB_COMM      BIT(5) /* Partner USB comm capable */
 #define PD_CTRL_RESP_ROLE_EXT_POWERED   BIT(6) /* Partner externally powerd */
 
-struct ec_response_usb_pd_control_v1 {
+struct __ec_align1 ec_response_usb_pd_control_v1 {
 	uint8_t enabled;
 	uint8_t role;
 	uint8_t polarity;
 	char state[32];
-} __packed;
+};
 
-#define EC_CMD_USB_PD_PORTS 0x102
+#define EC_CMD_USB_PD_PORTS 0x0102
 
 /* Maximum number of PD ports on a device, num_ports will be <= this */
 #define EC_USB_PD_MAX_PORTS 8
 
-struct ec_response_usb_pd_ports {
+struct __ec_align1 ec_response_usb_pd_ports {
 	uint8_t num_ports;
-} __packed;
+};
 
-#define EC_CMD_USB_PD_POWER_INFO 0x103
+#define EC_CMD_USB_PD_POWER_INFO 0x0103
 
 #define PD_POWER_CHARGING_PORT 0xff
-struct ec_params_usb_pd_power_info {
+struct __ec_align1 ec_params_usb_pd_power_info {
 	uint8_t port;
-} __packed;
+};
 
 enum usb_chg_type {
 	USB_CHG_TYPE_NONE,
@@ -3892,6 +4357,7 @@ enum usb_chg_type {
 	USB_CHG_TYPE_OTHER,
 	USB_CHG_TYPE_VBUS,
 	USB_CHG_TYPE_UNKNOWN,
+	USB_CHG_TYPE_DEDICATED,
 };
 enum usb_power_roles {
 	USB_PD_PORT_POWER_DISCONNECTED,
@@ -3900,21 +4366,21 @@ enum usb_power_roles {
 	USB_PD_PORT_POWER_SINK_NOT_CHARGING,
 };
 
-struct usb_chg_measures {
+struct __ec_align2 usb_chg_measures {
 	uint16_t voltage_max;
 	uint16_t voltage_now;
 	uint16_t current_max;
 	uint16_t current_lim;
-} __packed;
+};
 
-struct ec_response_usb_pd_power_info {
+struct __ec_align4 ec_response_usb_pd_power_info {
 	uint8_t role;
 	uint8_t type;
 	uint8_t dualrole;
 	uint8_t reserved1;
 	struct usb_chg_measures meas;
 	uint32_t max_power;
-} __packed;
+};
 
 /* AP to PD MCU host event status command, cleared on read */
 #define EC_CMD_PD_HOST_EVENT_STATUS 0x0104
@@ -3988,7 +4454,11 @@ struct __ec_align2 ec_params_charge_port_override {
 	int16_t override_port; /* Override port# */
 };
 
-/* Read (and delete) one entry of PD event log */
+/*
+ * Read (and delete) one entry of PD event log.
+ * TODO(crbug.com/751742): Make this host command more generic to accommodate
+ * future non-PD logs that use the same internal EC event_log.
+ */
 #define EC_CMD_PD_GET_LOG_ENTRY 0x0115
 
 struct __ec_align4 ec_response_pd_log {
@@ -4121,7 +4591,8 @@ enum ec_pd_control_cmd {
 	PD_SUSPEND = 0,      /* Suspend the PD chip (EC: stop talking to PD) */
 	PD_RESUME,           /* Resume the PD chip (EC: start talking to PD) */
 	PD_RESET,            /* Force reset the PD chip */
-	PD_CONTROL_DISABLE   /* Disable further calls to this command */
+	PD_CONTROL_DISABLE,  /* Disable further calls to this command */
+	PD_CHIP_ON,          /* Power on the PD chip */
 };
 
 struct __ec_align1 ec_params_pd_control {
@@ -4130,11 +4601,11 @@ struct __ec_align1 ec_params_pd_control {
 };
 
 /* Get info about USB-C SS muxes */
-#define EC_CMD_USB_PD_MUX_INFO 0x11a
+#define EC_CMD_USB_PD_MUX_INFO 0x011A
 
-struct ec_params_usb_pd_mux_info {
+struct __ec_align1 ec_params_usb_pd_mux_info {
 	uint8_t port; /* USB-C port number */
-} __packed;
+};
 
 /* Flags representing mux state */
 #define USB_PD_MUX_USB_ENABLED       (1 << 0)
@@ -4142,9 +4613,9 @@ struct ec_params_usb_pd_mux_info {
 #define USB_PD_MUX_POLARITY_INVERTED (1 << 2)
 #define USB_PD_MUX_HPD_IRQ           (1 << 3)
 
-struct ec_response_usb_pd_mux_info {
+struct __ec_align1 ec_response_usb_pd_mux_info {
 	uint8_t flags; /* USB_PD_MUX_*-encoded USB mux state */
-} __packed;
+};
 
 #define EC_CMD_PD_CHIP_INFO		0x011B
 
@@ -4170,7 +4641,17 @@ struct __ec_align4 ec_response_rwsig_check_status {
 	uint32_t status;
 };
 
-#endif  /* !__ACPI__ */
+/* For controlling RWSIG task */
+#define EC_CMD_RWSIG_ACTION	0x011D
+
+enum rwsig_action {
+	RWSIG_ACTION_ABORT = 0,		/* Abort RWSIG and prevent jumping */
+	RWSIG_ACTION_CONTINUE = 1,	/* Jump to RW immediately */
+};
+
+struct __ec_align4 ec_params_rwsig_action {
+	uint32_t action;
+};
 
 /*****************************************************************************/
 /* The command range 0x200-0x2FF is reserved for Rotor. */
@@ -4185,7 +4666,7 @@ struct __ec_align4 ec_response_rwsig_check_status {
 /*****************************************************************************/
 /* Fingerprint MCU commands: range 0x0400-0x040x */
 
-/* Fingerprint SPI sensor passthru command */
+/* Fingerprint SPI sensor passthru command: prototyping ONLY */
 #define EC_CMD_FP_PASSTHRU 0x0400
 
 #define EC_FP_FLAG_NOT_COMPLETE 0x1
@@ -4196,6 +4677,163 @@ struct __ec_align2 ec_params_fp_passthru {
 	uint8_t data[];		/* Data to send */
 };
 
+/* Fingerprint sensor configuration command: prototyping ONLY */
+#define EC_CMD_FP_SENSOR_CONFIG 0x0401
+
+#define EC_FP_SENSOR_CONFIG_MAX_REGS 16
+
+struct __ec_align2 ec_params_fp_sensor_config {
+	uint8_t count;		/* Number of setup registers */
+	/*
+	 * the value to send to each of the 'count' setup registers
+	 * is stored in the 'data' array for 'len' bytes just after
+	 * the previous one.
+	 */
+	uint8_t len[EC_FP_SENSOR_CONFIG_MAX_REGS];
+	uint8_t data[];
+};
+
+/* Configure the Fingerprint MCU behavior */
+#define EC_CMD_FP_MODE 0x0402
+
+/* Put the sensor in its lowest power mode */
+#define FP_MODE_DEEPSLEEP     (1<<0)
+/* Wait to see a finger on the sensor */
+#define FP_MODE_FINGER_DOWN   (1<<1)
+/* Poll until the finger has left the sensor */
+#define FP_MODE_FINGER_UP     (1<<2)
+/* Capture the current finger image */
+#define FP_MODE_CAPTURE       (1<<3)
+/* special value: don't change anything just read back current mode */
+#define FP_MODE_DONT_CHANGE   (1<<31)
+
+struct __ec_align4 ec_params_fp_mode {
+	uint32_t mode; /* as defined by FP_MODE_ constants */
+	/* TBD */
+};
+
+struct __ec_align4 ec_response_fp_mode {
+	uint32_t mode; /* as defined by FP_MODE_ constants */
+	/* TBD */
+};
+
+/* Retrieve Fingerprint sensor information */
+#define EC_CMD_FP_INFO 0x0403
+
+struct __ec_align2 ec_response_fp_info {
+	/* Sensor identification */
+	uint32_t vendor_id;
+	uint32_t product_id;
+	uint32_t model_id;
+	uint32_t version;
+	/* Image frame characteristics */
+	uint32_t frame_size;
+	uint32_t pixel_format; /* using V4L2_PIX_FMT_ */
+	uint16_t width;
+	uint16_t height;
+	uint16_t bpp;
+};
+
+/* Get the last captured finger frame: TODO: will be AES-encrypted */
+#define EC_CMD_FP_FRAME 0x0404
+
+struct __ec_align4 ec_params_fp_frame {
+	uint32_t offset;
+	uint32_t size;
+};
+
+/*****************************************************************************/
+/* Touchpad MCU commands: range 0x0500-0x05FF */
+
+/* Perform touchpad self test */
+#define EC_CMD_TP_SELF_TEST 0x0500
+
+/* Get number of frame types, and the size of each type */
+#define EC_CMD_TP_FRAME_INFO 0x0501
+
+struct __ec_align4 ec_response_tp_frame_info {
+	uint32_t n_frames;
+	uint32_t frame_sizes[0];
+};
+
+/* Create a snapshot of current frame readings */
+#define EC_CMD_TP_FRAME_SNAPSHOT 0x0502
+
+/* Read the frame */
+#define EC_CMD_TP_FRAME_GET 0x0503
+
+struct __ec_align4 ec_params_tp_frame_get {
+	uint32_t frame_index;
+	uint32_t offset;
+	uint32_t size;
+};
+
+/*****************************************************************************/
+/* EC-EC communication commands: range 0x0600-0x06FF */
+
+#define EC_COMM_TEXT_MAX 8
+
+/*
+ * Get battery static information, i.e. information that never changes, or
+ * very infrequently.
+ */
+#define EC_CMD_BATTERY_GET_STATIC 0x0600
+
+struct __ec_align_size1 ec_params_battery_static_info {
+	uint8_t index; /* Battery index. */
+};
+
+struct __ec_align4 ec_response_battery_static_info {
+	uint16_t design_capacity; /* Battery Design Capacity (mAh) */
+	uint16_t design_voltage; /* Battery Design Voltage (mV) */
+	char manufacturer[EC_COMM_TEXT_MAX]; /* Battery Manufacturer String */
+	char model[EC_COMM_TEXT_MAX]; /* Battery Model Number String */
+	char serial[EC_COMM_TEXT_MAX]; /* Battery Serial Number String */
+	char type[EC_COMM_TEXT_MAX]; /* Battery Type String */
+	/* TODO(crbug.com/795991): Consider moving to dynamic structure. */
+	uint32_t cycle_count; /* Battery Cycle Count */
+};
+
+/*
+ * Get battery dynamic information, i.e. information that is likely to change
+ * every time it is read.
+ */
+#define EC_CMD_BATTERY_GET_DYNAMIC 0x0601
+
+struct __ec_align_size1 ec_params_battery_dynamic_info {
+	uint8_t index; /* Battery index. */
+};
+
+struct __ec_align2 ec_response_battery_dynamic_info {
+	int16_t actual_voltage; /* Battery voltage (mV) */
+	int16_t actual_current; /* Battery current (mA); negative=discharging */
+	int16_t remaining_capacity; /* Remaining capacity (mAh) */
+	int16_t full_capacity; /* Capacity (mAh, might change occasionally) */
+	int16_t flags; /* Flags, see BATT_FLAG_* in battery.h */
+	int16_t desired_voltage; /* Charging voltage desired by battery (mV) */
+	int16_t desired_current; /* Charging current desired by battery (mA) */
+};
+
+/*
+ * Control charger chip. Used to control charger chip on the slave.
+ */
+#define EC_CMD_CHARGER_CONTROL 0x0602
+
+struct __ec_align_size1 ec_params_charger_control {
+	/*
+	 * Charger current (mA). Positive to allow base to draw up to
+	 * max_current and (possibly) charge battery, negative to request
+	 * current from base (OTG).
+	 */
+	int16_t max_current;
+
+	/* Voltage (mV) to use in OTG mode, ignored if max_current is >= 0. */
+	uint16_t otg_voltage;
+
+	/* Allow base battery charging (only makes sense if max_current > 0). */
+	uint8_t allow_charging;
+};
+
 /*****************************************************************************/
 /*
  * Reserve a range of host commands for board-specific, experimental, or
@@ -4270,4 +4908,6 @@ struct __ec_align2 ec_params_fp_passthru {
 #define EC_LPC_ADDR_OLD_PARAM   EC_HOST_CMD_REGION1
 #define EC_OLD_PARAM_SIZE       EC_HOST_CMD_REGION_SIZE
 
+#endif  /* !__ACPI__ */
+
 #endif  /* __CROS_EC_COMMANDS_H */
-- 
2.23.0.rc1.153.gdeed80330f-goog


From fbe39dc67f673452e81a1d405fb5b49a62ae047b Mon Sep 17 00:00:00 2001
From: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date: Fri, 3 May 2019 10:11:42 +0200
Subject: [PATCH] BACKPORT: FROMGIT: platform/chrome: Add CrOS USB PD logging
 driver

The CrOS USB PD logging feature is logically separate functionality of
the charge manager, hence has its own driver. The driver logs the event
data for the USB PD charger available in some ChromeOS Embedded
Controllers.

Signed-off-by: Guenter Roeck <groeck@chromium.org>
[remove macro to APPEND_STRING and minor cleanups]
Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
(cherry picked from commit a2679b64719085196a8e1762a40e90e92b1f3cf5
 git://git.kernel.org/pub/scm/linux/kernel/git/chrome-platform/linux.git chrome-platform-5.2)
(cherry picked from commit 7f042743306c3a9dc071952065514e2ae1814c1a
 git://git.kernel.org/pub/scm/linux/kernel/git/lee/mfd.git for-mfd-next)

Revert "CHROMIUM: Separate USB PD charger from USB PD logging" and
cherry-pick two patches from the maintainer's tree as a replacement.

 - platform/chrome: Add CrOS USB PD logging driver
 - mfd: cros_ec: Instantiate the CrOS USB PD logger driver

Then squash the three together and fix some trivial conflicts.

BUG=chromium:885330
TEST=Plug and unplug type-C accessories on Samus and Kevin and check kernel log

Change-Id: I36ea4c02fa2be41535bc028255e7134f748a59c8
Reviewed-on: https://chromium-review.googlesource.com/1583919
Commit-Ready: ChromeOS CL Exonerator Bot <chromiumos-cl-exonerator@appspot.gserviceaccount.com>
Tested-by: Rajat Jain <rajatja@google.com>
Reviewed-by: Nick Crews <ncrews@chromium.org>
Reviewed-by: Guenter Roeck <groeck@chromium.org>
---
 drivers/mfd/cros_ec_dev.c                   |   2 +-
 drivers/platform/chrome/Kconfig             |   2 +-
 drivers/platform/chrome/cros_usbpd_logger.c | 184 ++++++++++----------
 3 files changed, 93 insertions(+), 95 deletions(-)

diff --git a/drivers/mfd/cros_ec_dev.c b/drivers/mfd/cros_ec_dev.c
index fef424efd65d..e4064901b3f8 100644
--- a/drivers/mfd/cros_ec_dev.c
+++ b/drivers/mfd/cros_ec_dev.c
@@ -555,7 +555,7 @@ static const struct mfd_cell cros_ec_rtc_cells[] = {
 
 static const struct mfd_cell cros_usbpd_charger_cells[] = {
 	{ .name = "cros-usbpd-charger" },
-	{ .name = "cros-usbpd-logger" }
+	{ .name = "cros-usbpd-logger" },
 };
 
 #define CROS_EC_SENSOR_LEGACY_NUM 2
diff --git a/drivers/platform/chrome/Kconfig b/drivers/platform/chrome/Kconfig
index e3e73c2e2696..7a0e58bd44a4 100644
--- a/drivers/platform/chrome/Kconfig
+++ b/drivers/platform/chrome/Kconfig
@@ -152,7 +152,7 @@ config CROS_USBPD_LOGGER
 	select RTC_LIB
 	help
 	  This option enables support for logging event data for the USB PD charger
-	  available in the Embedded Controller on select Chrome OS systems.
+	  available in the Embedded Controller on ChromeOS systems.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called cros_usbpd_logger.
diff --git a/drivers/platform/chrome/cros_usbpd_logger.c b/drivers/platform/chrome/cros_usbpd_logger.c
index ba6c5510be15..7c7b267626a0 100644
--- a/drivers/platform/chrome/cros_usbpd_logger.c
+++ b/drivers/platform/chrome/cros_usbpd_logger.c
@@ -6,38 +6,58 @@
  */
 
 #include <linux/ktime.h>
+#include <linux/math64.h>
 #include <linux/mfd/cros_ec.h>
 #include <linux/mfd/cros_ec_commands.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/rtc.h>
 
-#define CROS_USB_PD_MAX_LOG_ENTRIES	30
-
-#define CROS_USB_PD_LOG_UPDATE_DELAY	msecs_to_jiffies(60000)
-#define CROS_USB_PD_CACHE_UPDATE_DELAY	msecs_to_jiffies(500)
-
-/* Buffer + macro for building PDLOG string */
-#define BUF_SIZE 80
-#define APPEND_STRING(buf, len, str, ...) ((len) += \
-	snprintf((buf) + (len), max(BUF_SIZE - (len), 0), (str), ##__VA_ARGS__))
-
 #define DRV_NAME "cros-usbpd-logger"
 
-#define EC_PD_LOG_DATA_SIZE	16
-#define EC_PD_LOG_RESP_SIZE	(sizeof(struct ec_response_pd_log) + \
-				 EC_PD_LOG_DATA_SIZE)
-#define EC_PD_BUFFER_SIZE	(sizeof(struct cros_ec_command) + \
-				 EC_PD_LOG_RESP_SIZE)
+#define CROS_USBPD_MAX_LOG_ENTRIES	30
+#define CROS_USBPD_LOG_UPDATE_DELAY	msecs_to_jiffies(60000)
+#define CROS_USBPD_DATA_SIZE		16
+#define CROS_USBPD_LOG_RESP_SIZE	(sizeof(struct ec_response_pd_log) + \
+					 CROS_USBPD_DATA_SIZE)
+#define CROS_USBPD_BUFFER_SIZE		(sizeof(struct cros_ec_command) + \
+					 CROS_USBPD_LOG_RESP_SIZE)
+/* Buffer for building the PDLOG string */
+#define BUF_SIZE	80
 
 struct logger_data {
 	struct device *dev;
 	struct cros_ec_dev *ec_dev;
-	u8 ec_buffer[EC_PD_BUFFER_SIZE];
+	u8 ec_buffer[CROS_USBPD_BUFFER_SIZE];
 	struct delayed_work log_work;
 	struct workqueue_struct *log_workqueue;
 };
 
+static const char * const chg_type_names[] = {
+	"None", "PD", "Type-C", "Proprietary", "DCP", "CDP", "SDP",
+	"Other", "VBUS"
+};
+
+static const char * const role_names[] = {
+	"Disconnected", "SRC", "SNK", "SNK (not charging)"
+};
+
+static const char * const fault_names[] = {
+	"---", "OCP", "fast OCP", "OVP", "Discharge"
+};
+
+static int append_str(char *buf, int pos, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vsnprintf(buf + pos, BUF_SIZE - pos, fmt, args);
+	va_end(args);
+
+	return i;
+}
+
 static struct ec_response_pd_log *ec_get_log_entry(struct logger_data *logger)
 {
 	struct cros_ec_dev *ec_dev = logger->ec_dev;
@@ -47,7 +67,7 @@ static struct ec_response_pd_log *ec_get_log_entry(struct logger_data *logger)
 	msg = (struct cros_ec_command *)logger->ec_buffer;
 
 	msg->command = ec_dev->cmd_offset + EC_CMD_PD_GET_LOG_ENTRY;
-	msg->insize = EC_PD_LOG_RESP_SIZE;
+	msg->insize = CROS_USBPD_LOG_RESP_SIZE;
 
 	ret = cros_ec_cmd_xfer_status(ec_dev->ec_dev, msg);
 	if (ret < 0)
@@ -59,114 +79,102 @@ static struct ec_response_pd_log *ec_get_log_entry(struct logger_data *logger)
 static void cros_usbpd_print_log_entry(struct ec_response_pd_log *r,
 				       ktime_t tstamp)
 {
-	static const char * const fault_names[] = {
-		"---", "OCP", "fast OCP", "OVP", "Discharge"
-	};
-	static const char * const role_names[] = {
-		"Disconnected", "SRC", "SNK", "SNK (not charging)"
-	};
-	static const char * const chg_type_names[] = {
-		"None", "PD", "Type-C", "Proprietary",
-		"DCP", "CDP", "SDP", "Other", "VBUS"
-	};
-	int i;
-	int role_idx, type_idx;
 	const char *fault, *role, *chg_type;
 	struct usb_chg_measures *meas;
 	struct mcdp_info *minfo;
+	int role_idx, type_idx;
+	char buf[BUF_SIZE + 1];
 	struct rtc_time rt;
-	u64 msecs;
 	int len = 0;
-	char buf[BUF_SIZE + 1];
+	s32 rem;
+	int i;
 
-	/* the timestamp is the number of 1024th of seconds in the past */
-	tstamp = ktime_sub_us(tstamp,
-		 (uint64_t)r->timestamp << PD_LOG_TIMESTAMP_SHIFT);
+	/* The timestamp is the number of 1024th of seconds in the past */
+	tstamp = ktime_sub_us(tstamp, r->timestamp << PD_LOG_TIMESTAMP_SHIFT);
 	rt = rtc_ktime_to_tm(tstamp);
 
 	switch (r->type) {
 	case PD_EVENT_MCU_CHARGE:
 		if (r->data & CHARGE_FLAGS_OVERRIDE)
-			APPEND_STRING(buf, len, "override ");
+			len += append_str(buf, len, "override ");
+
 		if (r->data & CHARGE_FLAGS_DELAYED_OVERRIDE)
-			APPEND_STRING(buf, len, "pending_override ");
+			len += append_str(buf, len, "pending_override ");
+
 		role_idx = r->data & CHARGE_FLAGS_ROLE_MASK;
 		role = role_idx < ARRAY_SIZE(role_names) ?
 			role_names[role_idx] : "Unknown";
+
 		type_idx = (r->data & CHARGE_FLAGS_TYPE_MASK)
 			 >> CHARGE_FLAGS_TYPE_SHIFT;
+
 		chg_type = type_idx < ARRAY_SIZE(chg_type_names) ?
 			chg_type_names[type_idx] : "???";
-		meas = (struct usb_chg_measures *)r->payload;
-
-		if ((role_idx == USB_PD_PORT_POWER_DISCONNECTED) ||
-		    (role_idx == USB_PD_PORT_POWER_SOURCE)) {
-			APPEND_STRING(buf, len, "%s", role);
-
-			if ((role_idx == USB_PD_PORT_POWER_SOURCE) &&
-			    (meas->current_max))
-				APPEND_STRING(buf, len, " %dmA",
-					      meas->current_max);
 
+		if (role_idx == USB_PD_PORT_POWER_DISCONNECTED ||
+		    role_idx == USB_PD_PORT_POWER_SOURCE) {
+			len += append_str(buf, len, "%s", role);
 			break;
 		}
 
-		APPEND_STRING(buf, len, "%s %s %s %dmV max %dmV / %dmA", role,
-			r->data & CHARGE_FLAGS_DUAL_ROLE ? "DRP" : "Charger",
-			chg_type,
-			meas->voltage_now,
-			meas->voltage_max,
-			meas->current_max);
+		meas = (struct usb_chg_measures *)r->payload;
+		len += append_str(buf, len, "%s %s %s %dmV max %dmV / %dmA",
+				  role,	r->data & CHARGE_FLAGS_DUAL_ROLE ?
+				  "DRP" : "Charger",
+				  chg_type, meas->voltage_now,
+				  meas->voltage_max, meas->current_max);
 		break;
 	case PD_EVENT_ACC_RW_FAIL:
-		APPEND_STRING(buf, len, "RW signature check failed");
+		len += append_str(buf, len, "RW signature check failed");
 		break;
 	case PD_EVENT_PS_FAULT:
 		fault = r->data < ARRAY_SIZE(fault_names) ? fault_names[r->data]
 							  : "???";
-		APPEND_STRING(buf, len, "Power supply fault: %s", fault);
+		len += append_str(buf, len, "Power supply fault: %s", fault);
 		break;
 	case PD_EVENT_VIDEO_DP_MODE:
-		APPEND_STRING(buf, len, "DP mode %sabled",
-			      (r->data == 1) ? "en" : "dis");
+		len += append_str(buf, len, "DP mode %sabled", r->data == 1 ?
+				  "en" : "dis");
 		break;
 	case PD_EVENT_VIDEO_CODEC:
 		minfo = (struct mcdp_info *)r->payload;
-		APPEND_STRING(buf, len,
-			      "HDMI info: family:%04x chipid:%04x irom:%d.%d.%d fw:%d.%d.%d",
-			      MCDP_FAMILY(minfo->family),
-			      MCDP_CHIPID(minfo->chipid),
-			      minfo->irom.major, minfo->irom.minor,
-			      minfo->irom.build, minfo->fw.major,
-			      minfo->fw.minor, minfo->fw.build);
+		len += append_str(buf, len, "HDMI info: family:%04x chipid:%04x ",
+				  MCDP_FAMILY(minfo->family),
+				  MCDP_CHIPID(minfo->chipid));
+		len += append_str(buf, len, "irom:%d.%d.%d fw:%d.%d.%d",
+				  minfo->irom.major, minfo->irom.minor,
+				  minfo->irom.build, minfo->fw.major,
+				  minfo->fw.minor, minfo->fw.build);
 		break;
 	default:
-		APPEND_STRING(buf, len,
-			"Event %02x (%04x) [", r->type, r->data);
+		len += append_str(buf, len, "Event %02x (%04x) [", r->type,
+				  r->data);
+
 		for (i = 0; i < PD_LOG_SIZE(r->size_port); i++)
-			APPEND_STRING(buf, len, "%02x ", r->payload[i]);
-		APPEND_STRING(buf, len, "]");
+			len += append_str(buf, len, "%02x ", r->payload[i]);
+
+		len += append_str(buf, len, "]");
 		break;
 	}
 
-	msecs = ktime_to_ms(tstamp);
-	do_div(msecs, MSEC_PER_SEC);
-	pr_info("PDLOG %d/%02d/%02d %02d:%02d:%02d.%03lld P%d %s\n",
+	div_s64_rem(ktime_to_ms(tstamp), MSEC_PER_SEC, &rem);
+	pr_info("PDLOG %d/%02d/%02d %02d:%02d:%02d.%03d P%d %s\n",
 		rt.tm_year + 1900, rt.tm_mon + 1, rt.tm_mday,
-		rt.tm_hour, rt.tm_min, rt.tm_sec, msecs,
+		rt.tm_hour, rt.tm_min, rt.tm_sec, rem,
 		PD_LOG_PORT(r->size_port), buf);
 }
 
 static void cros_usbpd_log_check(struct work_struct *work)
 {
 	struct logger_data *logger = container_of(to_delayed_work(work),
-		struct logger_data, log_work);
+						  struct logger_data,
+						  log_work);
 	struct device *dev = logger->dev;
 	struct ec_response_pd_log *r;
 	int entries = 0;
 	ktime_t now;
 
-	while (entries++ < CROS_USB_PD_MAX_LOG_ENTRIES) {
+	while (entries++ < CROS_USBPD_MAX_LOG_ENTRIES) {
 		r = ec_get_log_entry(logger);
 		now = ktime_get_real();
 		if (IS_ERR(r)) {
@@ -180,26 +188,16 @@ static void cros_usbpd_log_check(struct work_struct *work)
 	}
 
 	queue_delayed_work(logger->log_workqueue, &logger->log_work,
-			   CROS_USB_PD_LOG_UPDATE_DELAY);
+			   CROS_USBPD_LOG_UPDATE_DELAY);
 }
 
 static int cros_usbpd_logger_probe(struct platform_device *pd)
 {
-	struct device *dev = &pd->dev;
 	struct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);
+	struct device *dev = &pd->dev;
 	struct logger_data *logger;
 
-	if (!ec_dev) {
-		dev_err(dev, "No EC dev found\n");
-		return -EINVAL;
-	}
-
-	if (!ec_dev->ec_dev) {
-		dev_err(dev, "No EC device found.\n");
-		return -EINVAL;
-	}
-
-	logger = devm_kzalloc(dev, sizeof(struct logger_data), GFP_KERNEL);
+	logger = devm_kzalloc(dev, sizeof(*logger), GFP_KERNEL);
 	if (!logger)
 		return -ENOMEM;
 
@@ -210,10 +208,9 @@ static int cros_usbpd_logger_probe(struct platform_device *pd)
 
 	/* Retrieve PD event logs periodically */
 	INIT_DELAYED_WORK(&logger->log_work, cros_usbpd_log_check);
-	logger->log_workqueue =
-		create_singlethread_workqueue("cros_usbpd_log");
+	logger->log_workqueue =	create_singlethread_workqueue("cros_usbpd_log");
 	queue_delayed_work(logger->log_workqueue, &logger->log_work,
-			   CROS_USB_PD_LOG_UPDATE_DELAY);
+			   CROS_USBPD_LOG_UPDATE_DELAY);
 
 	return 0;
 }
@@ -232,7 +229,7 @@ static int __maybe_unused cros_usbpd_logger_resume(struct device *dev)
 	struct logger_data *logger = dev_get_drvdata(dev);
 
 	queue_delayed_work(logger->log_workqueue, &logger->log_work,
-			   CROS_USB_PD_LOG_UPDATE_DELAY);
+			   CROS_USBPD_LOG_UPDATE_DELAY);
 
 	return 0;
 }
@@ -242,11 +239,12 @@ static int __maybe_unused cros_usbpd_logger_suspend(struct device *dev)
 	struct logger_data *logger = dev_get_drvdata(dev);
 
 	cancel_delayed_work_sync(&logger->log_work);
+
 	return 0;
 }
 
-static SIMPLE_DEV_PM_OPS(cros_usbpd_logger_pm_ops,
-			 cros_usbpd_logger_suspend, cros_usbpd_logger_resume);
+static SIMPLE_DEV_PM_OPS(cros_usbpd_logger_pm_ops, cros_usbpd_logger_suspend,
+			 cros_usbpd_logger_resume);
 
 static struct platform_driver cros_usbpd_logger_driver = {
 	.driver = {
@@ -260,5 +258,5 @@ static struct platform_driver cros_usbpd_logger_driver = {
 module_platform_driver(cros_usbpd_logger_driver);
 
 MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("Chrome USBPD logger");
+MODULE_DESCRIPTION("Logging driver for ChromeOS EC USBPD Charger.");
 MODULE_ALIAS("platform:" DRV_NAME);
-- 
2.23.0.rc1.153.gdeed80330f-goog


From 887202da5af089ef2d50a1a179e3928d53544fb4 Mon Sep 17 00:00:00 2001
From: Douglas Anderson <dianders@chromium.org>
Date: Mon, 8 Apr 2019 13:28:51 -0700
Subject: [PATCH] CHROMIUM: ARM: rockchip: pm: Support deep suspend

The mainline Linux kernel has some placeholder code in "pm.c" for
supporting deep suspend but it's not actually selectable because
ROCKCHIP_ARM_OFF_LOGIC_NORMAL is always passed to rk3288_slp_mode_set.
...it also doesn't work due to the lack of any code to re-init SDRAM.

This patch actually makes deep suspend work and also makes it the
default, introducing a module parameter to go back to the non-deep
suspend mode (which you'd only want to do if for some reason deep
suspend wasn't working for you).

This code is mostly copied from the downstream Chrome OS 3.14 tree
with the following changes:

* The DDR Frequency changing code is currently stripped out of the
  "embedded" directory.  It'll be re-introduced in a later patch.
* In a previous change I changed the "rockchip,rk3288-noc" name to
  "rockchip,rk3288-service-bus" to match the TRM.  This code adapts to
  that.
* Upstream changed virt_to_phys() to __pa_symbol() in "pm.c" so I did
  too.

In general this code is not considered upstreamable (and thus this
patch is marked CHROMIUM) due to upstream not liking the way we do
embedded blobs [1].  Some other attempts have been made to come up
with better ways to do embedded blobs [2] but I know none that have
actually succeeded and landed their code.  By now people seem to have
given up since on newer systems the answer is to just jam all this
type of code into the firmware and hide it from the NAKing eyes of
kernel maintainers.

[1] https://lkml.kernel.org/r/1417461694-5129-1-git-send-email-dianders@chromium.org
[2] https://lkml.kernel.org/r/1459668234-16033-2-git-send-email-alexandre.belloni@free-electrons.com

BUG=chromium:941638
TEST=suspend_stress_test

Change-Id: I5c179ff9392a37218e27d6162a041c69f14026ce
Signed-off-by: Douglas Anderson <dianders@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/1570555
Reviewed-by: Matthias Kaehlcke <mka@chromium.org>

[rebase53(rrangel): Context conflict]
Signed-off-by: Raul E Rangel <rrangel@chromium.org>
---
 arch/arm/mach-rockchip/Makefile               |   4 +-
 arch/arm/mach-rockchip/embedded/.gitignore    |   1 +
 arch/arm/mach-rockchip/embedded/Makefile      |  55 ++
 arch/arm/mach-rockchip/embedded/rk3288_ddr.h  | 208 ++++++++
 .../embedded/rk3288_ddr_resume.c              | 261 ++++++++++
 .../mach-rockchip/embedded/rk3288_resume.c    | 129 +++++
 .../mach-rockchip/embedded/rk3288_resume.h    | 101 ++++
 .../embedded/rk3288_resume.lds.S              |  40 ++
 .../embedded/rk3288_resume_embedded.h         |  20 +
 arch/arm/mach-rockchip/embedded/sram_delay.h  |  38 ++
 arch/arm/mach-rockchip/pm.c                   |  62 ++-
 arch/arm/mach-rockchip/pm.h                   |  11 +-
 arch/arm/mach-rockchip/rk3288_ddr_suspend.c   | 480 ++++++++++++++++++
 arch/arm/mach-rockchip/sleep.S                |  64 ---
 include/soc/rockchip/rk3288-dmc-sram.h        | 235 +++++++++
 15 files changed, 1623 insertions(+), 86 deletions(-)
 create mode 100644 arch/arm/mach-rockchip/embedded/.gitignore
 create mode 100644 arch/arm/mach-rockchip/embedded/Makefile
 create mode 100644 arch/arm/mach-rockchip/embedded/rk3288_ddr.h
 create mode 100644 arch/arm/mach-rockchip/embedded/rk3288_ddr_resume.c
 create mode 100644 arch/arm/mach-rockchip/embedded/rk3288_resume.c
 create mode 100644 arch/arm/mach-rockchip/embedded/rk3288_resume.h
 create mode 100644 arch/arm/mach-rockchip/embedded/rk3288_resume.lds.S
 create mode 100644 arch/arm/mach-rockchip/embedded/rk3288_resume_embedded.h
 create mode 100644 arch/arm/mach-rockchip/embedded/sram_delay.h
 create mode 100644 arch/arm/mach-rockchip/rk3288_ddr_suspend.c
 delete mode 100644 arch/arm/mach-rockchip/sleep.S
 create mode 100644 include/soc/rockchip/rk3288-dmc-sram.h

diff --git a/arch/arm/mach-rockchip/Makefile b/arch/arm/mach-rockchip/Makefile
index 62596d5deb88..7a7f953cab54 100644
--- a/arch/arm/mach-rockchip/Makefile
+++ b/arch/arm/mach-rockchip/Makefile
@@ -2,5 +2,7 @@
 CFLAGS_platsmp.o := -march=armv7-a
 
 obj-$(CONFIG_ARCH_ROCKCHIP) += rockchip.o
-obj-$(CONFIG_PM_SLEEP) += pm.o sleep.o
+obj-$(CONFIG_PM_SLEEP) += pm.o rk3288_ddr_suspend.o
 obj-$(CONFIG_SMP) += headsmp.o platsmp.o
+
+obj-y += embedded/
diff --git a/arch/arm/mach-rockchip/embedded/.gitignore b/arch/arm/mach-rockchip/embedded/.gitignore
new file mode 100644
index 000000000000..6b8069a1dea8
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/.gitignore
@@ -0,0 +1 @@
+*.lds
diff --git a/arch/arm/mach-rockchip/embedded/Makefile b/arch/arm/mach-rockchip/embedded/Makefile
new file mode 100644
index 000000000000..a8d8f4700b32
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/Makefile
@@ -0,0 +1,55 @@
+# Makefile for embedded code blobs for Rockchip SoCs
+#
+# These code blobs are emedded into vmlinux and copied into SRAM
+# at times when SDRAM is not available.  Each blob is self contained.
+#
+# Some blobs may be linked to expect to run at a very specific address.
+# A good example is resume code blobs that always expect to run in a
+# very specific bit of SRAM that keeps power during sleep.  This code
+# is also running with the cache off so it can predict the address it
+# will be at.
+#
+# Other blobs may be linked with -fpic (by adding CFLAGS_file.o := -fpic).
+# These can be located anywhere.  I believe gcc will support this by
+# assuming that the .text and .data sections are relative to each other.
+#
+# That brings up the point that all blobs here:
+# - Are generally very small
+# - Generally have code and data jammed together in one blob.
+# - Generally have "parameters" at the beginning that are filled in by
+#   the kernel.
+
+obj-$(CONFIG_PM_SLEEP) += rk3288_resume.bin.o
+
+targets := rk3288_resume.o rk3288_ddr_resume.o \
+	rk3288_resume.elf rk3288_resume.lds \
+	rk3288_resume.bin rk3288_resume.bin.o
+
+# Reset objcopy flags, ARM puts "-O binary" here.
+OBJCOPYFLAGS :=
+
+# Our embedded code can't handle this flag.
+ifeq ($(CONFIG_FUNCTION_TRACER),y)
+ORIG_CFLAGS := $(KBUILD_CFLAGS)
+KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
+endif
+
+KBUILD_CFLAGS += -fno-stack-protector -fPIC
+
+# This is the ELF for the embedded binary
+LDFLAGS_rk3288_resume.elf := -Bstatic -nostdlib -T
+$(obj)/rk3288_resume.elf: $(obj)/rk3288_resume.lds \
+			  $(obj)/rk3288_resume.o \
+			  $(obj)/rk3288_ddr_resume.o \
+			  FORCE
+	$(call if_changed,ld)
+
+# Create binary data for the kernel
+OBJCOPYFLAGS_rk3288_resume.bin := -O binary
+$(obj)/rk3288_resume.bin: $(obj)/rk3288_resume.elf FORCE
+	$(call if_changed,objcopy)
+
+# Import the data into the kernel
+OBJCOPYFLAGS_rk3288_resume.bin.o += -B $(ARCH) -I binary -O elf32-littlearm
+$(obj)/rk3288_resume.bin.o: $(obj)/rk3288_resume.bin FORCE
+	$(call if_changed,objcopy)
diff --git a/arch/arm/mach-rockchip/embedded/rk3288_ddr.h b/arch/arm/mach-rockchip/embedded/rk3288_ddr.h
new file mode 100644
index 000000000000..8c65aa20de39
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/rk3288_ddr.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __MACH_ROCKCHIP_RK3288_DDR_H
+#define __MACH_ROCKCHIP_RK3288_DDR_H
+
+/* DDR pctl register */
+#define DDR_PCTL_SCFG			0x0000
+#define DDR_PCTL_SCTL			0x0004
+#define DDR_PCTL_STAT			0x0008
+#define DDR_PCTL_MCMD			0x0040
+#define DDR_PCTL_POWCTL			0x0044
+#define DDR_PCTL_POWSTAT		0x0048
+#define DDR_PCTL_CMDTSTATEN		0x0050
+#define DDR_PCTL_MRRCFG0		0x0060
+#define DDR_PCTL_MRRSTAT0		0x0064
+#define DDR_PCTL_MRRSTAT1		0x0068
+#define DDR_PCTL_MCFG1			0x007c
+#define DDR_PCTL_MCFG			0x0080
+#define DDR_PCTL_PPCFG			0x0084
+#define DDR_PCTL_TOGCNT1U		0x00c0
+#define DDR_PCTL_TINIT			0x00c4
+#define DDR_PCTL_TRSTH			0x00c8
+#define DDR_PCTL_TOGCNT100N		0x00cc
+#define DDR_PCTL_TREFI			0x00d0
+#define DDR_PCTL_TMRD			0x00d4
+#define DDR_PCTL_TRFC			0x00d8
+#define DDR_PCTL_TRP			0x00dc
+#define DDR_PCTL_TRTW			0x00e0
+#define DDR_PCTL_TAL			0x00e4
+#define DDR_PCTL_TCL			0x00e8
+#define DDR_PCTL_TCWL			0x00ec
+#define DDR_PCTL_TRAS			0x00f0
+#define DDR_PCTL_TRC			0x00f4
+#define DDR_PCTL_TRCD			0x00f8
+#define DDR_PCTL_TRRD			0x00fc
+#define DDR_PCTL_TRTP			0x0100
+#define DDR_PCTL_TWR			0x0104
+#define DDR_PCTL_TWTR			0x0108
+#define DDR_PCTL_TEXSR			0x010c
+#define DDR_PCTL_TXP			0x0110
+#define DDR_PCTL_TXPDLL			0x0114
+#define DDR_PCTL_TZQCS			0x0118
+#define DDR_PCTL_TZQCSI			0x011c
+#define DDR_PCTL_TDQS			0x0120
+#define DDR_PCTL_TCKSRE			0x0124
+#define DDR_PCTL_TCKSRX			0x0128
+#define DDR_PCTL_TCKE			0x012c
+#define DDR_PCTL_TMOD			0x0130
+#define DDR_PCTL_TRSTL			0x0134
+#define DDR_PCTL_TZQCL			0x0138
+#define DDR_PCTL_TMRR			0x013c
+#define DDR_PCTL_TCKESR			0x0140
+#define DDR_PCTL_TDPD			0x0144
+#define DDR_PCTL_DFITCTRLDELAY		0x0240
+#define DDR_PCTL_DFIODTCFG		0x0244
+#define DDR_PCTL_DFIODTCFG1		0x0248
+#define DDR_PCTL_DFIODTRANKMAP		0x024c
+#define DDR_PCTL_DFITPHYWRDATA		0x0250
+#define DDR_PCTL_DFITPHYWRLAT		0x0254
+#define DDR_PCTL_DFITRDDATAEN		0x0260
+#define DDR_PCTL_DFITPHYRDLAT           0x0264
+#define DDR_PCTL_DFITPHYUPDTYPE0        0x0270
+#define DDR_PCTL_DFITPHYUPDTYPE1        0x0274
+#define DDR_PCTL_DFITPHYUPDTYPE2        0x0278
+#define DDR_PCTL_DFITPHYUPDTYPE3        0x027c
+#define DDR_PCTL_DFITCTRLUPDMIN         0x0280
+#define DDR_PCTL_DFITCTRLUPDMAX         0x0284
+#define DDR_PCTL_DFITCTRLUPDDLY         0x0288
+#define DDR_PCTL_DFIUPDCFG		0x0290
+#define DDR_PCTL_DFITREFMSKI            0x0294
+#define DDR_PCTL_DFITCTRLUPDI           0x0298
+#define DDR_PCTL_DFISTCFG0		0x02c4
+#define DDR_PCTL_DFISTCFG1		0x02c8
+#define DDR_PCTL_DFITDRAMCLKEN          0x02d0
+#define DDR_PCTL_DFITDRAMCLKDIS         0x02d4
+#define DDR_PCTL_DFISTCFG2		0x02d8
+#define DDR_PCTL_DFILPCFG0		0x02f0
+
+/* DDR phy register */
+#define DDR_PUBL_RIDR		0x0000
+#define DDR_PUBL_PIR		0x0004
+#define DDR_PUBL_PGCR		0x0008
+#define DDR_PUBL_PGSR		0x000c
+#define DDR_PUBL_DLLGCR		0x0010
+#define DDR_PUBL_ACDLLCR	0x0014
+#define DDR_PUBL_PTR0		0x0018
+#define DDR_PUBL_PTR1		0x001c
+#define DDR_PUBL_PTR2		0x0020
+#define DDR_PUBL_ACIOCR		0x0024
+#define DDR_PUBL_DXCCR		0x0028
+#define DDR_PUBL_DSGCR		0x002c
+#define DDR_PUBL_DCR		0x0030
+#define DDR_PUBL_DTPR0		0x0034
+#define DDR_PUBL_DTPR1		0x0038
+#define DDR_PUBL_DTPR2		0x003c
+#define DDR_PUBL_MR0		0x0040
+#define DDR_PUBL_MR1		0x0044
+#define DDR_PUBL_MR2		0x0048
+#define DDR_PUBL_MR3		0x004c
+#define DDR_PUBL_ODTCR		0x0050
+#define DDR_PUBL_DTAR		0x0054
+#define DDR_PUBL_ZQ0CR0		0x0180
+#define DDR_PUBL_ZQ0CR1		0x0184
+#define DDR_PUBL_ZQ1CR0		0x0190
+#define DDR_PUBL_DX0GCR		0x01c0
+#define DDR_PUBL_DX0GSR0	0x01c4
+#define DDR_PUBL_DX0GSR1	0x01c8
+#define DDR_PUBL_DX0DLLCR	0x01cc
+#define DDR_PUBL_DX0DQTR	0x01d0
+#define DDR_PUBL_DX0DQSTR	0x01d4
+#define DDR_PUBL_DX1GCR		0x0200
+#define DDR_PUBL_DX1GSR0	0x0204
+#define DDR_PUBL_DX1GSR1	0x0208
+#define DDR_PUBL_DX1DLLCR	0x020c
+#define DDR_PUBL_DX1DQTR	0x0210
+#define DDR_PUBL_DX1DQSTR	0x0214
+#define DDR_PUBL_DX2GCR		0x0240
+#define DDR_PUBL_DX2GSR0	0x0244
+#define DDR_PUBL_DX2GSR1	0x0248
+#define DDR_PUBL_DX2DLLCR	0x024c
+#define DDR_PUBL_DX2DQTR	0x0250
+#define DDR_PUBL_DX2DQSTR	0x0254
+#define DDR_PUBL_DX3GCR		0x0280
+#define DDR_PUBL_DX3GSR0	0x0284
+#define DDR_PUBL_DX3GSR1	0x0288
+#define DDR_PUBL_DX3DLLCR	0x028c
+#define DDR_PUBL_DX3DQTR	0x0290
+#define DDR_PUBL_DX3DQSTR	0x0294
+
+/* DDR msch register */
+#define DDR_MSCH_DDRCONF	0x0008
+#define DDR_MSCH_DDRTIMING	0x000c
+#define DDR_MSCH_DDRMODE	0x0010
+#define DDR_MSCH_READLATENCY	0x0014
+#define DDR_MSCH_ACTIVATE	0x0038
+#define DDR_MSCH_DEVTODEV	0x003c
+
+#define DLLSRST			BIT(30)
+#define POWER_UP_START		BIT(0)
+#define POWER_UP_DONE		BIT(0)
+#define DDR0IO_RET_DE_REQ	BIT(21)
+#define DDR0I1_RET_DE_REQ	BIT(22)
+
+#define PCTL_STAT_MSK			(7)
+#define LP_TRIG_VAL(n)			(((n) >> 4) & 7)
+
+/* SCTL */
+#define INIT_STATE			(0)
+#define CFG_STATE			(1)
+#define GO_STATE			(2)
+#define SLEEP_STATE			(3)
+#define WAKEUP_STATE			(4)
+
+/* STAT */
+#define LP_TRIG_VAL(n)			(((n) >> 4) & 7)
+#define PCTL_STAT_MSK			(7)
+#define INIT_MEM			(0)
+#define CONFIG				(1)
+#define CONFIG_REQ			(2)
+#define ACCESS				(3)
+#define ACCESS_REQ			(4)
+#define LOW_POWER			(5)
+#define LOW_POWER_ENTRY_REQ		(6)
+#define LOW_POWER_EXIT_REQ		(7)
+
+/* PGSR */
+#define PGSR_IDONE			(1 << 0)
+#define PGSR_DLDONE			(1 << 1)
+#define PGSR_ZCDONE			(1 << 2)
+#define PGSR_DIDONE			(1 << 3)
+#define PGSR_DTDONE			(1 << 4)
+#define PGSR_DTERR			(1 << 5)
+#define PGSR_DTIERR			(1 << 6)
+#define PGSR_DFTERR			(1 << 7)
+#define PGSR_RVERR			(1 << 8)
+#define PGSR_RVEIRR			(1 << 9)
+
+/* PIR */
+#define PIR_INIT			(1 << 0)
+#define PIR_DLLSRST			(1 << 1)
+#define PIR_DLLLOCK			(1 << 2)
+#define PIR_ZCAL			(1 << 3)
+#define PIR_ITMSRST			(1 << 4)
+#define PIR_DRAMRST			(1 << 5)
+#define PIR_DRAMINIT			(1 << 6)
+#define PIR_QSTRN			(1 << 7)
+#define PIR_RVTRN			(1 << 8)
+#define PIR_ICPC			(1 << 16)
+#define PIR_DLLBYP			(1 << 17)
+#define PIR_CTLDINIT			(1 << 18)
+#define PIR_CLRSR			(1 << 28)
+#define PIR_LOCKBYP			(1 << 29)
+#define PIR_ZCALBYP			(1 << 30)
+#define PIR_INITBYP			(1u << 31)
+
+#endif /* __MACH_ROCKCHIP_RK3288_DDR_H */
diff --git a/arch/arm/mach-rockchip/embedded/rk3288_ddr_resume.c b/arch/arm/mach-rockchip/embedded/rk3288_ddr_resume.c
new file mode 100644
index 000000000000..ceee5e5ab1a4
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/rk3288_ddr_resume.c
@@ -0,0 +1,261 @@
+/*
+ * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/bug.h>		/* BUILD_BUG_ON */
+#include <linux/kernel.h>
+
+#include <asm/io.h>
+
+#include "rk3288_ddr.h"
+#include "rk3288_resume.h"
+#include "sram_delay.h"
+
+#include "../pm.h"
+
+#define PMU_ADDR		0xff730000
+#define PMU_PWRMODE_CON_ADDR	((void *)(PMU_ADDR + RK3288_PMU_PWRMODE_CON))
+#define DDR_PCTRL0_ADDR		((void *)0xff610000)
+#define DDR_PUBL0_ADDR		((void *)0xff620000) /* phy */
+#define DDR_PCTRL1_ADDR		((void *)0xff630000)
+#define DDR_PUBL1_ADDR		((void *)0xff640000) /* phy */
+
+#define MSCH0_ADDR		((void *)0xffac0000)
+#define MSCH1_ADDR		((void *)0xffac0080)
+
+static void * const pctrl_addrs[] = { DDR_PCTRL0_ADDR, DDR_PCTRL1_ADDR };
+static void * const phy_addrs[] = { DDR_PUBL0_ADDR, DDR_PUBL1_ADDR };
+static void * const msch_addrs[] = { MSCH0_ADDR, MSCH1_ADDR };
+
+static void reset_dll(void __iomem *phy_addr)
+{
+	static const u32 reg[] = { DDR_PUBL_ACDLLCR, DDR_PUBL_DX0DLLCR,
+				   DDR_PUBL_DX1DLLCR, DDR_PUBL_DX2DLLCR,
+				   DDR_PUBL_DX3DLLCR };
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(reg); i++)
+		writel_relaxed(readl_relaxed(phy_addr + reg[i]) & ~DLLSRST,
+			       phy_addr + reg[i]);
+
+	sram_udelay(10);
+
+	for (i = 0; i < ARRAY_SIZE(reg); i++)
+		writel_relaxed(readl_relaxed(phy_addr + reg[i]) | DLLSRST,
+			       phy_addr + reg[i]);
+
+	sram_udelay(10);
+}
+
+static void phy_init(void __iomem *phy_addr)
+{
+	u32 val;
+
+	val = readl_relaxed(phy_addr + DDR_PUBL_PIR);
+
+	val |= PIR_INIT | PIR_DLLSRST | PIR_DLLLOCK |
+	       PIR_ZCAL | PIR_ITMSRST | PIR_CLRSR;
+
+	writel_relaxed(val, phy_addr + DDR_PUBL_PIR);
+
+	sram_udelay(1);
+
+	while ((readl_relaxed(phy_addr + DDR_PUBL_PGSR) &
+		(PGSR_IDONE | PGSR_DLDONE | PGSR_ZCDONE)) !=
+		(PGSR_IDONE | PGSR_DLDONE | PGSR_ZCDONE))
+		;
+}
+
+static void memory_init(void __iomem *phy_addr)
+{
+	u32 val;
+
+	val = readl_relaxed(phy_addr + DDR_PUBL_PIR);
+
+	val |= PIR_INIT | PIR_DRAMINIT | PIR_LOCKBYP |
+	       PIR_ZCALBYP | PIR_CLRSR | PIR_ICPC;
+
+	writel_relaxed(val, phy_addr + DDR_PUBL_PIR);
+
+	sram_udelay(1);
+	while ((readl_relaxed(phy_addr + DDR_PUBL_PGSR) &
+		(PGSR_IDONE | PGSR_DLDONE)) != (PGSR_IDONE | PGSR_DLDONE))
+		;
+}
+
+static void move_to_lowpower_state(void __iomem *pctrl_addr,
+				   void __iomem *phy_addr)
+{
+	u32 state;
+
+	while (1) {
+		state = readl_relaxed(pctrl_addr +
+				      DDR_PCTL_STAT) & PCTL_STAT_MSK;
+
+		switch (state) {
+		case INIT_MEM:
+			writel_relaxed(CFG_STATE, pctrl_addr + DDR_PCTL_SCTL);
+			while ((readl_relaxed(pctrl_addr + DDR_PCTL_STAT) &
+				PCTL_STAT_MSK) != CONFIG)
+				;
+			/* fallthrough */
+		case CONFIG:
+			writel_relaxed(GO_STATE, pctrl_addr + DDR_PCTL_SCTL);
+			while ((readl_relaxed(pctrl_addr + DDR_PCTL_STAT) &
+				PCTL_STAT_MSK) != ACCESS)
+				;
+			/* fallthrough */
+		case ACCESS:
+			writel_relaxed(SLEEP_STATE, pctrl_addr + DDR_PCTL_SCTL);
+			while ((readl_relaxed(pctrl_addr + DDR_PCTL_STAT) &
+				PCTL_STAT_MSK) != LOW_POWER)
+				;
+			/* fallthrough */
+		case LOW_POWER:
+			return;
+		default:
+			break;
+		}
+	}
+}
+
+static void move_to_access_state(void __iomem *pctrl_addr,
+				 void __iomem *phy_addr)
+{
+	u32 state;
+
+	while (1) {
+		state = readl_relaxed(pctrl_addr +
+				      DDR_PCTL_STAT) & PCTL_STAT_MSK;
+
+		switch (state) {
+		case LOW_POWER:
+			if (LP_TRIG_VAL(readl_relaxed(pctrl_addr +
+						      DDR_PCTL_STAT)) == 1)
+				return;
+
+			writel_relaxed(WAKEUP_STATE,
+				       pctrl_addr + DDR_PCTL_SCTL);
+			while ((readl_relaxed(pctrl_addr + DDR_PCTL_STAT) &
+				PCTL_STAT_MSK) != ACCESS)
+				;
+
+			/* wait DLL lock */
+			while ((readl_relaxed(phy_addr +
+					      DDR_PUBL_PGSR) & PGSR_DLDONE)
+				!= PGSR_DLDONE)
+				;
+
+			break;
+		case INIT_MEM:
+			writel_relaxed(CFG_STATE, pctrl_addr + DDR_PCTL_SCTL);
+			while ((readl_relaxed(pctrl_addr + DDR_PCTL_STAT) &
+				PCTL_STAT_MSK) != CONFIG)
+				;
+			 /* fallthrough here */
+		case CONFIG:
+			writel_relaxed(GO_STATE,  pctrl_addr + DDR_PCTL_SCTL);
+			while ((readl_relaxed(pctrl_addr + DDR_PCTL_STAT) &
+				PCTL_STAT_MSK) == CONFIG)
+				;
+			break;
+		case ACCESS:
+			return;
+		default:
+			break;
+		}
+	}
+}
+
+static void rk3288_ddr_reg_restore(void __iomem *regbase, const u32 reg_list[],
+				   int num_reg, const u32 *vals)
+{
+	int i;
+
+	for (i = 0; i < num_reg && reg_list[i] != RK3288_BOGUS_OFFSET; i++)
+		writel_relaxed(vals[i], regbase + reg_list[i]);
+}
+
+void rk3288_ddr_resume_early(const struct rk3288_ddr_save_data *ddr_save_data)
+{
+	int ch;
+
+	/* PWM saves full address, so base is NULL */
+	rk3288_ddr_reg_restore(NULL, ddr_save_data->pwm_addrs,
+			       RK3288_MAX_PWM_REGS, ddr_save_data->pwm_vals);
+
+	/*
+	 * PWM never runs higher than 1.2V giving a 2000uV/us ramp delay since
+	 * we start from 1V. This is a very conservative ramp delay for the
+	 * regulator.
+	 */
+	sram_udelay(100);
+
+	for (ch = 0; ch < ARRAY_SIZE(pctrl_addrs); ch++) {
+		/* DLL bypass */
+		rk3288_ddr_reg_restore(phy_addrs[ch],
+				       ddr_save_data->phy_dll_offsets,
+				       RK3288_MAX_DDR_PHY_DLL_REGS,
+				       ddr_save_data->phy_dll_vals[ch]);
+
+		reset_dll(phy_addrs[ch]);
+
+		/* ddr ctrl restore; NOTE: both channels must be the same */
+		rk3288_ddr_reg_restore(pctrl_addrs[ch],
+				       ddr_save_data->ctrl_offsets,
+				       RK3288_MAX_DDR_CTRL_REGS,
+				       ddr_save_data->ctrl_vals);
+
+		/* ddr phy restore */
+		rk3288_ddr_reg_restore(phy_addrs[ch],
+				       ddr_save_data->phy_offsets,
+				       RK3288_MAX_DDR_PHY_REGS,
+				       ddr_save_data->phy_vals[ch]);
+
+		/* msch restore */
+		rk3288_ddr_reg_restore(msch_addrs[ch],
+				       ddr_save_data->msch_offsets,
+				       RK3288_MAX_DDR_MSCH_REGS,
+				       ddr_save_data->msch_vals[ch]);
+
+		phy_init(phy_addrs[ch]);
+
+		/* power up ddr power */
+		writel_relaxed(POWER_UP_START,
+			       pctrl_addrs[ch] + DDR_PCTL_POWCTL);
+		while (!(readl_relaxed(pctrl_addrs[ch] + DDR_PCTL_POWSTAT) &
+			 POWER_UP_DONE))
+			;
+
+		/* zqcr restore; NOTE: both channels must be the same */
+		rk3288_ddr_reg_restore(phy_addrs[ch],
+				       ddr_save_data->phy_zqcr_offsets,
+				       RK3288_MAX_DDR_PHY_ZQCR_REGS,
+				       ddr_save_data->phy_zqcr_vals);
+
+		memory_init(phy_addrs[ch]);
+
+		move_to_lowpower_state(pctrl_addrs[ch], phy_addrs[ch]);
+	}
+
+	/* disable retention */
+	writel_relaxed(readl_relaxed(PMU_PWRMODE_CON_ADDR) |
+	       DDR0IO_RET_DE_REQ | DDR0I1_RET_DE_REQ,
+	       PMU_PWRMODE_CON_ADDR);
+
+	sram_udelay(1);
+
+	/* disable self-refresh */
+	for (ch = 0; ch < ARRAY_SIZE(pctrl_addrs); ch++)
+		move_to_access_state(pctrl_addrs[ch], phy_addrs[ch]);
+}
diff --git a/arch/arm/mach-rockchip/embedded/rk3288_resume.c b/arch/arm/mach-rockchip/embedded/rk3288_resume.c
new file mode 100644
index 000000000000..bf187b9f0291
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/rk3288_resume.c
@@ -0,0 +1,129 @@
+/*
+ * Rockchip rk3288 resume code
+ *
+ * This code is intended to be linked into the embedded resume binary
+ * for the rk3288 SoC
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+
+#include "rk3288_resume.h"
+#include "rk3288_resume_embedded.h"
+
+#define INIT_CPSR	(PSR_I_BIT | PSR_F_BIT | SVC_MODE)
+
+static __noreturn void rk3288_resume(void);
+
+/* Parameters of early board initialization in SPL */
+struct rk3288_resume_params rk3288_resume_params
+		__attribute__((section(".resume_params"))) = {
+	.resume_loc	= rk3288_resume,
+};
+
+/**
+ * rk3288_resume_c - Main C entry point for rk3288 at resume time
+ *
+ * This function is called by rk3288_resume() and does the brunt of
+ * any resume processing.  After it's done it will call the kernel's
+ * cpu_resume() function (which it finds through its params structure).
+ *
+ * At the time this function is called:
+ * - We know we're on CPU0.
+ * - Interrupts are disabled.
+ * - We've got a stack.
+ * - The cache is turned off, so all addresses are physical.
+ * - SDRAM hasn't been restored yet (if it was off).
+ *
+ * WARNING: This code, the stack and the params structure are all sitting in
+ * PMU SRAM.  If you try to write to that memory using an 8-bit access (or even
+ * 16-bit) you'll get an imprecise data abort and it will be very hard to debug.
+ * Keep everything in here as 32-bit wide and aligned.  YOU'VE BEEN WARNED.
+ */
+static void __noreturn rk3288_resume_c(void)
+{
+	u32 tmp;
+
+	if (rk3288_resume_params.l2ctlr_f)
+		asm("mcr p15, 1, %0, c9, c0, 2" : :
+			"r" (rk3288_resume_params.l2ctlr));
+
+	/* We will have lost this when the CPU powered off */
+	if (IS_ENABLED(CONFIG_ARM_ERRATA_818325_852422)) {
+		asm volatile("mrc p15, 0, %0, c15, c0, 1" : "=r" (tmp));
+		tmp |= (1 << 12);
+		asm volatile("mcr p15, 0, %0, c15, c0, 1" : : "r" (tmp));
+		asm volatile("isb");
+	}
+	if (IS_ENABLED(CONFIG_ARM_ERRATA_821420)) {
+		asm volatile("mrc p15, 0, %0, c15, c0, 2" : "=r" (tmp));
+		tmp |= (1 << 1);
+		asm volatile("mcr p15, 0, %0, c15, c0, 2" : : "r" (tmp));
+		asm volatile("isb");
+	}
+	if (IS_ENABLED(CONFIG_ARM_ERRATA_825619)) {
+		asm volatile("mrc p15, 0, %0, c15, c0, 1" : "=r" (tmp));
+		tmp |= (1 << 24);
+		asm volatile("mcr p15, 0, %0, c15, c0, 1" : : "r" (tmp));
+		asm volatile("isb");
+	}
+	if (IS_ENABLED(CONFIG_ARM_ERRATA_FOOBAR)) {
+		asm volatile("mrc p15, 0, %0, c15, c0, 1" : "=r" (tmp));
+		tmp |= (1 << 10);
+		asm volatile("mcr p15, 0, %0, c15, c0, 1" : : "r" (tmp));
+		asm volatile("isb");
+	}
+	if (IS_ENABLED(CONFIG_ARM_ERRATA_CR711784)) {
+		asm volatile("mrc p15, 0, %0, c15, c0, 1" : "=r" (tmp));
+		tmp |= (1 << 11);
+		asm volatile("mcr p15, 0, %0, c15, c0, 1" : : "r" (tmp));
+		asm volatile("isb");
+	}
+
+	if (rk3288_resume_params.ddr_resume_f)
+		rk3288_ddr_resume_early(&rk3288_resume_params.ddr_save_data);
+
+	rk3288_resume_params.cpu_resume();
+}
+
+/**
+ * rk3288_resume - First entry point for rk3288 at resume time
+ *
+ * A pointer to this function is stored in rk3288_resume_params.  The
+ * kernel uses the pointer in that structure to find this function and
+ * to put its (physical) address in a location that it will get jumped
+ * to at resume time.
+ *
+ * There is no stack at the time this function is called, so this
+ * function is in charge of setting it up.  We get to a function with
+ * a normal stack pointer ASAP.
+ */
+static void __naked __noreturn rk3288_resume(void)
+{
+	/* Make sure we're on CPU0, no IRQs and get a stack setup */
+	asm volatile (
+			"msr	cpsr_cxf, %0\n"
+
+			/* Only cpu0 continues to run, the others halt here */
+			"mrc	p15, 0, r1, c0, c0, 5\n"
+			"and	r1, r1, #0xf\n"
+			"cmp	r1, #0\n"
+			"beq	cpu0run\n"
+		"secondary_loop:\n"
+			"wfe\n"
+			"b	secondary_loop\n"
+
+		"cpu0run:\n"
+			"mov	sp, %1\n"
+		:
+		: "i" (INIT_CPSR), "r" (&__stack_start)
+		: "cc", "r1", "sp");
+
+	/* Now get into a normal function that can use a stack */
+	rk3288_resume_c();
+}
diff --git a/arch/arm/mach-rockchip/embedded/rk3288_resume.h b/arch/arm/mach-rockchip/embedded/rk3288_resume.h
new file mode 100644
index 000000000000..2fe25cb929a7
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/rk3288_resume.h
@@ -0,0 +1,101 @@
+/*
+ * Rockchip resume header (API from kernel to embedded code)
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MACH_ROCKCHIP_RK3288_RESUME_H
+#define __MACH_ROCKCHIP_RK3288_RESUME_H
+
+#define RK3288_NUM_DDR_PORTS		2
+
+#define RK3288_MAX_PWM_REGS		3
+#define RK3288_MAX_DDR_PHY_DLL_REGS	7
+#define RK3288_MAX_DDR_CTRL_REGS	64
+#define RK3288_MAX_DDR_PHY_REGS		29
+#define RK3288_MAX_DDR_MSCH_REGS	6
+#define RK3288_MAX_DDR_PHY_ZQCR_REGS	2
+
+#define RK3288_BOGUS_OFFSET		0xffffffff
+
+/**
+ * rk3288_ddr_save - Parameters needed to reinit SDRAM after suspend
+ *
+ * This structure contains data needed to restore SDRAM after suspend.
+ * Generally:
+ * - There are two controllers and we need to save data for both.  We save
+ *   the same registers for both, so you see two sets of values and one sets
+ *   of offsets (the register offset from the base of the controller).
+ *   There are a few registers that are always the same for both controllers
+ *   so we only save one set of values.
+ *
+ * Offsets are saved at init time and vals are saved on each suspend.
+ *
+ * NOTE: offsets are u32 values right now to keep everything 32-bit and avoid
+ * 8-bit and 16-bit access problems in PMU SRAM (see WARNING below).
+ * Technically, though, 8-bit and 16-bit _reads_ seem to work, so as long as
+ * we were careful in setting things up we could possibly save some memory by
+ * storing 16-bit offsets.  We can investigate if we ever get that tight on
+ * space.
+ */
+struct rk3288_ddr_save_data {
+	u32 pwm_addrs[RK3288_MAX_PWM_REGS];
+	u32 pwm_vals[RK3288_MAX_PWM_REGS];
+
+	u32 phy_dll_offsets[RK3288_MAX_DDR_PHY_DLL_REGS];
+	u32 phy_dll_vals[RK3288_NUM_DDR_PORTS][RK3288_MAX_DDR_PHY_DLL_REGS];
+
+	u32 ctrl_offsets[RK3288_MAX_DDR_CTRL_REGS];
+	u32 ctrl_vals[RK3288_MAX_DDR_CTRL_REGS];		/* Both same */
+
+	u32 phy_offsets[RK3288_MAX_DDR_PHY_REGS];
+	u32 phy_vals[RK3288_NUM_DDR_PORTS][RK3288_MAX_DDR_PHY_REGS];
+
+	u32 msch_offsets[RK3288_MAX_DDR_MSCH_REGS];
+	u32 msch_vals[RK3288_NUM_DDR_PORTS][RK3288_MAX_DDR_MSCH_REGS];
+
+	u32 phy_zqcr_offsets[RK3288_MAX_DDR_PHY_ZQCR_REGS];
+	u32 phy_zqcr_vals[RK3288_MAX_DDR_PHY_ZQCR_REGS];	/* Both same */
+};
+
+/**
+ * rk3288_resume_params - Parameter space for the resume code
+ *
+ * This structure is at the start of the resume blob and is used to communicate
+ * between the resume blob and the callers.
+ *
+ * WARNING: This structure is sitting in PMU SRAM.  If you try to write to that
+ * memory using an 8-bit access (or even 16-bit) you'll get an imprecise data
+ * abort and it will be very hard to debug.  Keep everything in here as 32-bit
+ * wide and aligned.  YOU'VE BEEN WARNED.
+ *
+ * @resume_loc:		The value here should be the resume address that the CPU
+ *			is programmed to go to at resume time.
+ *
+ * @l2ctlr_f:		If non-zero we'll set l2ctlr at resume time.
+ * @l2ctlr:		The value to set l2ctlr to at resume time.
+ *
+ * @ddr_resume_f	True if we should resume DDR.
+ * @ddr_save_data:	Data for save / restore of DDR.
+ *
+ * @cpu_resume:		The function to jump to when we're all done.
+ */
+struct rk3288_resume_params {
+	/* This is compiled in and can be read to find the resume location */
+	__noreturn void (*resume_loc)(void);
+
+	/* Filled in by the client of the resume code */
+	u32 l2ctlr_f;		/* u32 not bool to avoid 8-bit SRAM access */
+	u32 l2ctlr;
+
+	u32 ddr_resume_f;	/* u32 not bool to avoid 8-bit SRAM access */
+	struct rk3288_ddr_save_data ddr_save_data;
+
+	__noreturn void (*cpu_resume)(void);
+};
+
+#endif /* __MACH_ROCKCHIP_RK3288_RESUME_H */
diff --git a/arch/arm/mach-rockchip/embedded/rk3288_resume.lds.S b/arch/arm/mach-rockchip/embedded/rk3288_resume.lds.S
new file mode 100644
index 000000000000..0643169d496f
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/rk3288_resume.lds.S
@@ -0,0 +1,40 @@
+MEMORY {
+	pmu_sram_code  : ORIGIN = 0xff720000, LENGTH = 0xf00
+	pmu_sram_stack : ORIGIN = 0xff720f00, LENGTH = 0x100
+}
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+
+SECTIONS
+{
+	/* Don't need unwind tables */
+	/DISCARD/ : {
+		*(.ARM.exidx*)
+		*(.ARM.extab*)
+	}
+
+	/* Kernel code finds params because it knows they are first */
+	.params : { *(.resume_params*) } > pmu_sram_code
+	. = ALIGN(4);
+
+	.text : { *(.text*) } > pmu_sram_code
+	. = ALIGN(4);
+
+	.rodata : { *(SORT_BY_ALIGNMENT(.rodata*)) } > pmu_sram_code
+	. = ALIGN(4);
+
+	.data : {
+		*(SORT_BY_ALIGNMENT(.data*))
+		. = ALIGN(4);
+
+		/* We purposely put bss as part of data to avoid initting */
+		*(SORT_BY_ALIGNMENT(.bss*))
+		. = ALIGN(4);
+	} > pmu_sram_code
+
+	.stack : {
+		. += LENGTH(pmu_sram_stack) - 8;
+		__stack_start = .;
+	} > pmu_sram_stack
+}
diff --git a/arch/arm/mach-rockchip/embedded/rk3288_resume_embedded.h b/arch/arm/mach-rockchip/embedded/rk3288_resume_embedded.h
new file mode 100644
index 000000000000..8e87f4665090
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/rk3288_resume_embedded.h
@@ -0,0 +1,20 @@
+/*
+ * Rockchip resume header (API between files in embedded code)
+ *
+ * Copyright (c) 2014 Google, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MACH_ROCKCHIP_RK3288_RESUME_EMBEDDED_H
+#define __MACH_ROCKCHIP_RK3288_RESUME_EMBEDDED_H
+
+/* Defined in the linker script */
+extern u32 *__stack_start;
+
+/* Defined by SDRAM code */
+void rk3288_ddr_resume_early(struct rk3288_ddr_save_data *ddr_save_data);
+
+#endif /* __MACH_ROCKCHIP_RK3288_RESUME_EMBEDDED_H */
diff --git a/arch/arm/mach-rockchip/embedded/sram_delay.h b/arch/arm/mach-rockchip/embedded/sram_delay.h
new file mode 100644
index 000000000000..dd237e6bff1d
--- /dev/null
+++ b/arch/arm/mach-rockchip/embedded/sram_delay.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MACH_ROCKCHIP_SRAM_DELAY_H
+#define __MACH_ROCKCHIP_SRAM_DELAY_H
+
+#include <asm/arch_timer.h>
+
+/*
+ * Arch timer freq is present in dts.  We could get it from there but
+ * really nobody is going to put anything but 24MHz here.  If they do then
+ * we'll have to add this to the suspend data.
+ */
+#define ARCH_TIMER_FREQ			24000000
+#define ARCH_TIMER_TICKS_PER_US		(ARCH_TIMER_FREQ / 1000000)
+
+static inline void sram_udelay(u32 us)
+{
+	u32 orig;
+	u32 to_wait = ARCH_TIMER_TICKS_PER_US * us;
+
+	/* Note: u32 math is way more than enough for our small delays */
+	orig = (u32) arch_counter_get_cntpct();
+	while ((u32) arch_counter_get_cntpct() - orig <= to_wait)
+		;
+}
+
+#endif /* MACH_ROCKCHIP_SRAM_DELAY_H */
diff --git a/arch/arm/mach-rockchip/pm.c b/arch/arm/mach-rockchip/pm.c
index 87389d9456b9..6652d057bc03 100644
--- a/arch/arm/mach-rockchip/pm.c
+++ b/arch/arm/mach-rockchip/pm.c
@@ -13,12 +13,14 @@
 #include <linux/suspend.h>
 #include <linux/mfd/syscon.h>
 #include <linux/regulator/machine.h>
+#include <linux/moduleparam.h>
 
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 #include <asm/suspend.h>
 
 #include "pm.h"
+#include "embedded/rk3288_resume.h"
 
 /* These enum are option of low power mode */
 enum {
@@ -31,6 +33,10 @@ struct rockchip_pm_data {
 	int (*init)(struct device_node *np);
 };
 
+static bool deep_sleep = true;
+module_param(deep_sleep, bool, 0644);
+MODULE_PARM_DESC(deep_sleep, "Go into deep sleep");
+
 static void __iomem *rk3288_bootram_base;
 static phys_addr_t rk3288_bootram_phy;
 
@@ -50,13 +56,28 @@ static inline u32 rk3288_l2_config(void)
 	return l2ctlr;
 }
 
-static void __init rk3288_config_bootdata(void)
+static void __init rk3288_init_pmu_sram(void)
 {
-	rkpm_bootdata_cpusp = rk3288_bootram_phy + (SZ_4K - 8);
-	rkpm_bootdata_cpu_code = __pa_symbol(cpu_resume);
+	extern char _binary_arch_arm_mach_rockchip_embedded_rk3288_resume_bin_start;
+	extern char _binary_arch_arm_mach_rockchip_embedded_rk3288_resume_bin_end;
+	u32 size = &_binary_arch_arm_mach_rockchip_embedded_rk3288_resume_bin_end -
+		   &_binary_arch_arm_mach_rockchip_embedded_rk3288_resume_bin_start;
+	struct rk3288_resume_params *params;
+
+	/* move resume code and data to PMU sram */
+	memcpy(rk3288_bootram_base,
+	       &_binary_arch_arm_mach_rockchip_embedded_rk3288_resume_bin_start,
+	       size);
+
+	/* setup the params that we know at boot time */
+	params = (struct rk3288_resume_params *)rk3288_bootram_base;
 
-	rkpm_bootdata_l2ctlr_f  = 1;
-	rkpm_bootdata_l2ctlr = rk3288_l2_config();
+	params->cpu_resume = (void *)(unsigned long)__pa_symbol(cpu_resume);
+
+	params->l2ctlr_f = 1;
+	params->l2ctlr = rk3288_l2_config();
+
+	rk3288_ddr_suspend_init(&params->ddr_save_data);
 }
 
 #define GRF_UOC0_CON0			0x320
@@ -86,6 +107,9 @@ static bool rk3288_slp_disable_osc(void)
 
 static void rk3288_slp_mode_set(int level)
 {
+	struct rk3288_resume_params *params =
+		(struct rk3288_resume_params *)rk3288_bootram_base;
+
 	u32 mode_set, mode_set1;
 	bool osc_disable = rk3288_slp_disable_osc();
 
@@ -112,7 +136,7 @@ static void rk3288_slp_mode_set(int level)
 
 	/* booting address of resuming system is from this register value */
 	regmap_write(sgrf_regmap, RK3288_SGRF_FAST_BOOT_ADDR,
-		     rk3288_bootram_phy);
+		     (u32)params->resume_loc);
 
 	mode_set = BIT(PMU_GLOBAL_INT_DISABLE) | BIT(PMU_L2FLUSH_EN) |
 		   BIT(PMU_SREF0_ENTER_EN) | BIT(PMU_SREF1_ENTER_EN) |
@@ -149,6 +173,11 @@ static void rk3288_slp_mode_set(int level)
 		/* only wait for stabilization, if we turned the osc off */
 		regmap_write(pmu_regmap, RK3288_PMU_OSC_CNT,
 					 osc_disable ? 32 * 30 : 0);
+
+		params->ddr_resume_f = true;
+
+		/* TODO: check error from ddr_suspend() and pass back */
+		rk3288_ddr_suspend(&params->ddr_save_data);
 	} else {
 		/*
 		 * arm off, logic normal
@@ -165,13 +194,15 @@ static void rk3288_slp_mode_set(int level)
 
 		/* oscillator is still running, so no need to wait */
 		regmap_write(pmu_regmap, RK3288_PMU_OSC_CNT, 0);
+
+		params->ddr_resume_f = false;
 	}
 
 	regmap_write(pmu_regmap, RK3288_PMU_PWRMODE_CON, mode_set);
 	regmap_write(pmu_regmap, RK3288_PMU_PWRMODE_CON1, mode_set1);
 }
 
-static void rk3288_slp_mode_set_resume(void)
+static void rk3288_slp_mode_set_resume(int level)
 {
 	regmap_write(sgrf_regmap, RK3288_SGRF_CPU_CON0,
 		     rk3288_sgrf_cpu_con0 | SGRF_DAPDEVICEEN_WRITE);
@@ -182,6 +213,9 @@ static void rk3288_slp_mode_set_resume(void)
 	regmap_write(sgrf_regmap, RK3288_SGRF_SOC_CON0,
 		     rk3288_sgrf_soc_con0 | SGRF_PCLK_WDT_GATE_WRITE
 		     | SGRF_FAST_BOOT_EN_WRITE);
+
+	if (level == ROCKCHIP_ARM_OFF_LOGIC_DEEP)
+		rk3288_ddr_resume();
 }
 
 static int rockchip_lpmode_enter(unsigned long arg)
@@ -197,13 +231,17 @@ static int rockchip_lpmode_enter(unsigned long arg)
 
 static int rk3288_suspend_enter(suspend_state_t state)
 {
+	int level = deep_sleep ?
+		ROCKCHIP_ARM_OFF_LOGIC_DEEP :
+		ROCKCHIP_ARM_OFF_LOGIC_NORMAL;
+
 	local_fiq_disable();
 
-	rk3288_slp_mode_set(ROCKCHIP_ARM_OFF_LOGIC_NORMAL);
+	rk3288_slp_mode_set(level);
 
 	cpu_suspend(0, rockchip_lpmode_enter);
 
-	rk3288_slp_mode_set_resume();
+	rk3288_slp_mode_set_resume(level);
 
 	local_fiq_enable();
 
@@ -271,11 +309,7 @@ static int __init rk3288_suspend_init(struct device_node *np)
 
 	of_node_put(sram_np);
 
-	rk3288_config_bootdata();
-
-	/* copy resume code and data to bootsram */
-	memcpy(rk3288_bootram_base, rockchip_slp_cpu_resume,
-	       rk3288_bootram_sz);
+	rk3288_init_pmu_sram();
 
 	return 0;
 }
diff --git a/arch/arm/mach-rockchip/pm.h b/arch/arm/mach-rockchip/pm.h
index 479500072312..1720f980309a 100644
--- a/arch/arm/mach-rockchip/pm.h
+++ b/arch/arm/mach-rockchip/pm.h
@@ -7,13 +7,10 @@
 #ifndef __MACH_ROCKCHIP_PM_H
 #define __MACH_ROCKCHIP_PM_H
 
-extern unsigned long rkpm_bootdata_cpusp;
-extern unsigned long rkpm_bootdata_cpu_code;
-extern unsigned long rkpm_bootdata_l2ctlr_f;
-extern unsigned long rkpm_bootdata_l2ctlr;
-extern unsigned long rkpm_bootdata_ddr_code;
-extern unsigned long rkpm_bootdata_ddr_data;
-extern unsigned long rk3288_bootram_sz;
+struct rk3288_ddr_save_data;
+int __init rk3288_ddr_suspend_init(struct rk3288_ddr_save_data *ddr_save);
+int rk3288_ddr_suspend(struct rk3288_ddr_save_data *ddr_save);
+void rk3288_ddr_resume(void);
 
 void rockchip_slp_cpu_resume(void);
 #ifdef CONFIG_PM_SLEEP
diff --git a/arch/arm/mach-rockchip/rk3288_ddr_suspend.c b/arch/arm/mach-rockchip/rk3288_ddr_suspend.c
new file mode 100644
index 000000000000..8456fb8bab8f
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk3288_ddr_suspend.c
@@ -0,0 +1,480 @@
+/*
+ * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Chris Zhong<zyw@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+
+#include "pm.h"
+#include "embedded/rk3288_ddr.h"
+#include "embedded/rk3288_resume.h"
+
+void __iomem *rk3288_regulator_pwm_addr;
+void __iomem *rk3288_ddr_ctrl_addr[RK3288_NUM_DDR_PORTS];
+void __iomem *rk3288_phy_addr[RK3288_NUM_DDR_PORTS];
+void __iomem *rk3288_msch_addr[RK3288_NUM_DDR_PORTS];
+
+static const char * const rk3288_ddr_clk_names[] = {
+	"pclk_ddrupctl0",
+	"pclk_publ0",
+	"pclk_ddrupctl1",
+	"pclk_publ1",
+};
+#define NUM_DDR_CLK_NAMES ARRAY_SIZE(rk3288_ddr_clk_names)
+
+static struct clk *rk3288_ddr_clks[NUM_DDR_CLK_NAMES];
+
+static const u32 rk3288_pwm_reg[] = {
+	0x4,	/* PERIOD */
+	0x8,	/* DUTY */
+	0xc,	/* CTRL */
+};
+#define NUM_PWM_REGS ARRAY_SIZE(rk3288_pwm_reg)
+
+static const u32 rk3288_ddr_phy_dll_reg[] = {
+	DDR_PUBL_DLLGCR,
+	DDR_PUBL_ACDLLCR,
+	DDR_PUBL_DX0DLLCR,
+	DDR_PUBL_DX1DLLCR,
+	DDR_PUBL_DX2DLLCR,
+	DDR_PUBL_DX3DLLCR,
+	DDR_PUBL_PIR,
+};
+#define NUM_DDR_PHY_DLL_REGS ARRAY_SIZE(rk3288_ddr_phy_dll_reg)
+
+static const u32 rk3288_ddr_ctrl_reg[] = {
+	DDR_PCTL_TOGCNT1U,
+	DDR_PCTL_TINIT,
+	DDR_PCTL_TEXSR,
+	DDR_PCTL_TINIT,
+	DDR_PCTL_TRSTH,
+	DDR_PCTL_TOGCNT100N,
+	DDR_PCTL_TREFI,
+	DDR_PCTL_TMRD,
+	DDR_PCTL_TRFC,
+	DDR_PCTL_TRP,
+	DDR_PCTL_TRTW,
+	DDR_PCTL_TAL,
+	DDR_PCTL_TCL,
+	DDR_PCTL_TCWL,
+	DDR_PCTL_TRAS,
+	DDR_PCTL_TRC,
+	DDR_PCTL_TRCD,
+	DDR_PCTL_TRRD,
+	DDR_PCTL_TRTP,
+	DDR_PCTL_TWR,
+	DDR_PCTL_TWTR,
+	DDR_PCTL_TEXSR,
+	DDR_PCTL_TXP,
+	DDR_PCTL_TXPDLL,
+	DDR_PCTL_TZQCS,
+	DDR_PCTL_TZQCSI,
+	DDR_PCTL_TDQS,
+	DDR_PCTL_TCKSRE,
+	DDR_PCTL_TCKSRX,
+	DDR_PCTL_TCKE,
+	DDR_PCTL_TMOD,
+	DDR_PCTL_TRSTL,
+	DDR_PCTL_TZQCL,
+	DDR_PCTL_TMRR,
+	DDR_PCTL_TCKESR,
+	DDR_PCTL_TDPD,
+	DDR_PCTL_SCFG,
+	DDR_PCTL_CMDTSTATEN,
+	DDR_PCTL_MCFG1,
+	DDR_PCTL_MCFG,
+	DDR_PCTL_DFITCTRLDELAY,
+	DDR_PCTL_DFIODTCFG,
+	DDR_PCTL_DFIODTCFG1,
+	DDR_PCTL_DFIODTRANKMAP,
+	DDR_PCTL_DFITPHYWRDATA,
+	DDR_PCTL_DFITPHYWRLAT,
+	DDR_PCTL_DFITRDDATAEN,
+	DDR_PCTL_DFITPHYRDLAT,
+	DDR_PCTL_DFITPHYUPDTYPE0,
+	DDR_PCTL_DFITPHYUPDTYPE1,
+	DDR_PCTL_DFITPHYUPDTYPE2,
+	DDR_PCTL_DFITPHYUPDTYPE3,
+	DDR_PCTL_DFITCTRLUPDMIN,
+	DDR_PCTL_DFITCTRLUPDMAX,
+	DDR_PCTL_DFITCTRLUPDDLY,
+	DDR_PCTL_DFIUPDCFG,
+	DDR_PCTL_DFITREFMSKI,
+	DDR_PCTL_DFITCTRLUPDI,
+	DDR_PCTL_DFISTCFG0,
+	DDR_PCTL_DFISTCFG1,
+	DDR_PCTL_DFITDRAMCLKEN,
+	DDR_PCTL_DFITDRAMCLKDIS,
+	DDR_PCTL_DFISTCFG2,
+	DDR_PCTL_DFILPCFG0,
+};
+#define NUM_DDR_CTRL_REGS ARRAY_SIZE(rk3288_ddr_ctrl_reg)
+
+static const u32 rk3288_ddr_phy_reg[] = {
+	DDR_PUBL_DTPR0,
+	DDR_PUBL_DTPR1,
+	DDR_PUBL_DTPR2,
+	DDR_PUBL_MR0,
+	DDR_PUBL_MR1,
+	DDR_PUBL_MR2,
+	DDR_PUBL_MR3,
+	DDR_PUBL_PGCR,
+	DDR_PUBL_PTR0,
+	DDR_PUBL_PTR1,
+	DDR_PUBL_PTR2,
+	DDR_PUBL_ACIOCR,
+	DDR_PUBL_DXCCR,
+	DDR_PUBL_DSGCR,
+	DDR_PUBL_DCR,
+	DDR_PUBL_ODTCR,
+	DDR_PUBL_DTAR,
+	DDR_PUBL_DX0GCR,
+	DDR_PUBL_DX1GCR,
+	DDR_PUBL_DX2GCR,
+	DDR_PUBL_DX3GCR,
+	DDR_PUBL_DX0DQTR,
+	DDR_PUBL_DX0DQSTR,
+	DDR_PUBL_DX1DQTR,
+	DDR_PUBL_DX1DQSTR,
+	DDR_PUBL_DX2DQTR,
+	DDR_PUBL_DX2DQSTR,
+	DDR_PUBL_DX3DQTR,
+	DDR_PUBL_DX3DQSTR,
+};
+#define NUM_DDR_PHY_REGS ARRAY_SIZE(rk3288_ddr_phy_reg)
+
+static const u32 rk3288_ddr_msch_reg[] = {
+	DDR_MSCH_DDRCONF,
+	DDR_MSCH_DDRTIMING,
+	DDR_MSCH_DDRMODE,
+	DDR_MSCH_READLATENCY,
+	DDR_MSCH_ACTIVATE,
+	DDR_MSCH_DEVTODEV,
+};
+#define NUM_DDR_MSCH_REGS ARRAY_SIZE(rk3288_ddr_msch_reg)
+
+static const u32 rk3288_ddr_phy_zqcr_reg[] = {
+	DDR_PUBL_ZQ0CR0,
+	DDR_PUBL_ZQ1CR0,
+};
+#define NUM_DDR_PHY_ZQCR_REGS ARRAY_SIZE(rk3288_ddr_phy_zqcr_reg)
+
+static void rk3288_ddr_reg_save(void __iomem *regbase, const u32 reg_list[],
+				int num_reg, u32 *vals)
+{
+	int i;
+
+	for (i = 0; i < num_reg; i++)
+		vals[i] = readl_relaxed(regbase + reg_list[i]);
+}
+
+static void rk3288_ddr_save_offsets(u32 *dst_offsets, const u32 *src_offsets,
+				    int num_offsets, int max_offsets)
+{
+	memcpy(dst_offsets, src_offsets, sizeof(*dst_offsets) * num_offsets);
+
+	/*
+	 * Bytes are precious in the restore code, so we don't actually store
+	 * a count.  We just put a 0xffffffff if num >= max.
+	 */
+	if (num_offsets < max_offsets)
+		dst_offsets[num_offsets] = RK3288_BOGUS_OFFSET;
+}
+
+int rk3288_ddr_suspend(struct rk3288_ddr_save_data *ddr_save)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rk3288_ddr_clk_names); i++) {
+		ret = clk_enable(rk3288_ddr_clks[i]);
+		if (ret) {
+			pr_err("%s: Couldn't enable clock %s\n", __func__,
+			       rk3288_ddr_clk_names[i]);
+			goto err;
+		}
+	}
+
+	if (rk3288_regulator_pwm_addr)
+		rk3288_ddr_reg_save(rk3288_regulator_pwm_addr, rk3288_pwm_reg,
+				NUM_PWM_REGS, ddr_save->pwm_vals);
+
+	rk3288_ddr_reg_save(rk3288_ddr_ctrl_addr[0], rk3288_ddr_ctrl_reg,
+			    NUM_DDR_CTRL_REGS, ddr_save->ctrl_vals);
+
+	/* TODO: need to support only one channel of DDR? */
+	for (i = 0; i < RK3288_NUM_DDR_PORTS; i++) {
+		rk3288_ddr_reg_save(rk3288_phy_addr[i], rk3288_ddr_phy_reg,
+				    NUM_DDR_PHY_REGS, ddr_save->phy_vals[i]);
+		rk3288_ddr_reg_save(rk3288_phy_addr[i], rk3288_ddr_phy_dll_reg,
+				    NUM_DDR_PHY_DLL_REGS,
+				    ddr_save->phy_dll_vals[i]);
+		rk3288_ddr_reg_save(rk3288_msch_addr[i], rk3288_ddr_msch_reg,
+				    NUM_DDR_MSCH_REGS, ddr_save->msch_vals[i]);
+	}
+
+	rk3288_ddr_reg_save(rk3288_phy_addr[0], rk3288_ddr_phy_zqcr_reg,
+			    NUM_DDR_PHY_ZQCR_REGS, ddr_save->phy_zqcr_vals);
+
+	return 0;
+
+err:
+	for (; i > 0; i--)
+		clk_disable(rk3288_ddr_clks[i - 1]);
+
+	return ret;
+}
+
+void rk3288_ddr_resume(void)
+{
+	int i;
+
+	for (i = NUM_DDR_CLK_NAMES; i > 0; i--)
+		clk_disable(rk3288_ddr_clks[i - 1]);
+}
+
+/**
+ * rk3288_get_regulator_pwm_np - Get the PWM regulator node, if present
+ *
+ * It's common (but not required) that an rk3288 board uses one of the
+ * PWMs on the rk3288 as a regulator.  We'll see if we're in that case.  If we
+ * are we'll return a "np" for the PWM to save.  If not, we'll return NULL.
+ * If we have an unexpected error we'll return an ERR_PTR.
+ *
+ * NOTE: this whole concept of needing to restore the voltage immediately after
+ * resume only makes sense for the PWMs built into rk3288.  Any external
+ * regulators or external PWMs ought to keep their state.
+ */
+static struct device_node * __init rk3288_get_regulator_pwm_np(
+	struct device_node *dmc_np)
+{
+	struct device_node *np;
+	struct of_phandle_args args;
+	int ret;
+
+	/* Look for the supply to the memory controller; OK if not there */
+	np = of_parse_phandle(dmc_np, "logic-supply", 0);
+	if (!np)
+		return NULL;
+
+	/* Check to see if it's a PWM regulator; OK if it's not */
+	if (!of_device_is_compatible(np, "pwm-regulator")) {
+		of_node_put(np);
+		return NULL;
+	}
+
+	/* If it's a PWM regulator, we'd better be able to get the PWM */
+	ret = of_parse_phandle_with_args(np, "pwms", "#pwm-cells", 0, &args);
+	of_node_put(np);
+	if (ret) {
+		pr_err("%s(): can't parse \"pwms\" property\n", __func__);
+		return ERR_PTR(ret);
+	}
+
+	/*
+	 * It seems highly unlikely that we'd have a PWM supplying a PWM
+	 * regulator on an rk3288 that isn't a rk3288 PWM.  In such a case
+	 * it's unlikely that the PWM will lose its state.  We'll throw up a
+	 * warning just because this is so strange, but we won't treat it as
+	 * an error.
+	 */
+	if (!of_device_is_compatible(args.np, "rockchip,rk3288-pwm")) {
+		pr_warn("%s(): unexpected PWM for regulator\n", __func__);
+		of_node_put(args.np);
+		return NULL;
+	}
+
+	return args.np;
+}
+
+int __init rk3288_ddr_suspend_init(struct rk3288_ddr_save_data *ddr_save)
+{
+	struct device_node *dmc_np = NULL;
+	struct device_node *service_bus_np = NULL;
+	struct device_node *pwm_np = NULL;
+	int ret;
+	int i;
+
+	dmc_np = of_find_compatible_node(NULL, NULL, "rockchip,rk3288-dmc");
+	if (!dmc_np) {
+		pr_err("%s: could not find dmc dt node\n", __func__);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	service_bus_np = of_find_compatible_node(NULL, NULL,
+						 "rockchip,rk3288-service-bus");
+	if (!service_bus_np) {
+		pr_err("%s: could not find service-bus node\n", __func__);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	pwm_np = rk3288_get_regulator_pwm_np(dmc_np);
+	if (IS_ERR(pwm_np)) {
+		ret = PTR_ERR(pwm_np);
+		goto err;
+	}
+
+	/* Do the offsets and saving of the PWM together */
+	if (pwm_np) {
+		struct resource res;
+
+		rk3288_regulator_pwm_addr = of_iomap(pwm_np, 0);
+		if (!rk3288_regulator_pwm_addr) {
+			pr_err("%s: could not map PWM\n", __func__);
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		ret = of_address_to_resource(pwm_np, 0, &res);
+		if (ret) {
+			pr_err("%s: could not get PWM phy addr\n", __func__);
+			goto err;
+		}
+
+		BUILD_BUG_ON(NUM_PWM_REGS > RK3288_MAX_PWM_REGS);
+		rk3288_ddr_save_offsets(ddr_save->pwm_addrs,
+					rk3288_pwm_reg,
+					NUM_PWM_REGS,
+					RK3288_MAX_PWM_REGS);
+
+		/* Adjust to store full address, since there are many PWMs */
+		for (i = 0; i < NUM_PWM_REGS; i++)
+			ddr_save->pwm_addrs[i] += res.start;
+	}
+
+	/* Copy offsets in */
+	BUILD_BUG_ON(NUM_DDR_PHY_DLL_REGS > RK3288_MAX_DDR_PHY_DLL_REGS);
+	rk3288_ddr_save_offsets(ddr_save->phy_dll_offsets,
+				rk3288_ddr_phy_dll_reg,
+				NUM_DDR_PHY_DLL_REGS,
+				RK3288_MAX_DDR_PHY_DLL_REGS);
+
+	BUILD_BUG_ON(NUM_DDR_CTRL_REGS > RK3288_MAX_DDR_CTRL_REGS);
+	rk3288_ddr_save_offsets(ddr_save->ctrl_offsets,
+				rk3288_ddr_ctrl_reg,
+				NUM_DDR_CTRL_REGS,
+				RK3288_MAX_DDR_CTRL_REGS);
+
+	BUILD_BUG_ON(NUM_DDR_PHY_REGS > RK3288_MAX_DDR_PHY_REGS);
+	rk3288_ddr_save_offsets(ddr_save->phy_offsets,
+				rk3288_ddr_phy_reg,
+				NUM_DDR_PHY_REGS,
+				RK3288_MAX_DDR_PHY_REGS);
+
+	BUILD_BUG_ON(ARRAY_SIZE(rk3288_ddr_msch_reg) >
+		     RK3288_MAX_DDR_MSCH_REGS);
+	rk3288_ddr_save_offsets(ddr_save->msch_offsets,
+				rk3288_ddr_msch_reg,
+				NUM_DDR_MSCH_REGS,
+				RK3288_MAX_DDR_MSCH_REGS);
+
+	BUILD_BUG_ON(NUM_DDR_PHY_ZQCR_REGS > RK3288_MAX_DDR_PHY_ZQCR_REGS);
+	rk3288_ddr_save_offsets(ddr_save->phy_zqcr_offsets,
+				rk3288_ddr_phy_zqcr_reg,
+				NUM_DDR_PHY_ZQCR_REGS,
+				RK3288_MAX_DDR_PHY_ZQCR_REGS);
+
+	for (i = 0; i < RK3288_NUM_DDR_PORTS; i++) {
+		rk3288_ddr_ctrl_addr[i] = of_iomap(dmc_np, i * 2);
+		if (!rk3288_ddr_ctrl_addr[i]) {
+			pr_err("%s: could not map ddr ctrl\n", __func__);
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		rk3288_phy_addr[i] = of_iomap(dmc_np, i * 2 + 1);
+		if (!rk3288_phy_addr[i]) {
+			pr_err("%s: could not map phy\n", __func__);
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	for (i = 0; i < NUM_DDR_CLK_NAMES; i++) {
+		rk3288_ddr_clks[i] =
+			of_clk_get_by_name(dmc_np, rk3288_ddr_clk_names[i]);
+
+		if (IS_ERR(rk3288_ddr_clks[i])) {
+			pr_err("%s: couldn't get clock %s\n", __func__,
+			       rk3288_ddr_clk_names[i]);
+			ret = PTR_ERR(rk3288_ddr_clks[i]);
+			goto err;
+		}
+
+		ret = clk_prepare(rk3288_ddr_clks[i]);
+		if (ret) {
+			pr_err("%s: couldn't prepare clock %s\n", __func__,
+			       rk3288_ddr_clk_names[i]);
+			clk_put(rk3288_ddr_clks[i]);
+			rk3288_ddr_clks[i] = NULL;
+			goto err;
+		}
+	}
+
+	rk3288_msch_addr[0] = of_iomap(service_bus_np, 0);
+	if (!rk3288_msch_addr[0]) {
+		pr_err("%s: could not map msch base\n", __func__);
+		ret = -ENOMEM;
+		goto err;
+	}
+	rk3288_msch_addr[1] = rk3288_msch_addr[0] + 0x80;
+
+	ret = 0;
+	goto exit_of;
+
+err:
+	if (rk3288_msch_addr[0]) {
+		iounmap(rk3288_msch_addr[0]);
+		rk3288_msch_addr[0] = NULL;
+	}
+
+	for (i = 0; i < NUM_DDR_CLK_NAMES; i++)
+		if (!IS_ERR_OR_NULL(rk3288_ddr_clks[i])) {
+			clk_unprepare(rk3288_ddr_clks[i]);
+			clk_put(rk3288_ddr_clks[i]);
+			rk3288_ddr_clks[i] = NULL;
+		}
+
+	for (i = 0; i < RK3288_NUM_DDR_PORTS; i++) {
+		if (rk3288_phy_addr[i]) {
+			iounmap(rk3288_phy_addr[i]);
+			rk3288_phy_addr[i] = NULL;
+		}
+		if (rk3288_ddr_ctrl_addr[i]) {
+			iounmap(rk3288_ddr_ctrl_addr[i]);
+			rk3288_ddr_ctrl_addr[i] = NULL;
+		}
+	}
+
+	if (rk3288_regulator_pwm_addr) {
+		iounmap(rk3288_regulator_pwm_addr);
+		rk3288_regulator_pwm_addr = NULL;
+	}
+
+exit_of:
+	if (pwm_np)
+		of_node_put(pwm_np);
+	if (service_bus_np)
+		of_node_put(service_bus_np);
+	if (dmc_np)
+		of_node_put(dmc_np);
+
+	return ret;
+}
diff --git a/arch/arm/mach-rockchip/sleep.S b/arch/arm/mach-rockchip/sleep.S
deleted file mode 100644
index 3eca3922c944..000000000000
--- a/arch/arm/mach-rockchip/sleep.S
+++ /dev/null
@@ -1,64 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright (c) 2014, Fuzhou Rockchip Electronics Co., Ltd
- * Author: Tony Xie <tony.xie@rock-chips.com>
- */
-
-#include <linux/linkage.h>
-#include <asm/assembler.h>
-#include <asm/memory.h>
-
-.data
-/*
- * this code will be copied from
- * ddr to sram for system resumeing.
- * so it is ".data section".
- */
-	.align	2
-
-ENTRY(rockchip_slp_cpu_resume)
-	setmode	PSR_I_BIT | PSR_F_BIT | SVC_MODE, r1  @ set svc, irqs off
-	mrc	p15, 0, r1, c0, c0, 5
-	and	r1, r1, #0xf
-	cmp	r1, #0
-	/* olny cpu0 can continue to run, the others is halt here */
-	beq	cpu0run
-secondary_loop:
-	wfe
-	b	secondary_loop
-cpu0run:
-	ldr	r3, rkpm_bootdata_l2ctlr_f
-	cmp	r3, #0
-	beq	sp_set
-	ldr	r3, rkpm_bootdata_l2ctlr
-	mcr	p15, 1, r3, c9, c0, 2
-sp_set:
-	ldr	sp, rkpm_bootdata_cpusp
-	ldr	r1, rkpm_bootdata_cpu_code
-	bx	r1
-ENDPROC(rockchip_slp_cpu_resume)
-
-/* Parameters filled in by the kernel */
-
-/* Flag for whether to restore L2CTLR on resume */
-	.global rkpm_bootdata_l2ctlr_f
-rkpm_bootdata_l2ctlr_f:
-	.long 0
-
-/* Saved L2CTLR to restore on resume */
-	.global rkpm_bootdata_l2ctlr
-rkpm_bootdata_l2ctlr:
-	.long 0
-
-/* CPU resume SP addr */
-	.globl rkpm_bootdata_cpusp
-rkpm_bootdata_cpusp:
-	.long 0
-
-/* CPU resume function (physical address) */
-	.globl rkpm_bootdata_cpu_code
-rkpm_bootdata_cpu_code:
-	.long 0
-
-ENTRY(rk3288_bootram_sz)
-        .word   . - rockchip_slp_cpu_resume
diff --git a/include/soc/rockchip/rk3288-dmc-sram.h b/include/soc/rockchip/rk3288-dmc-sram.h
new file mode 100644
index 000000000000..72d36dc789bc
--- /dev/null
+++ b/include/soc/rockchip/rk3288-dmc-sram.h
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#ifndef __RK3288_DMC_SRAM_H
+#define __RK3288_DMC_SRAM_H
+
+#include <linux/clk-provider.h>
+
+enum dram_type_tag {
+	LPDDR = 0,
+	DDR,
+	DDR2,
+	DDR3,
+	LPDDR2,
+	LPDDR3,
+
+	DRAM_MAX
+};
+
+#define NUM_MC_CHANNEL_MAX 2
+
+struct ctl_timing_tag {
+	u32 ddr_freq;
+	/* Memory Timing Registers */
+	u32 togcnt1u;		/* Toggle Counter 1U Register */
+	u32 tinit;		/* t_init Timing Register */
+	u32 trsth;		/* Reset High Time Register */
+	u32 togcnt100n;		/* Toggle Counter 100N Register */
+	u32 trefi;		/* t_refi Timing Register */
+	u32 tmrd;		/* t_mrd Timing Register */
+	u32 trfc;		/* t_rfc Timing Register */
+	u32 trp;		/* t_rp Timing Register */
+	u32 trtw;		/* t_rtw Timing Register */
+	u32 tal;		/* AL Latency Register */
+	u32 tcl;		/* CL Timing Register */
+	u32 tcwl;		/* CWL Register */
+	u32 tras;		/* t_ras Timing Register */
+	u32 trc;		/* t_rc Timing Register */
+	u32 trcd;		/* t_rcd Timing Register */
+	u32 trrd;		/* t_rrd Timing Register */
+	u32 trtp;		/* t_rtp Timing Register */
+	u32 twr;		/* t_wr Timing Register */
+	u32 twtr;		/* t_wtr Timing Register */
+	u32 texsr;		/* t_exsr Timing Register */
+	u32 txp;		/* t_xp Timing Register */
+	u32 txpdll;		/* t_xpdll Timing Register */
+	u32 tzqcs;		/* t_zqcs Timing Register */
+	u32 tzqcsi;		/* t_zqcsi Timing Register */
+	u32 tdqs;		/* t_dqs Timing Register */
+	u32 tcksre;		/* t_cksre Timing Register */
+	u32 tcksrx;		/* t_cksrx Timing Register */
+	u32 tcke;		/* t_cke Timing Register */
+	u32 tmod;		/* t_mod Timing Register */
+	u32 trstl;		/* Reset Low Timing Register */
+	u32 tzqcl;		/* t_zqcl Timing Register */
+	u32 tmrr;		/* t_mrr Timing Register */
+	u32 tckesr;		/* t_ckesr Timing Register */
+	u32 tdpd;		/* t_dpd Timing Register */
+};
+
+union dtpr_0_tag {
+	u32 d32;
+	struct {
+		unsigned tmrd:2;
+		unsigned trtp:3;
+		unsigned twtr:3;
+		unsigned trp:4;
+		unsigned trcd:4;
+		unsigned tras:5;
+		unsigned trrd:4;
+		unsigned trc:6;
+		unsigned tccd:1;
+	} b;
+};
+
+union dtpr_1_tag {
+	u32 d32;
+	struct {
+		unsigned taond:2;
+		unsigned trtw:1;
+		unsigned tfaw:6;
+		unsigned tmod:2;
+		unsigned trtodt:1;
+		unsigned reserved12_15:4;
+		unsigned trfc:8;
+		unsigned tdqsck:3;
+		unsigned tdqsck_max:3;
+		unsigned reserved30_31:2;
+	} b;
+};
+
+union dtpr_2_tag {
+	u32 d32;
+	struct {
+		unsigned txs:10;
+		unsigned txp:5;
+		unsigned tcke:4;
+		unsigned tdllk:10;
+		unsigned reserved29_31:3;
+	} b;
+};
+
+struct phy_timing_tag {
+	union dtpr_0_tag dtpr0;
+	union dtpr_1_tag dtpr1;
+	union dtpr_2_tag dtpr2;
+	u32 mr[4];		/* LPDDR2 no MR0, mr[2] is mDDR MR1 */
+	u32 mr11;		/* for LPDDR3 only */
+};
+
+union noc_timing_tag {
+	u32 d32;
+	struct {
+		unsigned act_to_act:6;
+		unsigned rd_to_miss:6;
+		unsigned wr_to_miss:6;
+		unsigned burst_len:3;
+		unsigned rd_to_wr:5;
+		unsigned wr_to_rd:5;
+		unsigned bw_ratio:1;
+	} b;
+};
+
+union noc_activate_tag {
+	u32 d32;
+	struct {
+		unsigned rrd:4;		/* bit[0:3] */
+		unsigned faw:6;		/* bit[4:9] */
+		unsigned faw_bank:1;	/* bit 10 */
+		unsigned reserved:21;
+	} b;
+};
+
+struct dmc_regtiming {
+	struct ctl_timing_tag ctl_timing;
+	struct phy_timing_tag phy_timing;
+	union noc_timing_tag noc_timing;
+	union noc_activate_tag noc_activate;
+};
+
+struct dmc_oftiming {
+	u32 normal_freq;
+	u32 suspend_freq;
+	u32 odt_disable_freq;
+	u32 dll_disable_freq;
+	u32 sr_enable_freq;
+	u32 pd_enable_freq;
+	u32 sr_cnt;
+	u32 pd_cnt;
+	u32 ddr_speed_bin;
+	u32 trcd;
+	u32 trp;
+};
+
+struct rk3288_dmcclk {
+	struct device *dev;
+	struct clk_hw hw;
+	struct clk *pclk_ddrupctl0;
+	struct clk *pclk_publ0;
+	struct clk *pclk_ddrupctl1;
+	struct clk *pclk_publ1;
+
+	u32 cur_freq;
+	u32 target_freq;
+	u32 freq_slew;
+	u32 dqstr_value;
+	u32 clkod;
+	u32 clkr;
+	u32 clkf;
+	int training_retries;
+
+	u32 channel_num;
+	u32 stride;
+	u32 ranks[NUM_MC_CHANNEL_MAX];
+	u32 rank_step[NUM_MC_CHANNEL_MAX];
+
+	void __iomem *ddr_regs[NUM_MC_CHANNEL_MAX];
+	void __iomem *phy_regs[NUM_MC_CHANNEL_MAX];
+	void __iomem *ddr_regs_phys[NUM_MC_CHANNEL_MAX];
+	void __iomem *phy_regs_phys[NUM_MC_CHANNEL_MAX];
+
+	void __iomem *cru;
+	/*
+	 * We access at these without locking. The reason this works is that we
+	 * either own the registers or access them with all interrupts disabled
+	 * (across all cpus). The registers we don't own are put back in their
+	 * original state before interrupts are enabled.
+	 */
+	void __iomem *grf;
+	void __iomem *pmu;
+	void __iomem *sgrf;
+	void __iomem *noc;
+	void __iomem *cru_phys;
+	void __iomem *grf_phys;
+	void __iomem *pmu_phys;
+	void __iomem *noc_phys;
+
+	struct rockchip_dmc_sram_params *sram_params;
+	void *sram;
+	void *sram_stack;
+	void *sram_phys;
+	void *sram_stack_phys;
+	size_t sram_len;
+
+	u32 ddr_type;
+	/* Only record the max capability per die. */
+	u32 ddr_capability_per_die;
+
+	struct dmc_oftiming oftimings;
+	struct dmc_regtiming *regtiming;
+
+	struct ctl_timing_tag *p_ctl_timing;
+	struct phy_timing_tag *p_phy_timing;
+	union noc_timing_tag *p_noc_timing;
+	union noc_activate_tag *p_noc_activate;
+};
+
+struct rockchip_dmc_sram_params {
+	/* Filled in by the sram code */
+	void (*pause_cpu_in_sram)(void *arg);
+	void (*set_major_cpu)(unsigned int cpu);
+	u32 (*get_major_cpu)(void);
+	void (*set_major_cpu_paused)(unsigned int cpu, bool pause);
+	bool (*is_cpux_paused)(unsigned int cpu);
+	void (*dmc_pre_set_rate)(struct rk3288_dmcclk *dmc);
+	void (*dmc_post_set_rate)(struct rk3288_dmcclk *dmc);
+	void (*dmc_set_rate_in_sram)(void *arg);
+	struct dmc_regtiming *(*dmc_get_regtiming_addr)(void);
+};
+#endif
-- 
2.23.0.187.g17f5b7556c-goog


From 59aabbbb040c11f368e7e53ee40894e80806bf09 Mon Sep 17 00:00:00 2001
From: Guenter Roeck <groeck@chromium.org>
Date: Tue, 16 Jul 2019 11:13:04 -0700
Subject: [PATCH] CHROMIUM: Revert android-verity

android-verity is not used in ant Chrome OS configurations, and has been
removed from android-4.19. Remove it from chromeos-4.19 as well to reduce
deviation from the upstream stable kernel.

This patch is a squashed commit of:

Revert "ANDROID: verity: really fix android-verity Kconfig"
Revert "ANDROID: android-verity: Fix broken parameter handling."
Revert "ANDROID: android-verity: Make it work with newer kernels"
Revert "ANDROID: verity: fix android-verity Kconfig dependencies"
Revert "ANDROID: Add kconfig to make dm-verity check_at_most_once default enabled"
Revert "ANDROID: dm: android-verity: mark dev as rw for linear target"
Revert "ANDROID: dm: android-verity: allow disable dm-verity for Treble VTS"
Revert "ANDROID: dm: android-verity: fix table_make_digest() error handling"
Revert "ANDROID: dm: android-verity: rebase for 4.9"
Revert "ANDROID: dm: android-verity: Remove fec_header location constraint"
Revert "ANDROID: dm: android-verity: adopt changes made to dm callbacks"
Revert "ANDROID: dm: android-verity: pack the fec_header structure"
Revert "ANDROID: dm: android-verity: Verify header before fetching table"
Revert "ANDROID: dm: android-verity: allow adb disable-verity only in userdebug"
Revert "ANDROID: dm: android-verity: mount as linear target if eng build"
Revert "ANDROID: dm: android-verity: use default verity public key"
Revert "ANDROID: dm: android-verity: fix signature verification flag"
Revert "ANDROID: dm: android-verity: use name_to_dev_t"
Revert "ANDROID: dm: android-verity: Mounting root as linear device when verity disabled"
Revert "ANDROID: dm: android-verity: Add android verity target"

BUG=chromium:983660
TEST=platform.DMVerity

Change-Id: Ie7842ab9d45bc22a07cab9b2c946ec4165840543
Signed-off-by: Guenter Roeck <groeck@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/c/chromiumos/third_party/kernel/+/1704776
Reviewed-by: Evan Green <evgreen@chromium.org>
---
 drivers/md/Kconfig             |  38 --
 drivers/md/Makefile            |   4 -
 drivers/md/dm-android-verity.c | 927 ---------------------------------
 drivers/md/dm-android-verity.h | 134 -----
 drivers/md/dm-linear.c         |  49 +-
 drivers/md/dm-verity-target.c  |  22 +-
 drivers/md/dm-verity.h         |  10 +-
 7 files changed, 31 insertions(+), 1153 deletions(-)
 delete mode 100644 drivers/md/dm-android-verity.c
 delete mode 100644 drivers/md/dm-android-verity.h

diff --git a/drivers/md/Kconfig b/drivers/md/Kconfig
index 683883c68f3b..12df06e65cc2 100644
--- a/drivers/md/Kconfig
+++ b/drivers/md/Kconfig
@@ -596,42 +596,4 @@ config DM_VERITY_AVB
 	  specified on the kernel command-line when non-transient error
 	  occurs (followed by a panic).
 
-config DM_ANDROID_VERITY
-	bool "Android verity target support"
-	depends on BLK_DEV_DM=y
-	depends on DM_VERITY=y
-	depends on X509_CERTIFICATE_PARSER
-	depends on SYSTEM_TRUSTED_KEYRING
-	depends on CRYPTO_RSA
-	depends on KEYS
-	depends on ASYMMETRIC_KEY_TYPE
-	depends on ASYMMETRIC_PUBLIC_KEY_SUBTYPE
-	select DM_VERITY_HASH_PREFETCH_MIN_SIZE_128
-	---help---
-	  This device-mapper target is virtually a VERITY target. This
-	  target is setup by reading the metadata contents piggybacked
-	  to the actual data blocks in the block device. The signature
-	  of the metadata contents are verified against the key included
-	  in the system keyring. Upon success, the underlying verity
-	  target is setup.
-
-config DM_ANDROID_VERITY_AT_MOST_ONCE_DEFAULT_ENABLED
-	bool "Verity will validate blocks at most once"
-	depends on DM_VERITY
-	---help---
-	  Default enables at_most_once option for dm-verity
-
-	  Verify data blocks only the first time they are read from the
-	  data device, rather than every time.  This reduces the overhead
-	  of dm-verity so that it can be used on systems that are memory
-	  and/or CPU constrained.  However, it provides a reduced level
-	  of security because only offline tampering of the data device's
-	  content will be detected, not online tampering.
-
-	  Hash blocks are still verified each time they are read from the
-	  hash device, since verification of hash blocks is less performance
-	  critical than data blocks, and a hash block will not be verified
-	  any more after all the data blocks it covers have been verified anyway.
-
-	  If unsure, say N.
 endif # MD
diff --git a/drivers/md/Makefile b/drivers/md/Makefile
index 624538373663..53886b217dc8 100644
--- a/drivers/md/Makefile
+++ b/drivers/md/Makefile
@@ -81,7 +81,3 @@ endif
 ifeq ($(CONFIG_DM_VERITY_AVB),y)
 dm-verity-objs			+= dm-verity-avb.o
 endif
-
-ifeq ($(CONFIG_DM_ANDROID_VERITY),y)
-dm-verity-objs			+= dm-android-verity.o
-endif
diff --git a/drivers/md/dm-android-verity.c b/drivers/md/dm-android-verity.c
deleted file mode 100644
index e004e2c55a3a..000000000000
--- a/drivers/md/dm-android-verity.c
+++ /dev/null
@@ -1,927 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/buffer_head.h>
-#include <linux/debugfs.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/device-mapper.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/fcntl.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/key.h>
-#include <linux/module.h>
-#include <linux/mount.h>
-#include <linux/namei.h>
-#include <linux/of.h>
-#include <linux/reboot.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-
-#include <asm/setup.h>
-#include <crypto/hash.h>
-#include <crypto/hash_info.h>
-#include <crypto/public_key.h>
-#include <crypto/sha.h>
-#include <keys/asymmetric-type.h>
-#include <keys/system_keyring.h>
-
-#include "dm-verity.h"
-#include "dm-android-verity.h"
-
-static char verifiedbootstate[VERITY_COMMANDLINE_PARAM_LENGTH];
-static char veritymode[VERITY_COMMANDLINE_PARAM_LENGTH];
-static char veritykeyid[VERITY_DEFAULT_KEY_ID_LENGTH];
-static char buildvariant[BUILD_VARIANT];
-
-static bool target_added;
-static bool verity_enabled = true;
-struct dentry *debug_dir;
-static int android_verity_ctr(struct dm_target *ti, unsigned argc, char **argv);
-
-static struct target_type android_verity_target = {
-	.name                   = "android-verity",
-	.version                = {1, 0, 0},
-	.module                 = THIS_MODULE,
-	.ctr                    = android_verity_ctr,
-	.dtr                    = verity_dtr,
-	.map                    = verity_map,
-	.status                 = verity_status,
-	.prepare_ioctl          = verity_prepare_ioctl,
-	.iterate_devices        = verity_iterate_devices,
-	.io_hints               = verity_io_hints,
-};
-
-static int __init verified_boot_state_param(char *line)
-{
-	strlcpy(verifiedbootstate, line, sizeof(verifiedbootstate));
-	return 1;
-}
-
-__setup("androidboot.verifiedbootstate=", verified_boot_state_param);
-
-static int __init verity_mode_param(char *line)
-{
-	strlcpy(veritymode, line, sizeof(veritymode));
-	return 1;
-}
-
-__setup("androidboot.veritymode=", verity_mode_param);
-
-static int __init verity_keyid_param(char *line)
-{
-	strlcpy(veritykeyid, line, sizeof(veritykeyid));
-	return 1;
-}
-
-__setup("veritykeyid=", verity_keyid_param);
-
-static int __init verity_buildvariant(char *line)
-{
-	strlcpy(buildvariant, line, sizeof(buildvariant));
-	return 1;
-}
-
-__setup("buildvariant=", verity_buildvariant);
-
-static inline bool default_verity_key_id(void)
-{
-	return veritykeyid[0] != '\0';
-}
-
-static inline bool is_eng(void)
-{
-	static const char typeeng[]  = "eng";
-
-	return !strncmp(buildvariant, typeeng, sizeof(typeeng));
-}
-
-static inline bool is_userdebug(void)
-{
-	static const char typeuserdebug[]  = "userdebug";
-
-	return !strncmp(buildvariant, typeuserdebug, sizeof(typeuserdebug));
-}
-
-static inline bool is_unlocked(void)
-{
-	static const char unlocked[] = "orange";
-
-	return !strncmp(verifiedbootstate, unlocked, sizeof(unlocked));
-}
-
-static int read_block_dev(struct bio_read *payload, struct block_device *bdev,
-		sector_t offset, int length)
-{
-	struct bio *bio;
-	int err = 0, i;
-
-	payload->number_of_pages = DIV_ROUND_UP(length, PAGE_SIZE);
-
-	bio = bio_alloc(GFP_KERNEL, payload->number_of_pages);
-	if (!bio) {
-		DMERR("Error while allocating bio");
-		return -ENOMEM;
-	}
-
-	bio_set_dev(bio, bdev);
-	bio->bi_iter.bi_sector = offset;
-	bio_set_op_attrs(bio, REQ_OP_READ, 0);
-
-	payload->page_io = kzalloc(sizeof(struct page *) *
-		payload->number_of_pages, GFP_KERNEL);
-	if (!payload->page_io) {
-		DMERR("page_io array alloc failed");
-		err = -ENOMEM;
-		goto free_bio;
-	}
-
-	for (i = 0; i < payload->number_of_pages; i++) {
-		payload->page_io[i] = alloc_page(GFP_KERNEL);
-		if (!payload->page_io[i]) {
-			DMERR("alloc_page failed");
-			err = -ENOMEM;
-			goto free_pages;
-		}
-		if (!bio_add_page(bio, payload->page_io[i], PAGE_SIZE, 0)) {
-			DMERR("bio_add_page error");
-			err = -EIO;
-			goto free_pages;
-		}
-	}
-
-	if (!submit_bio_wait(bio))
-		/* success */
-		goto free_bio;
-	DMERR("bio read failed");
-	err = -EIO;
-
-free_pages:
-	for (i = 0; i < payload->number_of_pages; i++)
-		if (payload->page_io[i])
-			__free_page(payload->page_io[i]);
-	kfree(payload->page_io);
-free_bio:
-	bio_put(bio);
-	return err;
-}
-
-static inline u64 fec_div_round_up(u64 x, u64 y)
-{
-	u64 remainder;
-
-	return div64_u64_rem(x, y, &remainder) +
-		(remainder > 0 ? 1 : 0);
-}
-
-static inline void populate_fec_metadata(struct fec_header *header,
-				struct fec_ecc_metadata *ecc)
-{
-	ecc->blocks = fec_div_round_up(le64_to_cpu(header->inp_size),
-			FEC_BLOCK_SIZE);
-	ecc->roots = le32_to_cpu(header->roots);
-	ecc->start = le64_to_cpu(header->inp_size);
-}
-
-static inline int validate_fec_header(struct fec_header *header, u64 offset)
-{
-	/* move offset to make the sanity check work for backup header
-	 * as well. */
-	offset -= offset % FEC_BLOCK_SIZE;
-	if (le32_to_cpu(header->magic) != FEC_MAGIC ||
-		le32_to_cpu(header->version) != FEC_VERSION ||
-		le32_to_cpu(header->size) != sizeof(struct fec_header) ||
-		le32_to_cpu(header->roots) == 0 ||
-		le32_to_cpu(header->roots) >= FEC_RSM)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int extract_fec_header(dev_t dev, struct fec_header *fec,
-				struct fec_ecc_metadata *ecc)
-{
-	u64 device_size;
-	struct bio_read payload;
-	int i, err = 0;
-	struct block_device *bdev;
-
-	bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);
-
-	if (IS_ERR_OR_NULL(bdev)) {
-		DMERR("bdev get error");
-		return PTR_ERR(bdev);
-	}
-
-	device_size = i_size_read(bdev->bd_inode);
-
-	/* fec metadata size is a power of 2 and PAGE_SIZE
-	 * is a power of 2 as well.
-	 */
-	BUG_ON(FEC_BLOCK_SIZE > PAGE_SIZE);
-	/* 512 byte sector alignment */
-	BUG_ON(((device_size - FEC_BLOCK_SIZE) % (1 << SECTOR_SHIFT)) != 0);
-
-	err = read_block_dev(&payload, bdev, (device_size -
-		FEC_BLOCK_SIZE) / (1 << SECTOR_SHIFT), FEC_BLOCK_SIZE);
-	if (err) {
-		DMERR("Error while reading verity metadata");
-		goto error;
-	}
-
-	BUG_ON(sizeof(struct fec_header) > PAGE_SIZE);
-	memcpy(fec, page_address(payload.page_io[0]),
-			sizeof(*fec));
-
-	ecc->valid = true;
-	if (validate_fec_header(fec, device_size - FEC_BLOCK_SIZE)) {
-		/* Try the backup header */
-		memcpy(fec, page_address(payload.page_io[0]) + FEC_BLOCK_SIZE
-			- sizeof(*fec) ,
-			sizeof(*fec));
-		if (validate_fec_header(fec, device_size -
-			sizeof(struct fec_header)))
-			ecc->valid = false;
-	}
-
-	if (ecc->valid)
-		populate_fec_metadata(fec, ecc);
-
-	for (i = 0; i < payload.number_of_pages; i++)
-		__free_page(payload.page_io[i]);
-	kfree(payload.page_io);
-
-error:
-	blkdev_put(bdev, FMODE_READ);
-	return err;
-}
-static void find_metadata_offset(struct fec_header *fec,
-		struct block_device *bdev, u64 *metadata_offset)
-{
-	u64 device_size;
-
-	device_size = i_size_read(bdev->bd_inode);
-
-	if (le32_to_cpu(fec->magic) == FEC_MAGIC)
-		*metadata_offset = le64_to_cpu(fec->inp_size) -
-					VERITY_METADATA_SIZE;
-	else
-		*metadata_offset = device_size - VERITY_METADATA_SIZE;
-}
-
-static int find_size(dev_t dev, u64 *device_size)
-{
-	struct block_device *bdev;
-
-	bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);
-	if (IS_ERR_OR_NULL(bdev)) {
-		DMERR("blkdev_get_by_dev failed");
-		return PTR_ERR(bdev);
-	}
-
-	*device_size = i_size_read(bdev->bd_inode);
-	*device_size >>= SECTOR_SHIFT;
-
-	DMINFO("blkdev size in sectors: %llu", *device_size);
-	blkdev_put(bdev, FMODE_READ);
-	return 0;
-}
-
-static int verify_header(struct android_metadata_header *header)
-{
-	int retval = -EINVAL;
-
-	if (is_userdebug() && le32_to_cpu(header->magic_number) ==
-			VERITY_METADATA_MAGIC_DISABLE)
-		return VERITY_STATE_DISABLE;
-
-	if (!(le32_to_cpu(header->magic_number) ==
-			VERITY_METADATA_MAGIC_NUMBER) ||
-			(le32_to_cpu(header->magic_number) ==
-			VERITY_METADATA_MAGIC_DISABLE)) {
-		DMERR("Incorrect magic number");
-		return retval;
-	}
-
-	if (le32_to_cpu(header->protocol_version) !=
-			VERITY_METADATA_VERSION) {
-		DMERR("Unsupported version %u",
-			le32_to_cpu(header->protocol_version));
-		return retval;
-	}
-
-	return 0;
-}
-
-static int extract_metadata(dev_t dev, struct fec_header *fec,
-				struct android_metadata **metadata,
-				bool *verity_enabled)
-{
-	struct block_device *bdev;
-	struct android_metadata_header *header;
-	int i;
-	u32 table_length, copy_length, offset;
-	u64 metadata_offset;
-	struct bio_read payload;
-	int err = 0;
-
-	bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);
-
-	if (IS_ERR_OR_NULL(bdev)) {
-		DMERR("blkdev_get_by_dev failed");
-		return -ENODEV;
-	}
-
-	find_metadata_offset(fec, bdev, &metadata_offset);
-
-	/* Verity metadata size is a power of 2 and PAGE_SIZE
-	 * is a power of 2 as well.
-	 * PAGE_SIZE is also a multiple of 512 bytes.
-	*/
-	if (VERITY_METADATA_SIZE > PAGE_SIZE)
-		BUG_ON(VERITY_METADATA_SIZE % PAGE_SIZE != 0);
-	/* 512 byte sector alignment */
-	BUG_ON(metadata_offset % (1 << SECTOR_SHIFT) != 0);
-
-	err = read_block_dev(&payload, bdev, metadata_offset /
-		(1 << SECTOR_SHIFT), VERITY_METADATA_SIZE);
-	if (err) {
-		DMERR("Error while reading verity metadata");
-		goto blkdev_release;
-	}
-
-	header = kzalloc(sizeof(*header), GFP_KERNEL);
-	if (!header) {
-		DMERR("kzalloc failed for header");
-		err = -ENOMEM;
-		goto free_payload;
-	}
-
-	memcpy(header, page_address(payload.page_io[0]),
-		sizeof(*header));
-
-	DMINFO("bio magic_number:%u protocol_version:%d table_length:%u",
-		le32_to_cpu(header->magic_number),
-		le32_to_cpu(header->protocol_version),
-		le32_to_cpu(header->table_length));
-
-	err = verify_header(header);
-
-	if (err == VERITY_STATE_DISABLE) {
-		DMERR("Mounting root with verity disabled");
-		*verity_enabled = false;
-		/* we would still have to read the metadata to figure out
-		 * the data blocks size. Or may be could map the entire
-		 * partition similar to mounting the device.
-		 *
-		 * Reset error as well as the verity_enabled flag is changed.
-		 */
-		err = 0;
-	} else if (err)
-		goto free_header;
-
-	*metadata = kzalloc(sizeof(**metadata), GFP_KERNEL);
-	if (!*metadata) {
-		DMERR("kzalloc for metadata failed");
-		err = -ENOMEM;
-		goto free_header;
-	}
-
-	(*metadata)->header = header;
-	table_length = le32_to_cpu(header->table_length);
-
-	if (table_length == 0 ||
-		table_length > (VERITY_METADATA_SIZE -
-			sizeof(struct android_metadata_header))) {
-		DMERR("table_length too long");
-		err = -EINVAL;
-		goto free_metadata;
-	}
-
-	(*metadata)->verity_table = kzalloc(table_length + 1, GFP_KERNEL);
-
-	if (!(*metadata)->verity_table) {
-		DMERR("kzalloc verity_table failed");
-		err = -ENOMEM;
-		goto free_metadata;
-	}
-
-	if (sizeof(struct android_metadata_header) +
-			table_length <= PAGE_SIZE) {
-		memcpy((*metadata)->verity_table,
-			page_address(payload.page_io[0])
-			+ sizeof(struct android_metadata_header),
-			table_length);
-	} else {
-		copy_length = PAGE_SIZE -
-			sizeof(struct android_metadata_header);
-		memcpy((*metadata)->verity_table,
-			page_address(payload.page_io[0])
-			+ sizeof(struct android_metadata_header),
-			copy_length);
-		table_length -= copy_length;
-		offset = copy_length;
-		i = 1;
-		while (table_length != 0) {
-			if (table_length > PAGE_SIZE) {
-				memcpy((*metadata)->verity_table + offset,
-					page_address(payload.page_io[i]),
-					PAGE_SIZE);
-				offset += PAGE_SIZE;
-				table_length -= PAGE_SIZE;
-			} else {
-				memcpy((*metadata)->verity_table + offset,
-					page_address(payload.page_io[i]),
-					table_length);
-				table_length = 0;
-			}
-			i++;
-		}
-	}
-	(*metadata)->verity_table[table_length] = '\0';
-
-	DMINFO("verity_table: %s", (*metadata)->verity_table);
-	goto free_payload;
-
-free_metadata:
-	kfree(*metadata);
-free_header:
-	kfree(header);
-free_payload:
-	for (i = 0; i < payload.number_of_pages; i++)
-		if (payload.page_io[i])
-			__free_page(payload.page_io[i]);
-	kfree(payload.page_io);
-blkdev_release:
-	blkdev_put(bdev, FMODE_READ);
-	return err;
-}
-
-/* helper functions to extract properties from dts */
-const char *find_dt_value(const char *name)
-{
-	struct device_node *firmware;
-	const char *value;
-
-	firmware = of_find_node_by_path("/firmware/android");
-	if (!firmware)
-		return NULL;
-	value = of_get_property(firmware, name, NULL);
-	of_node_put(firmware);
-
-	return value;
-}
-
-static int verity_mode(void)
-{
-	static const char enforcing[] = "enforcing";
-	static const char verified_mode_prop[] = "veritymode";
-	const char *value;
-
-	value = find_dt_value(verified_mode_prop);
-	if (!value)
-		value = veritymode;
-	if (!strncmp(value, enforcing, sizeof(enforcing) - 1))
-		return DM_VERITY_MODE_RESTART;
-
-	return DM_VERITY_MODE_EIO;
-}
-
-static void handle_error(void)
-{
-	int mode = verity_mode();
-	if (mode == DM_VERITY_MODE_RESTART) {
-		DMERR("triggering restart");
-		kernel_restart("dm-verity device corrupted");
-	} else {
-		DMERR("Mounting verity root failed");
-	}
-}
-
-static struct public_key_signature *table_make_digest(
-						enum hash_algo hash,
-						const void *table,
-						unsigned long table_len)
-{
-	struct public_key_signature *pks = NULL;
-	struct crypto_shash *tfm;
-	struct shash_desc *desc;
-	size_t digest_size, desc_size;
-	int ret;
-
-	/* Allocate the hashing algorithm we're going to need and find out how
-	 * big the hash operational data will be.
-	 */
-	tfm = crypto_alloc_shash(hash_algo_name[hash], 0, 0);
-	if (IS_ERR(tfm))
-		return ERR_CAST(tfm);
-
-	desc_size = crypto_shash_descsize(tfm) + sizeof(*desc);
-	digest_size = crypto_shash_digestsize(tfm);
-
-	/* We allocate the hash operational data storage on the end of out
-	 * context data and the digest output buffer on the end of that.
-	 */
-	ret = -ENOMEM;
-	pks = kzalloc(digest_size + sizeof(*pks) + desc_size, GFP_KERNEL);
-	if (!pks)
-		goto error;
-
-	pks->pkey_algo = "rsa";
-	pks->hash_algo = hash_algo_name[hash];
-	pks->digest = (u8 *)pks + sizeof(*pks) + desc_size;
-	pks->digest_size = digest_size;
-
-	desc = (struct shash_desc *)(pks + 1);
-	desc->tfm = tfm;
-	desc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;
-
-	ret = crypto_shash_init(desc);
-	if (ret < 0)
-		goto error;
-
-	ret = crypto_shash_finup(desc, table, table_len, pks->digest);
-	if (ret < 0)
-		goto error;
-
-	crypto_free_shash(tfm);
-	return pks;
-
-error:
-	kfree(pks);
-	crypto_free_shash(tfm);
-	return ERR_PTR(ret);
-}
-
-
-static int verify_verity_signature(char *key_id,
-		struct android_metadata *metadata)
-{
-	struct public_key_signature *pks = NULL;
-	int retval = -EINVAL;
-
-	if (!key_id)
-		goto error;
-
-	pks = table_make_digest(HASH_ALGO_SHA256,
-			(const void *)metadata->verity_table,
-			le32_to_cpu(metadata->header->table_length));
-	if (IS_ERR(pks)) {
-		DMERR("hashing failed");
-		retval = PTR_ERR(pks);
-		pks = NULL;
-		goto error;
-	}
-
-	pks->s = kmemdup(&metadata->header->signature[0], RSANUMBYTES, GFP_KERNEL);
-	if (!pks->s) {
-		DMERR("Error allocating memory for signature");
-		goto error;
-	}
-	pks->s_size = RSANUMBYTES;
-
-	retval = verify_signature_one(pks, NULL, key_id);
-	kfree(pks->s);
-error:
-	kfree(pks);
-	return retval;
-}
-
-static inline bool test_mult_overflow(sector_t a, u32 b)
-{
-	sector_t r = (sector_t)~0ULL;
-
-	sector_div(r, b);
-	return a > r;
-}
-
-static int add_as_linear_device(struct dm_target *ti, char *dev)
-{
-	/*Move to linear mapping defines*/
-	char *linear_table_args[DM_LINEAR_ARGS] = {dev,
-					DM_LINEAR_TARGET_OFFSET};
-	int err = 0;
-
-	android_verity_target.dtr = dm_linear_dtr,
-	android_verity_target.map = dm_linear_map,
-	android_verity_target.status = dm_linear_status,
-#ifdef CONFIG_BLK_DEV_ZONED
-	android_verity_target.end_io = dm_linear_end_io,
-#endif
-	android_verity_target.prepare_ioctl = dm_linear_prepare_ioctl,
-	android_verity_target.iterate_devices = dm_linear_iterate_devices,
-        android_verity_target.direct_access = dm_linear_dax_direct_access,
-        android_verity_target.dax_copy_from_iter = dm_linear_dax_copy_from_iter,
-	android_verity_target.io_hints = NULL;
-
-	set_disk_ro(dm_disk(dm_table_get_md(ti->table)), 0);
-
-	err = dm_linear_ctr(ti, DM_LINEAR_ARGS, linear_table_args);
-
-	if (!err) {
-		DMINFO("Added android-verity as a linear target");
-		target_added = true;
-	} else
-		DMERR("Failed to add android-verity as linear target");
-
-	return err;
-}
-
-static int create_linear_device(struct dm_target *ti, dev_t dev,
-				char *target_device)
-{
-	u64 device_size = 0;
-	int err = find_size(dev, &device_size);
-
-	if (err) {
-		DMERR("error finding bdev size");
-		handle_error();
-		return err;
-	}
-
-	ti->len = device_size;
-	err = add_as_linear_device(ti, target_device);
-	if (err) {
-		handle_error();
-		return err;
-	}
-	verity_enabled = false;
-	return 0;
-}
-
-/*
- * Target parameters:
- *	<key id>	Key id of the public key in the system keyring.
- *			Verity metadata's signature would be verified against
- *			this. If the key id contains spaces, replace them
- *			with '#'.
- *	<block device>	The block device for which dm-verity is being setup.
- */
-static int android_verity_ctr(struct dm_target *ti, unsigned argc, char **argv)
-{
-	dev_t uninitialized_var(dev);
-	struct android_metadata *metadata = NULL;
-	int err = 0, i, mode;
-	char *key_id = NULL, *table_ptr, dummy, *target_device;
-	char *verity_table_args[VERITY_TABLE_ARGS + 2 + VERITY_TABLE_OPT_FEC_ARGS];
-	/* One for specifying number of opt args and one for mode */
-	sector_t data_sectors;
-	u32 data_block_size;
-	unsigned int no_of_args = VERITY_TABLE_ARGS + 2 + VERITY_TABLE_OPT_FEC_ARGS;
-	struct fec_header uninitialized_var(fec);
-	struct fec_ecc_metadata uninitialized_var(ecc);
-	char buf[FEC_ARG_LENGTH], *buf_ptr;
-	unsigned long long tmpll;
-
-	if (argc == 1) {
-		/* Use the default keyid */
-		if (default_verity_key_id())
-			key_id = veritykeyid;
-		else if (!is_eng()) {
-			DMERR("veritykeyid= is not set");
-			handle_error();
-			return -EINVAL;
-		}
-		target_device = argv[0];
-	} else if (argc == 2) {
-		key_id = argv[0];
-		target_device = argv[1];
-	} else {
-		DMERR("Incorrect number of arguments");
-		handle_error();
-		return -EINVAL;
-	}
-
-	dev = name_to_dev_t(target_device);
-	if (!dev) {
-		DMERR("no dev found for %s", target_device);
-		handle_error();
-		return -EINVAL;
-	}
-
-	if (is_eng())
-		return create_linear_device(ti, dev, target_device);
-
-	strreplace(key_id, '#', ' ');
-
-	DMINFO("key:%s dev:%s", key_id, target_device);
-
-	if (extract_fec_header(dev, &fec, &ecc)) {
-		DMERR("Error while extracting fec header");
-		handle_error();
-		return -EINVAL;
-	}
-
-	err = extract_metadata(dev, &fec, &metadata, &verity_enabled);
-
-	if (err) {
-		/* Allow invalid metadata when the device is unlocked */
-		if (is_unlocked()) {
-			DMWARN("Allow invalid metadata when unlocked");
-			return create_linear_device(ti, dev, target_device);
-		}
-		DMERR("Error while extracting metadata");
-		handle_error();
-		goto free_metadata;
-	}
-
-	if (verity_enabled) {
-		err = verify_verity_signature(key_id, metadata);
-
-		if (err) {
-			DMERR("Signature verification failed");
-			handle_error();
-			goto free_metadata;
-		} else
-			DMINFO("Signature verification success");
-	}
-
-	table_ptr = metadata->verity_table;
-
-	for (i = 0; i < VERITY_TABLE_ARGS; i++) {
-		verity_table_args[i] = strsep(&table_ptr, " ");
-		if (verity_table_args[i] == NULL)
-			break;
-	}
-
-	if (i != VERITY_TABLE_ARGS) {
-		DMERR("Verity table not in the expected format");
-		err = -EINVAL;
-		handle_error();
-		goto free_metadata;
-	}
-
-	if (sscanf(verity_table_args[5], "%llu%c", &tmpll, &dummy)
-							!= 1) {
-		DMERR("Verity table not in the expected format");
-		handle_error();
-		err = -EINVAL;
-		goto free_metadata;
-	}
-
-	if (tmpll > ULONG_MAX) {
-		DMERR("<num_data_blocks> too large. Forgot to turn on CONFIG_LBDAF?");
-		handle_error();
-		err = -EINVAL;
-		goto free_metadata;
-	}
-
-	data_sectors = tmpll;
-
-	if (sscanf(verity_table_args[3], "%u%c", &data_block_size, &dummy)
-								!= 1) {
-		DMERR("Verity table not in the expected format");
-		handle_error();
-		err = -EINVAL;
-		goto free_metadata;
-	}
-
-	if (test_mult_overflow(data_sectors, data_block_size >>
-							SECTOR_SHIFT)) {
-		DMERR("data_sectors too large");
-		handle_error();
-		err = -EOVERFLOW;
-		goto free_metadata;
-	}
-
-	data_sectors *= data_block_size >> SECTOR_SHIFT;
-	DMINFO("Data sectors %llu", (unsigned long long)data_sectors);
-
-	/* update target length */
-	ti->len = data_sectors;
-
-	/* Setup linear target and free */
-	if (!verity_enabled) {
-		err = add_as_linear_device(ti, target_device);
-		goto free_metadata;
-	}
-
-	/*substitute data_dev and hash_dev*/
-	verity_table_args[1] = target_device;
-	verity_table_args[2] = target_device;
-
-	mode = verity_mode();
-
-	if (ecc.valid && IS_BUILTIN(CONFIG_DM_VERITY_FEC)) {
-		if (mode) {
-			err = snprintf(buf, FEC_ARG_LENGTH,
-				"%u %s " VERITY_TABLE_OPT_FEC_FORMAT,
-				1 + VERITY_TABLE_OPT_FEC_ARGS,
-				mode == DM_VERITY_MODE_RESTART ?
-					VERITY_TABLE_OPT_RESTART :
-					VERITY_TABLE_OPT_LOGGING,
-				target_device,
-				ecc.start / FEC_BLOCK_SIZE, ecc.blocks,
-				ecc.roots);
-		} else {
-			err = snprintf(buf, FEC_ARG_LENGTH,
-				"%u " VERITY_TABLE_OPT_FEC_FORMAT,
-				VERITY_TABLE_OPT_FEC_ARGS, target_device,
-				ecc.start / FEC_BLOCK_SIZE, ecc.blocks,
-				ecc.roots);
-		}
-	} else if (mode) {
-		err = snprintf(buf, FEC_ARG_LENGTH,
-			"2 " VERITY_TABLE_OPT_IGNZERO " %s",
-			mode == DM_VERITY_MODE_RESTART ?
-			VERITY_TABLE_OPT_RESTART : VERITY_TABLE_OPT_LOGGING);
-	} else {
-		err = snprintf(buf, FEC_ARG_LENGTH, "1 %s",
-				 "ignore_zero_blocks");
-	}
-
-	if (err < 0 || err >= FEC_ARG_LENGTH)
-		goto free_metadata;
-
-	buf_ptr = buf;
-
-	for (i = VERITY_TABLE_ARGS; i < (VERITY_TABLE_ARGS +
-		VERITY_TABLE_OPT_FEC_ARGS + 2); i++) {
-		verity_table_args[i] = strsep(&buf_ptr, " ");
-		if (verity_table_args[i] == NULL) {
-			no_of_args = i;
-			break;
-		}
-	}
-
-	err = verity_ctr(ti, no_of_args, verity_table_args);
-	if (err) {
-		DMERR("android-verity failed to create a verity target");
-	} else {
-		target_added = true;
-		DMINFO("android-verity created as verity target");
-	}
-
-free_metadata:
-	if (metadata) {
-		kfree(metadata->header);
-		kfree(metadata->verity_table);
-	}
-	kfree(metadata);
-	return err;
-}
-
-static int __init dm_android_verity_init(void)
-{
-	int r;
-	struct dentry *file;
-
-	r = dm_register_target(&android_verity_target);
-	if (r < 0)
-		DMERR("register failed %d", r);
-
-	/* Tracks the status of the last added target */
-	debug_dir = debugfs_create_dir("android_verity", NULL);
-
-	if (IS_ERR_OR_NULL(debug_dir)) {
-		DMERR("Cannot create android_verity debugfs directory: %ld",
-			PTR_ERR(debug_dir));
-		goto end;
-	}
-
-	file = debugfs_create_bool("target_added", S_IRUGO, debug_dir,
-				&target_added);
-
-	if (IS_ERR_OR_NULL(file)) {
-		DMERR("Cannot create android_verity debugfs directory: %ld",
-			PTR_ERR(debug_dir));
-		debugfs_remove_recursive(debug_dir);
-		goto end;
-	}
-
-	file = debugfs_create_bool("verity_enabled", S_IRUGO, debug_dir,
-				&verity_enabled);
-
-	if (IS_ERR_OR_NULL(file)) {
-		DMERR("Cannot create android_verity debugfs directory: %ld",
-			PTR_ERR(debug_dir));
-		debugfs_remove_recursive(debug_dir);
-	}
-
-end:
-	return r;
-}
-
-static void __exit dm_android_verity_exit(void)
-{
-	if (!IS_ERR_OR_NULL(debug_dir))
-		debugfs_remove_recursive(debug_dir);
-
-	dm_unregister_target(&android_verity_target);
-}
-
-module_init(dm_android_verity_init);
-module_exit(dm_android_verity_exit);
diff --git a/drivers/md/dm-android-verity.h b/drivers/md/dm-android-verity.h
deleted file mode 100644
index a1c8f4b5d8c2..000000000000
--- a/drivers/md/dm-android-verity.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef DM_ANDROID_VERITY_H
-#define DM_ANDROID_VERITY_H
-
-#include <crypto/sha.h>
-
-#define RSANUMBYTES 256
-#define VERITY_METADATA_MAGIC_NUMBER 0xb001b001
-#define VERITY_METADATA_MAGIC_DISABLE 0x46464f56
-#define VERITY_METADATA_VERSION 0
-#define VERITY_STATE_DISABLE 1
-#define DATA_BLOCK_SIZE (4 * 1024)
-#define VERITY_METADATA_SIZE (8 * DATA_BLOCK_SIZE)
-#define VERITY_TABLE_ARGS 10
-#define VERITY_COMMANDLINE_PARAM_LENGTH 20
-#define BUILD_VARIANT 20
-
-/*
- * <subject>:<sha1-id> is the format for the identifier.
- * subject can either be the Common Name(CN) + Organization Name(O) or
- * just the CN if the it is prefixed with O
- * From https://tools.ietf.org/html/rfc5280#appendix-A
- * ub-organization-name-length INTEGER ::= 64
- * ub-common-name-length INTEGER ::= 64
- *
- * http://lxr.free-electrons.com/source/crypto/asymmetric_keys/x509_cert_parser.c?v=3.9#L278
- * ctx->o_size + 2 + ctx->cn_size + 1
- * + 41 characters for ":" and sha1 id
- * 64 + 2 + 64 + 1 + 1 + 40 (172)
- * setting VERITY_DEFAULT_KEY_ID_LENGTH to 200 characters.
- */
-#define VERITY_DEFAULT_KEY_ID_LENGTH 200
-
-#define FEC_MAGIC 0xFECFECFE
-#define FEC_BLOCK_SIZE (4 * 1024)
-#define FEC_VERSION 0
-#define FEC_RSM 255
-#define FEC_ARG_LENGTH 300
-
-#define VERITY_TABLE_OPT_RESTART "restart_on_corruption"
-#define VERITY_TABLE_OPT_LOGGING "ignore_corruption"
-#define VERITY_TABLE_OPT_IGNZERO "ignore_zero_blocks"
-
-#define VERITY_TABLE_OPT_FEC_FORMAT \
-	"use_fec_from_device %s fec_start %llu fec_blocks %llu fec_roots %u ignore_zero_blocks"
-#define VERITY_TABLE_OPT_FEC_ARGS 9
-
-#define VERITY_DEBUG 0
-
-#define DM_MSG_PREFIX                   "android-verity"
-
-#define DM_LINEAR_ARGS 2
-#define DM_LINEAR_TARGET_OFFSET "0"
-
-/*
- * There can be two formats.
- * if fec is present
- * <data_blocks> <verity_tree> <verity_metdata_32K><fec_data><fec_data_4K>
- * if fec is not present
- * <data_blocks> <verity_tree> <verity_metdata_32K>
- */
-struct fec_header {
-	__le32 magic;
-	__le32 version;
-	__le32 size;
-	__le32 roots;
-	__le32 fec_size;
-	__le64 inp_size;
-	u8 hash[SHA256_DIGEST_SIZE];
-} __attribute__((packed));
-
-struct android_metadata_header {
-	__le32 magic_number;
-	__le32 protocol_version;
-	char signature[RSANUMBYTES];
-	__le32 table_length;
-};
-
-struct android_metadata {
-	struct android_metadata_header *header;
-	char *verity_table;
-};
-
-struct fec_ecc_metadata {
-	bool valid;
-	u32 roots;
-	u64 blocks;
-	u64 rounds;
-	u64 start;
-};
-
-struct bio_read {
-	struct page **page_io;
-	int number_of_pages;
-};
-
-extern struct target_type linear_target;
-
-extern void dm_linear_dtr(struct dm_target *ti);
-extern int dm_linear_map(struct dm_target *ti, struct bio *bio);
-#ifdef CONFIG_BLK_DEV_ZONED
-extern int dm_linear_end_io(struct dm_target *ti, struct bio *bio,
-			 blk_status_t *error);
-#endif
-extern void dm_linear_status(struct dm_target *ti, status_type_t type,
-			unsigned status_flags, char *result, unsigned maxlen);
-extern int dm_linear_prepare_ioctl(struct dm_target *ti, struct block_device **bdev);
-extern int dm_linear_iterate_devices(struct dm_target *ti,
-			iterate_devices_callout_fn fn, void *data);
-extern int dm_linear_ctr(struct dm_target *ti, unsigned int argc, char **argv);
-#if IS_ENABLED(CONFIG_DAX_DRIVER)
-extern long dm_linear_dax_direct_access(struct dm_target *ti, pgoff_t pgoff,
-				       long nr_pages, void **kaddr,
-				       pfn_t *pfn);
-extern size_t dm_linear_dax_copy_from_iter(struct dm_target *ti, pgoff_t pgoff,
-		void *addr, size_t bytes, struct iov_iter *i);
-#else
-#define dm_linear_dax_direct_access NULL
-#define dm_linear_dax_copy_from_iter NULL
-#endif
-#endif /* DM_ANDROID_VERITY_H */
diff --git a/drivers/md/dm-linear.c b/drivers/md/dm-linear.c
index f0b088af801a..caa08c4b84cd 100644
--- a/drivers/md/dm-linear.c
+++ b/drivers/md/dm-linear.c
@@ -26,7 +26,7 @@ struct linear_c {
 /*
  * Construct a linear mapping: <dev_path> <offset>
  */
-int dm_linear_ctr(struct dm_target *ti, unsigned int argc, char **argv)
+static int linear_ctr(struct dm_target *ti, unsigned int argc, char **argv)
 {
 	struct linear_c *lc;
 	unsigned long long tmp;
@@ -70,7 +70,7 @@ int dm_linear_ctr(struct dm_target *ti, unsigned int argc, char **argv)
 	return ret;
 }
 
-void dm_linear_dtr(struct dm_target *ti)
+static void linear_dtr(struct dm_target *ti)
 {
 	struct linear_c *lc = (struct linear_c *) ti->private;
 
@@ -95,7 +95,7 @@ static void linear_map_bio(struct dm_target *ti, struct bio *bio)
 			linear_map_sector(ti, bio->bi_iter.bi_sector);
 }
 
-int dm_linear_map(struct dm_target *ti, struct bio *bio)
+static int linear_map(struct dm_target *ti, struct bio *bio)
 {
 	linear_map_bio(ti, bio);
 
@@ -103,7 +103,7 @@ int dm_linear_map(struct dm_target *ti, struct bio *bio)
 }
 
 #ifdef CONFIG_BLK_DEV_ZONED
-int dm_linear_end_io(struct dm_target *ti, struct bio *bio,
+static int linear_end_io(struct dm_target *ti, struct bio *bio,
 			 blk_status_t *error)
 {
 	struct linear_c *lc = ti->private;
@@ -113,10 +113,9 @@ int dm_linear_end_io(struct dm_target *ti, struct bio *bio,
 
 	return DM_ENDIO_DONE;
 }
-EXPORT_SYMBOL_GPL(dm_linear_end_io);
 #endif
 
-void dm_linear_status(struct dm_target *ti, status_type_t type,
+static void linear_status(struct dm_target *ti, status_type_t type,
 			  unsigned status_flags, char *result, unsigned maxlen)
 {
 	struct linear_c *lc = (struct linear_c *) ti->private;
@@ -133,7 +132,7 @@ void dm_linear_status(struct dm_target *ti, status_type_t type,
 	}
 }
 
-int dm_linear_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
+static int linear_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 {
 	struct linear_c *lc = (struct linear_c *) ti->private;
 	struct dm_dev *dev = lc->dev;
@@ -149,7 +148,7 @@ int dm_linear_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 	return 0;
 }
 
-int dm_linear_iterate_devices(struct dm_target *ti,
+static int linear_iterate_devices(struct dm_target *ti,
 				  iterate_devices_callout_fn fn, void *data)
 {
 	struct linear_c *lc = ti->private;
@@ -158,7 +157,7 @@ int dm_linear_iterate_devices(struct dm_target *ti,
 }
 
 #if IS_ENABLED(CONFIG_DAX_DRIVER)
-long dm_linear_dax_direct_access(struct dm_target *ti, pgoff_t pgoff,
+static long linear_dax_direct_access(struct dm_target *ti, pgoff_t pgoff,
 		long nr_pages, void **kaddr, pfn_t *pfn)
 {
 	long ret;
@@ -173,9 +172,8 @@ long dm_linear_dax_direct_access(struct dm_target *ti, pgoff_t pgoff,
 		return ret;
 	return dax_direct_access(dax_dev, pgoff, nr_pages, kaddr, pfn);
 }
-EXPORT_SYMBOL_GPL(dm_linear_dax_direct_access);
 
-size_t dm_linear_dax_copy_from_iter(struct dm_target *ti, pgoff_t pgoff,
+static size_t linear_dax_copy_from_iter(struct dm_target *ti, pgoff_t pgoff,
 		void *addr, size_t bytes, struct iov_iter *i)
 {
 	struct linear_c *lc = ti->private;
@@ -188,9 +186,8 @@ size_t dm_linear_dax_copy_from_iter(struct dm_target *ti, pgoff_t pgoff,
 		return 0;
 	return dax_copy_from_iter(dax_dev, pgoff, addr, bytes, i);
 }
-EXPORT_SYMBOL_GPL(dm_linear_dax_copy_from_iter);
 
-static size_t dm_linear_dax_copy_to_iter(struct dm_target *ti, pgoff_t pgoff,
+static size_t linear_dax_copy_to_iter(struct dm_target *ti, pgoff_t pgoff,
 		void *addr, size_t bytes, struct iov_iter *i)
 {
 	struct linear_c *lc = ti->private;
@@ -205,30 +202,30 @@ static size_t dm_linear_dax_copy_to_iter(struct dm_target *ti, pgoff_t pgoff,
 }
 
 #else
-#define dm_linear_dax_direct_access NULL
-#define dm_linear_dax_copy_from_iter NULL
-#define dm_linear_dax_copy_to_iter NULL
+#define linear_dax_direct_access NULL
+#define linear_dax_copy_from_iter NULL
+#define linear_dax_copy_to_iter NULL
 #endif
 
 static struct target_type linear_target = {
 	.name   = "linear",
 	.version = {1, 4, 0},
 #ifdef CONFIG_BLK_DEV_ZONED
-	.end_io = dm_linear_end_io,
+	.end_io = linear_end_io,
 	.features = DM_TARGET_PASSES_INTEGRITY | DM_TARGET_ZONED_HM,
 #else
 	.features = DM_TARGET_PASSES_INTEGRITY,
 #endif
 	.module = THIS_MODULE,
-	.ctr    = dm_linear_ctr,
-	.dtr    = dm_linear_dtr,
-	.map    = dm_linear_map,
-	.status = dm_linear_status,
-	.prepare_ioctl = dm_linear_prepare_ioctl,
-	.iterate_devices = dm_linear_iterate_devices,
-	.direct_access = dm_linear_dax_direct_access,
-	.dax_copy_from_iter = dm_linear_dax_copy_from_iter,
-	.dax_copy_to_iter = dm_linear_dax_copy_to_iter,
+	.ctr    = linear_ctr,
+	.dtr    = linear_dtr,
+	.map    = linear_map,
+	.status = linear_status,
+	.prepare_ioctl = linear_prepare_ioctl,
+	.iterate_devices = linear_iterate_devices,
+	.direct_access = linear_dax_direct_access,
+	.dax_copy_from_iter = linear_dax_copy_from_iter,
+	.dax_copy_to_iter = linear_dax_copy_to_iter,
 };
 
 int __init dm_linear_init(void)
diff --git a/drivers/md/dm-verity-target.c b/drivers/md/dm-verity-target.c
index 16169548d879..f563e043b161 100644
--- a/drivers/md/dm-verity-target.c
+++ b/drivers/md/dm-verity-target.c
@@ -759,7 +759,7 @@ static void verity_submit_prefetch(struct dm_verity *v, struct dm_verity_io *io)
  * Bio map function. It allocates dm_verity_io structure and bio vector and
  * fills them. Then it issues prefetches and the I/O.
  */
-int verity_map(struct dm_target *ti, struct bio *bio)
+static int verity_map(struct dm_target *ti, struct bio *bio)
 {
 	struct dm_verity *v = ti->private;
 	struct dm_verity_io *io;
@@ -804,7 +804,7 @@ int verity_map(struct dm_target *ti, struct bio *bio)
 /*
  * Status: V (valid) or C (corruption found)
  */
-void verity_status(struct dm_target *ti, status_type_t type,
+static void verity_status(struct dm_target *ti, status_type_t type,
 			  unsigned status_flags, char *result, unsigned maxlen)
 {
 	struct dm_verity *v = ti->private;
@@ -868,7 +868,7 @@ void verity_status(struct dm_target *ti, status_type_t type,
 	}
 }
 
-int verity_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
+static int verity_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 {
 	struct dm_verity *v = ti->private;
 
@@ -880,7 +880,7 @@ int verity_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 	return 0;
 }
 
-int verity_iterate_devices(struct dm_target *ti,
+static int verity_iterate_devices(struct dm_target *ti,
 				  iterate_devices_callout_fn fn, void *data)
 {
 	struct dm_verity *v = ti->private;
@@ -888,7 +888,7 @@ int verity_iterate_devices(struct dm_target *ti,
 	return fn(ti, v->data_dev, v->data_start, ti->len, data);
 }
 
-void verity_io_hints(struct dm_target *ti, struct queue_limits *limits)
+static void verity_io_hints(struct dm_target *ti, struct queue_limits *limits)
 {
 	struct dm_verity *v = ti->private;
 
@@ -901,7 +901,7 @@ void verity_io_hints(struct dm_target *ti, struct queue_limits *limits)
 	blk_limits_io_min(limits, limits->logical_block_size);
 }
 
-void verity_dtr(struct dm_target *ti)
+static void verity_dtr(struct dm_target *ti)
 {
 	struct dm_verity *v = ti->private;
 
@@ -1239,7 +1239,7 @@ static char *chromeos_args(unsigned argc, char **argv, struct verity_args *args)
  *	<digest>
  *	<salt>		Hex string or "-" if no salt.
  */
-int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)
+static int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)
 {
 	struct verity_args args = { 0 };
 	struct dm_verity *v;
@@ -1370,14 +1370,6 @@ int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)
 			goto bad;
 	}
 
-#ifdef CONFIG_DM_ANDROID_VERITY_AT_MOST_ONCE_DEFAULT_ENABLED
-	if (!v->validated_blocks) {
-		r = verity_alloc_most_once(v);
-		if (r)
-			goto bad;
-	}
-#endif
-
 	v->hash_per_block_bits =
 		__fls((1 << v->hash_dev_block_bits) / v->digest_size);
 
diff --git a/drivers/md/dm-verity.h b/drivers/md/dm-verity.h
index b04e7eac5615..97e8dba8dcd7 100644
--- a/drivers/md/dm-verity.h
+++ b/drivers/md/dm-verity.h
@@ -163,14 +163,6 @@ extern int verity_hash(struct dm_verity *v, struct ahash_request *req,
 extern int verity_hash_for_block(struct dm_verity *v, struct dm_verity_io *io,
 				 sector_t block, u8 *digest, bool *is_zero);
 
-extern void verity_status(struct dm_target *ti, status_type_t type,
-			unsigned status_flags, char *result, unsigned maxlen);
-extern int verity_prepare_ioctl(struct dm_target *ti, struct block_device **bdev);
-extern int verity_iterate_devices(struct dm_target *ti,
-				iterate_devices_callout_fn fn, void *data);
-extern void verity_io_hints(struct dm_target *ti, struct queue_limits *limits);
-extern void verity_dtr(struct dm_target *ti);
-extern int verity_ctr(struct dm_target *ti, unsigned argc, char **argv);
-extern int verity_map(struct dm_target *ti, struct bio *bio);
 extern void dm_verity_avb_error_handler(void);
+
 #endif /* DM_VERITY_H */
-- 
2.23.0.187.g17f5b7556c-goog


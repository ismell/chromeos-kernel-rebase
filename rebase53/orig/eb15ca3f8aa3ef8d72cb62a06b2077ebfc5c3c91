From eb15ca3f8aa3ef8d72cb62a06b2077ebfc5c3c91 Mon Sep 17 00:00:00 2001
From: Pawel Osciak <posciak@chromium.org>
Date: Thu, 24 Jan 2019 07:51:55 -0200
Subject: [PATCH] BACKPORT: FROMGIT: media: vb2: Keep dma-buf buffers mapped
 until they are freed

When using vb2 for video decoding, dequeued capture buffers may still
be accessed by the hardware: this is the case when they are used as
reference frames for decoding subsequent frames.

When the buffer is imported with dma-buf, it needs to be mapped before
access. Until now, it was mapped when queuing and unmapped when
dequeuing, which doesn't work for access as a reference frames.

One way to solve this would be to map the buffer again when it is
needed as a reference, but the mapping/unmapping operations can
seriously impact performance. As a result, map the buffer once (when it
is first needed when queued) and keep it mapped until it is freed.

Reviewed-on: https://chromium-review.googlesource.com/334103
[Paul: Updated for mainline and changed commit message]

Signed-off-by: Pawel Osciak <posciak@chromium.org>
Signed-off-by: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
(cherry picked from commit 2cc1802f62e562611e86f04d9dae1337c824991e
 git://linuxtv.org/media_tree.git)

Commit d88937624351 ("media: videobuf2: remove unused variable")
removes the unused "i" variable left by this patch, but because of our
local change, commit 5b47324d523d ("CHROMIUM: vb2: Don't reuse USERPTR
buffers."), the variable is still needed, so I skipped it.

BUG=chromium:938781
TEST=Pre-CQ passes

Change-Id: I99723d66af8fe203124634fa010f5351218789bd
Signed-off-by: Tomasz Figa <tfiga@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/1505082
Reviewed-by: Guenter Roeck <groeck@chromium.org>
Reviewed-by: Alexandre Courbot <acourbot@chromium.org>
---
 drivers/media/common/videobuf2/videobuf2-core.c | 13 ++++---------
 1 file changed, 4 insertions(+), 9 deletions(-)

diff --git a/drivers/media/common/videobuf2/videobuf2-core.c b/drivers/media/common/videobuf2/videobuf2-core.c
index e0e6337d3d6f..bdeef23a4e65 100644
--- a/drivers/media/common/videobuf2/videobuf2-core.c
+++ b/drivers/media/common/videobuf2/videobuf2-core.c
@@ -1139,6 +1139,9 @@ static int __prepare_dmabuf(struct vb2_buffer *vb)
 	 * userspace knows sooner rather than later if the dma-buf map fails.
 	 */
 	for (plane = 0; plane < vb->num_planes; ++plane) {
+		if (vb->planes[plane].dbuf_mapped)
+			continue;
+
 		ret = call_memop(vb, map_dmabuf, vb->planes[plane].mem_priv);
 		if (ret) {
 			dprintk(1, "failed to map dmabuf for plane %d\n",
@@ -1701,15 +1704,7 @@ static void __vb2_dqbuf(struct vb2_buffer *vb)
 
 	vb->state = VB2_BUF_STATE_DEQUEUED;
 
-	/* unmap DMABUF buffer */
-	if (q->memory == VB2_MEMORY_DMABUF) {
-		for (i = 0; i < vb->num_planes; ++i) {
-			if (!vb->planes[i].dbuf_mapped)
-				continue;
-			call_void_memop(vb, unmap_dmabuf, vb->planes[i].mem_priv);
-			vb->planes[i].dbuf_mapped = 0;
-		}
-	} else if (q->memory == VB2_MEMORY_USERPTR) {
+	if (q->memory == VB2_MEMORY_USERPTR) {
 		call_void_vb_qop(vb, buf_cleanup, vb);
 
 		for (i = 0; i < vb->num_planes; ++i) {
-- 
2.23.0.187.g17f5b7556c-goog


From cee874e7210deeed6d7190486d07b53010d82986 Mon Sep 17 00:00:00 2001
From: Douglas Anderson <dianders@chromium.org>
Date: Thu, 19 Sep 2019 15:09:53 -0700
Subject: [PATCH] CHROMIUM: drm/rockchip: dw_hdmi: Support Chromebook-style
 HDCP key from userspace

This patch adds code to the Rockchip HDMI driver to support loading
the HDCP key in a way that rk3288-veyron-mickey expects.
Specifically:
- rk3288-veyron-mickey expects to load the HDCP key (minus the seed)
  from userspace through sysfs.
- The HDCP key that userspace has access to needs to be combined with
  a "seed" which is generated by hashing the CPU ID.

It is expected that nobody other than rk3288-veyron-mickey works in
exactly this way.  Specifically from looking at Rockchip's github
tree:
- It seems that nobody else generates the seed by hashing the CPU ID.
- On other Rockchip devices userspace doesn't seem to be involved.  It
  seems that in Rockchip's downstream tree they use
  "rk_vendor_storage".

It is _possible_ that we could make this more generic by forcing
userspace to provide both the key and the seed.  On
rk3288-veyron-mickey userspace could be changed to read the CPU ID
directly, hash it, and provide it to the kernel.  If this code were to
make its way upstream and folks were OK w/ this sysfs interface that
would probably be the way to go.

For now we can make this a CHROMIUM patch.

BUG=chromium:971474
TEST=Use this to generate HDCP seed

Change-Id: I0cdfedbedf73a4199d5961ecce8e51a25b217c05
Signed-off-by: Douglas Anderson <dianders@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/c/chromiumos/third_party/kernel/+/1814892
Reviewed-by: Sean Paul <seanpaul@chromium.org>
---
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c | 73 +++++++++++++++++++++
 1 file changed, 73 insertions(+)

diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index 5cca118bb5b83..c5c561149f66e 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -8,8 +8,10 @@
  */
 
 #include <linux/clk.h>
+#include <linux/crc16.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 
@@ -367,6 +369,75 @@ dw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 						   &crtc_state->adjusted_mode);
 }
 
+static ssize_t hdcp_key_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct rockchip_hdmi *hdmi = dev_get_drvdata(dev);
+	struct dw_hdmi_hdcp_key_1x *key;
+	struct nvmem_cell *cell;
+	u16 encrypt_seed;
+	u8 *cpu_id;
+	size_t len;
+	int ret;
+
+	/*
+	 * The HDCP Key format should look like this: "12345678...",
+	 * every two characters stand for a byte, so the total key size
+	 * would be (308 * 2) byte.
+	 *
+	 * Allow key size to be bigger as a simple way to allow "\r" or "\n"
+	 * after the key.
+	 */
+	if (count < (DW_HDMI_HDCP_KEY_LEN * 2))
+		return -EINVAL;
+
+	cell = nvmem_cell_get(dev, "cpu-id");
+	if (IS_ERR(cell)) {
+		DRM_DEV_ERROR(dev, "err getting CPU ID %ld\n", PTR_ERR(cell));
+		return PTR_ERR(cell);
+	}
+	cpu_id = (u8 *)nvmem_cell_read(cell, &len);
+	if (IS_ERR(cpu_id)) {
+		nvmem_cell_put(cell);
+		DRM_DEV_ERROR(dev, "err reading CPU ID %ld\n", PTR_ERR(cpu_id));
+		return PTR_ERR(cpu_id);
+	}
+	encrypt_seed = crc16(0xffff, cpu_id, len);
+	nvmem_cell_put(cell);
+
+	key = kzalloc(sizeof(*key), GFP_KERNEL);
+	if (IS_ERR(key))
+		return -ENOMEM;
+
+	/*
+	 * The format of input HDCP Key should be "12345678...".
+	 * there is no standard format for HDCP keys, so it is
+	 * just made up for this driver.
+	 *
+	 * The "ksv & device_key & sha" should parsed from input data
+	 * buffer, and the "seed" would take the crc16 of cpu uid.
+	 */
+	ret = hex2bin(key->user_provided_key, buf, DW_HDMI_HDCP_KEY_LEN);
+	if (ret) {
+		dev_err(dev, "Failed to decode the input HDCP key: %d\n", ret);
+		goto exit;
+	}
+
+	key->seed[0] = encrypt_seed & 0xFF;
+	key->seed[1] = (encrypt_seed >> 8) & 0xFF;
+
+	ret = dw_hdmi_config_hdcp_key(hdmi->hdmi, key);
+	if (ret)
+		goto exit;
+
+	ret = count;
+exit:
+	kfree(key);
+
+	return ret;
+}
+static DEVICE_ATTR_WO(hdcp_key);
+
 static const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {
 	.mode_set   = dw_hdmi_rockchip_encoder_mode_set,
 	.enable     = dw_hdmi_rockchip_encoder_enable,
@@ -460,6 +531,8 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,
 		return ret;
 	}
 
+	device_create_file(dev, &dev_attr_hdcp_key);
+
 	drm_encoder_helper_add(encoder, &dw_hdmi_rockchip_encoder_helper_funcs);
 	drm_encoder_init(drm, encoder, &dw_hdmi_rockchip_encoder_funcs,
 			 DRM_MODE_ENCODER_TMDS, NULL);
-- 
2.23.0.444.g18eeb5a265-goog


From 33901c602a1a67fded5d428819eaf226ec3a9c08 Mon Sep 17 00:00:00 2001
From: Gwendal Grignou <gwendal@chromium.org>
Date: Wed, 5 Jun 2019 16:20:20 -0700
Subject: [PATCH] CHROMIUM: mfd: cros_ec: Remove chromium specific changes in
 cros_ec_commands.h

This CL removes all changes that have not be sent upstream.

It put cros_ec_command.sh to 93abf68b6bcb git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git master]
That the last CL upstream before the sync-up.

BUG=chromium:945948
TEST=Prepare for next CLs.
CQ-DEPEND=CL:1652467

Change-Id: Iff3392018f7cf1d7f8d2911bbf159751b53dcdf5
Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/1646943
Commit-Ready: ChromeOS CL Exonerator Bot <chromiumos-cl-exonerator@appspot.gserviceaccount.com>
Legacy-Commit-Queue: Commit Bot <commit-bot@chromium.org>
Reviewed-by: Benson Leung <bleung@google.com>
---
 include/linux/mfd/cros_ec_commands.h | 3006 ++++++--------------------
 1 file changed, 687 insertions(+), 2319 deletions(-)

diff --git a/include/linux/mfd/cros_ec_commands.h b/include/linux/mfd/cros_ec_commands.h
index ff095219165a..dcec96f01879 100644
--- a/include/linux/mfd/cros_ec_commands.h
+++ b/include/linux/mfd/cros_ec_commands.h
@@ -85,7 +85,8 @@
 /* Unused 0x28 - 0x2f */
 #define EC_MEMMAP_SWITCHES         0x30	/* 8 bits */
 /* Unused 0x31 - 0x33 */
-#define EC_MEMMAP_HOST_EVENTS      0x34 /* 64 bits */
+#define EC_MEMMAP_HOST_EVENTS      0x34 /* 32 bits */
+/* Reserve 0x38 - 0x3f for additional host event-related stuff */
 /* Battery values are all 32 bits */
 #define EC_MEMMAP_BATT_VOLT        0x40 /* Battery Present Voltage */
 #define EC_MEMMAP_BATT_RATE        0x44 /* Battery Present Rate */
@@ -104,19 +105,10 @@
 /* Unused 0x84 - 0x8f */
 #define EC_MEMMAP_ACC_STATUS       0x90 /* Accelerometer status (8 bits )*/
 /* Unused 0x91 */
-#define EC_MEMMAP_ACC_DATA         0x92 /* Accelerometers data 0x92 - 0x9f */
-/* 0x92: Lid Angle if available, LID_ANGLE_UNRELIABLE otherwise */
-/* 0x94 - 0x99: 1st Accelerometer */
-/* 0x9a - 0x9f: 2nd Accelerometer */
+#define EC_MEMMAP_ACC_DATA         0x92 /* Accelerometer data 0x92 - 0x9f */
 #define EC_MEMMAP_GYRO_DATA        0xa0 /* Gyroscope data 0xa0 - 0xa5 */
-/* Unused 0xa6 - 0xdf */
+/* Unused 0xa6 - 0xfe (remember, 0xff is NOT part of the memmap region) */
 
-/*
- * ACPI is unable to access memory mapped data at or above this offset due to
- * limitations of the ACPI protocol. Do not place data in the range 0xe0 - 0xfe
- * which might be needed by ACPI.
- */
-#define EC_MEMMAP_NO_ACPI 0xe0
 
 /* Define the format of the accelerometer mapped memory status byte. */
 #define EC_MEMMAP_ACC_STATUS_SAMPLE_ID_MASK  0x0f
@@ -190,174 +182,6 @@
 #define EC_WIRELESS_SWITCH_WWAN       0x04  /* WWAN power */
 #define EC_WIRELESS_SWITCH_WLAN_POWER 0x08  /* WLAN power */
 
-/*****************************************************************************/
-/*
- * ACPI commands
- *
- * These are valid ONLY on the ACPI command/data port.
- */
-
-/*
- * ACPI Read Embedded Controller
- *
- * This reads from ACPI memory space on the EC (EC_ACPI_MEM_*).
- *
- * Use the following sequence:
- *
- *    - Write EC_CMD_ACPI_READ to EC_LPC_ADDR_ACPI_CMD
- *    - Wait for EC_LPC_CMDR_PENDING bit to clear
- *    - Write address to EC_LPC_ADDR_ACPI_DATA
- *    - Wait for EC_LPC_CMDR_DATA bit to set
- *    - Read value from EC_LPC_ADDR_ACPI_DATA
- */
-#define EC_CMD_ACPI_READ 0x0080
-
-/*
- * ACPI Write Embedded Controller
- *
- * This reads from ACPI memory space on the EC (EC_ACPI_MEM_*).
- *
- * Use the following sequence:
- *
- *    - Write EC_CMD_ACPI_WRITE to EC_LPC_ADDR_ACPI_CMD
- *    - Wait for EC_LPC_CMDR_PENDING bit to clear
- *    - Write address to EC_LPC_ADDR_ACPI_DATA
- *    - Wait for EC_LPC_CMDR_PENDING bit to clear
- *    - Write value to EC_LPC_ADDR_ACPI_DATA
- */
-#define EC_CMD_ACPI_WRITE 0x0081
-
-/*
- * ACPI Burst Enable Embedded Controller
- *
- * This enables burst mode on the EC to allow the host to issue several
- * commands back-to-back. While in this mode, writes to mapped multi-byte
- * data are locked out to ensure data consistency.
- */
-#define EC_CMD_ACPI_BURST_ENABLE 0x0082
-
-/*
- * ACPI Burst Disable Embedded Controller
- *
- * This disables burst mode on the EC and stops preventing EC writes to mapped
- * multi-byte data.
- */
-#define EC_CMD_ACPI_BURST_DISABLE 0x0083
-
-/*
- * ACPI Query Embedded Controller
- *
- * This clears the lowest-order bit in the currently pending host events, and
- * sets the result code to the 1-based index of the bit (event 0x00000001 = 1,
- * event 0x80000000 = 32), or 0 if no event was pending.
- */
-#define EC_CMD_ACPI_QUERY_EVENT 0x0084
-
-/* Valid addresses in ACPI memory space, for read/write commands */
-
-/* Memory space version; set to EC_ACPI_MEM_VERSION_CURRENT */
-#define EC_ACPI_MEM_VERSION            0x00
-/*
- * Test location; writing value here updates test compliment byte to (0xff -
- * value).
- */
-#define EC_ACPI_MEM_TEST               0x01
-/* Test compliment; writes here are ignored. */
-#define EC_ACPI_MEM_TEST_COMPLIMENT    0x02
-
-/* Keyboard backlight brightness percent (0 - 100) */
-#define EC_ACPI_MEM_KEYBOARD_BACKLIGHT 0x03
-/* DPTF Target Fan Duty (0-100, 0xff for auto/none) */
-#define EC_ACPI_MEM_FAN_DUTY           0x04
-
-/*
- * DPTF temp thresholds. Any of the EC's temp sensors can have up to two
- * independent thresholds attached to them. The current value of the ID
- * register determines which sensor is affected by the THRESHOLD and COMMIT
- * registers. The THRESHOLD register uses the same EC_TEMP_SENSOR_OFFSET scheme
- * as the memory-mapped sensors. The COMMIT register applies those settings.
- *
- * The spec does not mandate any way to read back the threshold settings
- * themselves, but when a threshold is crossed the AP needs a way to determine
- * which sensor(s) are responsible. Each reading of the ID register clears and
- * returns one sensor ID that has crossed one of its threshold (in either
- * direction) since the last read. A value of 0xFF means "no new thresholds
- * have tripped". Setting or enabling the thresholds for a sensor will clear
- * the unread event count for that sensor.
- */
-#define EC_ACPI_MEM_TEMP_ID            0x05
-#define EC_ACPI_MEM_TEMP_THRESHOLD     0x06
-#define EC_ACPI_MEM_TEMP_COMMIT        0x07
-/*
- * Here are the bits for the COMMIT register:
- *   bit 0 selects the threshold index for the chosen sensor (0/1)
- *   bit 1 enables/disables the selected threshold (0 = off, 1 = on)
- * Each write to the commit register affects one threshold.
- */
-#define EC_ACPI_MEM_TEMP_COMMIT_SELECT_MASK (1 << 0)
-#define EC_ACPI_MEM_TEMP_COMMIT_ENABLE_MASK (1 << 1)
-/*
- * Example:
- *
- * Set the thresholds for sensor 2 to 50 C and 60 C:
- *   write 2 to [0x05]      --  select temp sensor 2
- *   write 0x7b to [0x06]   --  C_TO_K(50) - EC_TEMP_SENSOR_OFFSET
- *   write 0x2 to [0x07]    --  enable threshold 0 with this value
- *   write 0x85 to [0x06]   --  C_TO_K(60) - EC_TEMP_SENSOR_OFFSET
- *   write 0x3 to [0x07]    --  enable threshold 1 with this value
- *
- * Disable the 60 C threshold, leaving the 50 C threshold unchanged:
- *   write 2 to [0x05]      --  select temp sensor 2
- *   write 0x1 to [0x07]    --  disable threshold 1
- */
-
-/* DPTF battery charging current limit */
-#define EC_ACPI_MEM_CHARGING_LIMIT     0x08
-
-/* Charging limit is specified in 64 mA steps */
-#define EC_ACPI_MEM_CHARGING_LIMIT_STEP_MA   64
-/* Value to disable DPTF battery charging limit */
-#define EC_ACPI_MEM_CHARGING_LIMIT_DISABLED  0xff
-
-/*
- * Report device orientation
- *   bit 0 device is tablet mode
- */
-#define EC_ACPI_MEM_DEVICE_ORIENTATION 0x09
-#define EC_ACPI_MEM_DEVICE_TABLET_MODE 0x01
-
-/*
- * Report device features. Uses the same format as the host command, except:
- *
- * bit 0 (EC_FEATURE_LIMITED) changes meaning from "EC code has a limited set
- * of features", which is of limited interest when the system is already
- * interpreting ACPI bytecode, to "EC_FEATURES[0-7] is not supported". Since
- * these are supported, it defaults to 0.
- * This allows detecting the presence of this field since older versions of
- * the EC codebase would simply return 0xff to that unknown address. Check
- * FEATURES0 != 0xff (or FEATURES0[0] == 0) to make sure that the other bits
- * are valid.
- */
-#define EC_ACPI_MEM_DEVICE_FEATURES0 0x0a
-#define EC_ACPI_MEM_DEVICE_FEATURES1 0x0b
-#define EC_ACPI_MEM_DEVICE_FEATURES2 0x0c
-#define EC_ACPI_MEM_DEVICE_FEATURES3 0x0d
-#define EC_ACPI_MEM_DEVICE_FEATURES4 0x0e
-#define EC_ACPI_MEM_DEVICE_FEATURES5 0x0f
-#define EC_ACPI_MEM_DEVICE_FEATURES6 0x10
-#define EC_ACPI_MEM_DEVICE_FEATURES7 0x11
-
-/*
- * ACPI addresses 0x20 - 0xff map to EC_MEMMAP offset 0x00 - 0xdf.  This data
- * is read-only from the AP.  Added in EC_ACPI_MEM_VERSION 2.
- */
-#define EC_ACPI_MEM_MAPPED_BEGIN   0x20
-#define EC_ACPI_MEM_MAPPED_SIZE    0xe0
-
-/* Current version of ACPI memory address space */
-#define EC_ACPI_MEM_VERSION_CURRENT 2
-
-
 /*
  * This header file is used in coreboot both in C and ACPI code.  The ACPI code
  * is pre-processed to handle constants but the ASL compiler is unable to
@@ -373,92 +197,6 @@
 #define __packed __attribute__((packed))
 #endif
 
-#ifndef __aligned
-#define __aligned(x) __attribute__((aligned(x)))
-#endif
-
-/*
- * Attributes for EC request and response packets.  Just defining __packed
- * results in inefficient assembly code on ARM, if the structure is actually
- * 32-bit aligned, as it should be for all buffers.
- *
- * Be very careful when adding these to existing structures.  They will round
- * up the structure size to the specified boundary.
- *
- * Also be very careful to make that if a structure is included in some other
- * parent structure that the alignment will still be true given the packing of
- * the parent structure.  This is particularly important if the sub-structure
- * will be passed as a pointer to another function, since that function will
- * not know about the misaligment caused by the parent structure's packing.
- *
- * Also be very careful using __packed - particularly when nesting non-packed
- * structures inside packed ones.  In fact, DO NOT use __packed directly;
- * always use one of these attributes.
- *
- * Once everything is annotated properly, the following search strings should
- * not return ANY matches in this file other than right here:
- *
- * "__packed" - generates inefficient code; all sub-structs must also be packed
- *
- * "struct [^_]" - all structs should be annotated, except for structs that are
- * members of other structs/unions (and their original declarations should be
- * annotated).
- */
-#ifdef CONFIG_HOSTCMD_ALIGNED
-
-/*
- * Packed structures where offset and size are always aligned to 1, 2, or 4
- * byte boundary.
- */
-#define __ec_align1 __packed
-#define __ec_align2 __packed __aligned(2)
-#define __ec_align4 __packed __aligned(4)
-
-/*
- * Packed structure which must be under-aligned, because its size is not a
- * 4-byte multiple.  This is sub-optimal because it forces byte-wise access
- * of all multi-byte fields in it, even though they are themselves aligned.
- *
- * In theory, we could duplicate the structure with __aligned(4) for accessing
- * its members, but use the __packed version for sizeof().
- */
-#define __ec_align_size1 __packed
-
-/*
- * Packed structure which must be under-aligned, because its offset inside a
- * parent structure is not a 4-byte multiple.
- */
-#define __ec_align_offset1 __packed
-#define __ec_align_offset2 __packed __aligned(2)
-
-/*
- * Structures which are complicated enough that I'm skipping them on the first
- * pass.  They are effectively unchanged from their previous definitions.
- *
- * TODO(rspangler): Figure out what to do with these.  It's likely necessary
- * to work out the size and offset of each member and add explicit padding to
- * maintain those.
- */
-#define __ec_todo_packed __packed
-#define __ec_todo_unpacked
-
-#else  /* !CONFIG_HOSTCMD_ALIGNED */
-
-/*
- * Packed structures make no assumption about alignment, so they do inefficient
- * byte-wise reads.
- */
-#define __ec_align1 __packed
-#define __ec_align2 __packed
-#define __ec_align4 __packed
-#define __ec_align_size1 __packed
-#define __ec_align_offset1 __packed
-#define __ec_align_offset2 __packed
-#define __ec_todo_packed __packed
-#define __ec_todo_unpacked
-
-#endif  /* !CONFIG_HOSTCMD_ALIGNED */
-
 /* LPC command status byte masks */
 /* EC has written a byte in the data register and host hasn't read it yet */
 #define EC_LPC_STATUS_TO_HOST     0x01
@@ -468,7 +206,7 @@
 #define EC_LPC_STATUS_PROCESSING  0x04
 /* Last write to EC was a command, not data */
 #define EC_LPC_STATUS_LAST_CMD    0x08
-/* EC is in burst mode */
+/* EC is in burst mode.  Unsupported by Chrome EC, so this bit is never set */
 #define EC_LPC_STATUS_BURST_MODE  0x10
 /* SCI event is pending (requesting SCI query) */
 #define EC_LPC_STATUS_SCI_PENDING 0x20
@@ -484,9 +222,7 @@
 #define EC_LPC_STATUS_BUSY_MASK \
 	(EC_LPC_STATUS_FROM_HOST | EC_LPC_STATUS_PROCESSING)
 
-/* Host command response codes (16-bit).  Note that response codes should be
- * stored in a uint16_t rather than directly in a value of this type.
- */
+/* Host command response codes */
 enum ec_status {
 	EC_RES_SUCCESS = 0,
 	EC_RES_INVALID_COMMAND = 1,
@@ -502,13 +238,7 @@ enum ec_status {
 	EC_RES_OVERFLOW = 11,		/* Table / data overflow */
 	EC_RES_INVALID_HEADER = 12,     /* Header contains invalid data */
 	EC_RES_REQUEST_TRUNCATED = 13,  /* Didn't get the entire request */
-	EC_RES_RESPONSE_TOO_BIG = 14,   /* Response was too big to handle */
-	EC_RES_BUS_ERROR = 15,		/* Communications bus error */
-	EC_RES_BUSY = 16,		/* Up but too busy.  Should retry */
-	EC_RES_INVALID_HEADER_VERSION = 17,  /* Header version invalid */
-	EC_RES_INVALID_HEADER_CRC = 18,      /* Header CRC invalid */
-	EC_RES_INVALID_DATA_CRC = 19,        /* Data CRC invalid */
-	EC_RES_DUP_UNAVAILABLE = 20,         /* Can't resend response */
+	EC_RES_RESPONSE_TOO_BIG = 14    /* Response was too big to handle */
 };
 
 /*
@@ -528,8 +258,7 @@ enum host_event_code {
 	EC_HOST_EVENT_BATTERY_CRITICAL = 7,
 	EC_HOST_EVENT_BATTERY = 8,
 	EC_HOST_EVENT_THERMAL_THRESHOLD = 9,
-	/* Event generated by a device attached to the EC */
-	EC_HOST_EVENT_DEVICE = 10,
+	EC_HOST_EVENT_THERMAL_OVERLOAD = 10,
 	EC_HOST_EVENT_THERMAL = 11,
 	EC_HOST_EVENT_USB_CHARGER = 12,
 	EC_HOST_EVENT_KEY_PRESSED = 13,
@@ -556,33 +285,14 @@ enum host_event_code {
 	EC_HOST_EVENT_HANG_DETECT = 20,
 	/* Hang detect logic detected a hang and warm rebooted the AP */
 	EC_HOST_EVENT_HANG_REBOOT = 21,
-
 	/* PD MCU triggering host event */
 	EC_HOST_EVENT_PD_MCU = 22,
 
-	/* Battery Status flags have changed */
-	EC_HOST_EVENT_BATTERY_STATUS = 23,
-
-	/* EC encountered a panic, triggering a reset */
-	EC_HOST_EVENT_PANIC = 24,
-
-	/* Keyboard fastboot combo has been pressed */
-	EC_HOST_EVENT_KEYBOARD_FASTBOOT = 25,
-
-	/* EC RTC event occurred */
-	EC_HOST_EVENT_RTC = 26,
-
-	/* Emulate MKBP event */
-	EC_HOST_EVENT_MKBP = 27,
-
 	/* EC desires to change state of host-controlled USB mux */
 	EC_HOST_EVENT_USB_MUX = 28,
 
-	/* TABLET/LAPTOP mode event*/
-	EC_HOST_EVENT_MODE_CHANGE = 29,
-
-	/* Keyboard recovery combo with hardware reinitialization */
-	EC_HOST_EVENT_KEYBOARD_RECOVERY_HW_REINIT = 30,
+	/* EC RTC event occurred */
+	EC_HOST_EVENT_RTC = 26,
 
 	/*
 	 * The high bit of the event mask is not used as a host event code.  If
@@ -594,7 +304,7 @@ enum host_event_code {
 	EC_HOST_EVENT_INVALID = 32
 };
 /* Host event mask */
-#define EC_HOST_EVENT_MASK(event_code) (1ULL << ((event_code) - 1))
+#define EC_HOST_EVENT_MASK(event_code) (1UL << ((event_code) - 1))
 
 /**
  * struct ec_lpc_host_args - Arguments at EC_LPC_ADDR_HOST_ARGS
@@ -604,12 +314,12 @@ enum host_event_code {
  * @checksum: Checksum; sum of command + flags + command_version + data_size +
  *            all params/response data bytes.
  */
-struct __ec_align4 ec_lpc_host_args {
+struct ec_lpc_host_args {
 	uint8_t flags;
 	uint8_t command_version;
 	uint8_t data_size;
 	uint8_t checksum;
-};
+} __packed;
 
 /* Flags for ec_lpc_host_args.flags */
 /*
@@ -619,7 +329,7 @@ struct __ec_align4 ec_lpc_host_args {
  * If EC gets a command and this flag is not set, this is an old-style command.
  * Command version is 0 and params from host are at EC_LPC_ADDR_OLD_PARAM with
  * unknown length.  EC must respond with an old-style response (that is,
- * without setting EC_HOST_ARGS_FLAG_TO_HOST).
+ * withouth setting EC_HOST_ARGS_FLAG_TO_HOST).
  */
 #define EC_HOST_ARGS_FLAG_FROM_HOST 0x01
 /*
@@ -773,14 +483,14 @@ struct __ec_align4 ec_lpc_host_args {
  * @reserved: Unused byte in current protocol version; set to 0.
  * @data_len: Length of data which follows this header.
  */
-struct __ec_align4 ec_host_request {
+struct ec_host_request {
 	uint8_t struct_version;
 	uint8_t checksum;
 	uint16_t command;
 	uint8_t command_version;
 	uint8_t reserved;
 	uint16_t data_len;
-};
+} __packed;
 
 #define EC_HOST_RESPONSE_VERSION 3
 
@@ -793,157 +503,24 @@ struct __ec_align4 ec_host_request {
  * @data_len: Length of data which follows this header.
  * @reserved: Unused bytes in current protocol version; set to 0.
  */
-struct __ec_align4 ec_host_response {
+struct ec_host_response {
 	uint8_t struct_version;
 	uint8_t checksum;
 	uint16_t result;
 	uint16_t data_len;
 	uint16_t reserved;
-};
-
-/*****************************************************************************/
-
-/*
- * Host command protocol V4.
- *
- * Packets always start with a request or response header.  They are followed
- * by data_len bytes of data.  If the data_crc_present flag is set, the data
- * bytes are followed by a CRC-8 of that data, using using x^8 + x^2 + x + 1
- * polynomial.
- *
- * Host algorithm when sending a request q:
- *
- * 101) tries_left=(some value, e.g. 3);
- * 102) q.seq_num++
- * 103) q.seq_dup=0
- * 104) Calculate q.header_crc.
- * 105) Send request q to EC.
- * 106) Wait for response r.  Go to 201 if received or 301 if timeout.
- *
- * 201) If r.struct_version != 4, go to 301.
- * 202) If r.header_crc mismatches calculated CRC for r header, go to 301.
- * 203) If r.data_crc_present and r.data_crc mismatches, go to 301.
- * 204) If r.seq_num != q.seq_num, go to 301.
- * 205) If r.seq_dup == q.seq_dup, return success.
- * 207) If r.seq_dup == 1, go to 301.
- * 208) Return error.
- *
- * 301) If --tries_left <= 0, return error.
- * 302) If q.seq_dup == 1, go to 105.
- * 303) q.seq_dup = 1
- * 304) Go to 104.
- *
- * EC algorithm when receiving a request q.
- * EC has response buffer r, error buffer e.
- *
- * 101) If q.struct_version != 4, set e.result = EC_RES_INVALID_HEADER_VERSION
- *      and go to 301
- * 102) If q.header_crc mismatches calculated CRC, set e.result =
- *      EC_RES_INVALID_HEADER_CRC and go to 301
- * 103) If q.data_crc_present, calculate data CRC.  If that mismatches the CRC
- *      byte at the end of the packet, set e.result = EC_RES_INVALID_DATA_CRC
- *      and go to 301.
- * 104) If q.seq_dup == 0, go to 201.
- * 105) If q.seq_num != r.seq_num, go to 201.
- * 106) If q.seq_dup == r.seq_dup, go to 205, else go to 203.
- *
- * 201) Process request q into response r.
- * 202) r.seq_num = q.seq_num
- * 203) r.seq_dup = q.seq_dup
- * 204) Calculate r.header_crc
- * 205) If r.data_len > 0 and data is no longer available, set e.result =
- *      EC_RES_DUP_UNAVAILABLE and go to 301.
- * 206) Send response r.
- *
- * 301) e.seq_num = q.seq_num
- * 302) e.seq_dup = q.seq_dup
- * 303) Calculate e.header_crc.
- * 304) Send error response e.
- */
-
-/* Version 4 request from host */
-struct __ec_align4 ec_host_request4 {
-	/*
-	 * bits 0-3: struct_version: Structure version (=4)
-	 * bit    4: is_response: Is response (=0)
-	 * bits 5-6: seq_num: Sequence number
-	 * bit    7: seq_dup: Sequence duplicate flag
-	 */
-	uint8_t fields0;
-
-	/*
-	 * bits 0-4: command_version: Command version
-	 * bits 5-6: Reserved (set 0, ignore on read)
-	 * bit    7: data_crc_present: Is data CRC present after data
-	 */
-	uint8_t fields1;
-
-	/* Command code (EC_CMD_*) */
-	uint16_t command;
-
-	/* Length of data which follows this header (not including data CRC) */
-	uint16_t data_len;
-
-	/* Reserved (set 0, ignore on read) */
-	uint8_t reserved;
-
-	/* CRC-8 of above fields, using x^8 + x^2 + x + 1 polynomial */
-	uint8_t header_crc;
-};
-
-/* Version 4 response from EC */
-struct __ec_align4 ec_host_response4 {
-	/*
-	 * bits 0-3: struct_version: Structure version (=4)
-	 * bit    4: is_response: Is response (=1)
-	 * bits 5-6: seq_num: Sequence number
-	 * bit    7: seq_dup: Sequence duplicate flag
-	 */
-	uint8_t fields0;
-
-	/*
-	 * bits 0-6: Reserved (set 0, ignore on read)
-	 * bit    7: data_crc_present: Is data CRC present after data
-	 */
-	uint8_t fields1;
-
-	/* Result code (EC_RES_*) */
-	uint16_t result;
-
-	/* Length of data which follows this header (not including data CRC) */
-	uint16_t data_len;
-
-	/* Reserved (set 0, ignore on read) */
-	uint8_t reserved;
-
-	/* CRC-8 of above fields, using x^8 + x^2 + x + 1 polynomial */
-	uint8_t header_crc;
-};
-
-/* Fields in fields0 byte */
-#define EC_PACKET4_0_STRUCT_VERSION_MASK	0x0f
-#define EC_PACKET4_0_IS_RESPONSE_MASK		0x10
-#define EC_PACKET4_0_SEQ_NUM_SHIFT		5
-#define EC_PACKET4_0_SEQ_NUM_MASK		0x60
-#define EC_PACKET4_0_SEQ_DUP_MASK		0x80
-
-/* Fields in fields1 byte */
-#define EC_PACKET4_1_COMMAND_VERSION_MASK	0x1f  /* (request only) */
-#define EC_PACKET4_1_DATA_CRC_PRESENT_MASK	0x80
+} __packed;
 
 /*****************************************************************************/
 /*
  * Notes on commands:
  *
  * Each command is an 16-bit command value.  Commands which take params or
- * return response data specify structures for that data.  If no structure is
+ * return response data specify structs for that data.  If no struct is
  * specified, the command does not input or output data, respectively.
  * Parameter/response length is implicit in the structs.  Some underlying
  * communication protocols (I2C, SPI) may add length or checksum headers, but
  * those are implementation-dependent and not defined here.
- *
- * All commands MUST be #defined to be 4-digit UPPER CASE hex values
- * (e.g., 0x00AB, not 0xab) for CONFIG_HOSTCMD_SECTION_SORTED to work.
  */
 
 /*****************************************************************************/
@@ -953,40 +530,40 @@ struct __ec_align4 ec_host_response4 {
  * Get protocol version, used to deal with non-backward compatible protocol
  * changes.
  */
-#define EC_CMD_PROTO_VERSION 0x0000
+#define EC_CMD_PROTO_VERSION 0x00
 
 /**
  * struct ec_response_proto_version - Response to the proto version command.
  * @version: The protocol version.
  */
-struct __ec_align4 ec_response_proto_version {
+struct ec_response_proto_version {
 	uint32_t version;
-};
+} __packed;
 
 /*
  * Hello.  This is a simple command to test the EC is responsive to
  * commands.
  */
-#define EC_CMD_HELLO 0x0001
+#define EC_CMD_HELLO 0x01
 
 /**
  * struct ec_params_hello - Parameters to the hello command.
  * @in_data: Pass anything here.
  */
-struct __ec_align4 ec_params_hello {
+struct ec_params_hello {
 	uint32_t in_data;
-};
+} __packed;
 
 /**
  * struct ec_response_hello - Response to the hello command.
  * @out_data: Output will be in_data + 0x01020304.
  */
-struct __ec_align4 ec_response_hello {
+struct ec_response_hello {
 	uint32_t out_data;
-};
+} __packed;
 
 /* Get version number */
-#define EC_CMD_GET_VERSION 0x0002
+#define EC_CMD_GET_VERSION 0x02
 
 enum ec_current_image {
 	EC_IMAGE_UNKNOWN = 0,
@@ -1001,43 +578,43 @@ enum ec_current_image {
  * @reserved: Unused bytes; was previously RW-B firmware version string.
  * @current_image: One of ec_current_image.
  */
-struct __ec_align4 ec_response_get_version {
+struct ec_response_get_version {
 	char version_string_ro[32];
 	char version_string_rw[32];
 	char reserved[32];
 	uint32_t current_image;
-};
+} __packed;
 
 /* Read test */
-#define EC_CMD_READ_TEST 0x0003
+#define EC_CMD_READ_TEST 0x03
 
 /**
  * struct ec_params_read_test - Parameters for the read test command.
  * @offset: Starting value for read buffer.
  * @size: Size to read in bytes.
  */
-struct __ec_align4 ec_params_read_test {
+struct ec_params_read_test {
 	uint32_t offset;
 	uint32_t size;
-};
+} __packed;
 
 /**
  * struct ec_response_read_test - Response to the read test command.
  * @data: Data returned by the read test command.
  */
-struct __ec_align4 ec_response_read_test {
+struct ec_response_read_test {
 	uint32_t data[32];
-};
+} __packed;
 
 /*
  * Get build information
  *
  * Response is null-terminated string.
  */
-#define EC_CMD_GET_BUILD_INFO 0x0004
+#define EC_CMD_GET_BUILD_INFO 0x04
 
 /* Get chip info */
-#define EC_CMD_GET_CHIP_INFO 0x0005
+#define EC_CMD_GET_CHIP_INFO 0x05
 
 /**
  * struct ec_response_get_chip_info - Response to the get chip info command.
@@ -1045,22 +622,22 @@ struct __ec_align4 ec_response_read_test {
  * @name: Null-terminated string for chip name.
  * @revision: Null-terminated string for chip mask version.
  */
-struct __ec_align4 ec_response_get_chip_info {
+struct ec_response_get_chip_info {
 	char vendor[32];
 	char name[32];
 	char revision[32];
-};
+} __packed;
 
 /* Get board HW version */
-#define EC_CMD_GET_BOARD_VERSION 0x0006
+#define EC_CMD_GET_BOARD_VERSION 0x06
 
 /**
  * struct ec_response_board_version - Response to the board version command.
  * @board_version: A monotonously incrementing number.
  */
-struct __ec_align2 ec_response_board_version {
+struct ec_response_board_version {
 	uint16_t board_version;
-};
+} __packed;
 
 /*
  * Read memory-mapped data.
@@ -1070,55 +647,55 @@ struct __ec_align2 ec_response_board_version {
  *
  * Response is params.size bytes of data.
  */
-#define EC_CMD_READ_MEMMAP 0x0007
+#define EC_CMD_READ_MEMMAP 0x07
 
 /**
  * struct ec_params_read_memmap - Parameters for the read memory map command.
  * @offset: Offset in memmap (EC_MEMMAP_*).
  * @size: Size to read in bytes.
  */
-struct __ec_align1 ec_params_read_memmap {
+struct ec_params_read_memmap {
 	uint8_t offset;
 	uint8_t size;
-};
+} __packed;
 
 /* Read versions supported for a command */
-#define EC_CMD_GET_CMD_VERSIONS 0x0008
+#define EC_CMD_GET_CMD_VERSIONS 0x08
 
 /**
  * struct ec_params_get_cmd_versions - Parameters for the get command versions.
  * @cmd: Command to check.
  */
-struct __ec_align1 ec_params_get_cmd_versions {
+struct ec_params_get_cmd_versions {
 	uint8_t cmd;
-};
+} __packed;
 
 /**
  * struct ec_params_get_cmd_versions_v1 - Parameters for the get command
  *         versions (v1)
  * @cmd: Command to check.
  */
-struct __ec_align2 ec_params_get_cmd_versions_v1 {
+struct ec_params_get_cmd_versions_v1 {
 	uint16_t cmd;
-};
+} __packed;
 
 /**
  * struct ec_response_get_cmd_version - Response to the get command versions.
  * @version_mask: Mask of supported versions; use EC_VER_MASK() to compare with
  *                a desired version.
  */
-struct __ec_align4 ec_response_get_cmd_versions {
+struct ec_response_get_cmd_versions {
 	uint32_t version_mask;
-};
+} __packed;
 
 /*
- * Check EC communications status (busy). This is needed on i2c/spi but not
+ * Check EC communcations status (busy). This is needed on i2c/spi but not
  * on lpc since it has its own out-of-band busy indicator.
  *
  * lpc must read the status from the command register. Attempting this on
  * lpc will overwrite the args/parameter space and corrupt its data.
  */
-#define EC_CMD_GET_COMMS_STATUS		0x0009
+#define EC_CMD_GET_COMMS_STATUS		0x09
 
 /* Avoid using ec_status which is for return values */
 enum ec_comms_status {
@@ -1130,27 +707,27 @@ enum ec_comms_status {
  *         command.
  * @flags: Mask of enum ec_comms_status.
  */
-struct __ec_align4 ec_response_get_comms_status {
+struct ec_response_get_comms_status {
 	uint32_t flags;		/* Mask of enum ec_comms_status */
-};
+} __packed;
 
 /* Fake a variety of responses, purely for testing purposes. */
-#define EC_CMD_TEST_PROTOCOL		0x000A
+#define EC_CMD_TEST_PROTOCOL		0x0a
 
 /* Tell the EC what to send back to us. */
-struct __ec_align4 ec_params_test_protocol {
+struct ec_params_test_protocol {
 	uint32_t ec_result;
 	uint32_t ret_len;
 	uint8_t buf[32];
-};
+} __packed;
 
 /* Here it comes... */
-struct __ec_align4 ec_response_test_protocol {
+struct ec_response_test_protocol {
 	uint8_t buf[32];
-};
+} __packed;
 
-/* Get protocol information */
-#define EC_CMD_GET_PROTOCOL_INFO	0x000B
+/* Get prococol information */
+#define EC_CMD_GET_PROTOCOL_INFO	0x0b
 
 /* Flags for ec_response_get_protocol_info.flags */
 /* EC_RES_IN_PROGRESS may be returned if a command is slow */
@@ -1164,13 +741,13 @@ struct __ec_align4 ec_response_test_protocol {
  * @max_response_packet_size: Maximum response packet size in bytes.
  * @flags: see EC_PROTOCOL_INFO_*
  */
-struct __ec_align4 ec_response_get_protocol_info {
+struct ec_response_get_protocol_info {
 	/* Fields which exist if at least protocol version 3 supported */
 	uint32_t protocol_versions;
 	uint16_t max_request_packet_size;
 	uint16_t max_response_packet_size;
 	uint32_t flags;
-};
+} __packed;
 
 
 /*****************************************************************************/
@@ -1185,22 +762,22 @@ struct __ec_align4 ec_response_get_protocol_info {
  */
 #define EC_GSV_PARAM_MASK 0x00ffffff
 
-struct __ec_align4 ec_params_get_set_value {
+struct ec_params_get_set_value {
 	uint32_t flags;
 	uint32_t value;
-};
+} __packed;
 
-struct __ec_align4 ec_response_get_set_value {
+struct ec_response_get_set_value {
 	uint32_t flags;
 	uint32_t value;
-};
+} __packed;
 
-/* More than one command can use these structs to get/set parameters. */
-#define EC_CMD_GSV_PAUSE_IN_S5	0x000C
+/* More than one command can use these structs to get/set paramters. */
+#define EC_CMD_GSV_PAUSE_IN_S5	0x0c
 
 /*****************************************************************************/
 /* List the features supported by the firmware */
-#define EC_CMD_GET_FEATURES  0x000D
+#define EC_CMD_GET_FEATURES  0x0d
 
 /* Supported features */
 enum ec_feature_code {
@@ -1307,7 +884,7 @@ enum ec_feature_code {
 	EC_FEATURE_REFINED_TABLET_MODE_HYSTERESIS = 37,
 	/* EC supports audio codec. */
 	EC_FEATURE_AUDIO_CODEC = 38,
-	/* The MCU is a System Companion Processor (SCP). */
+	/* EC Supports SCP. */
 	EC_FEATURE_SCP = 39,
 	/* The MCU is an Integrated Sensor Hub */
 	EC_FEATURE_ISH = 40,
@@ -1316,27 +893,15 @@ enum ec_feature_code {
 #define EC_FEATURE_MASK_0(event_code) (1UL << (event_code % 32))
 #define EC_FEATURE_MASK_1(event_code) (1UL << (event_code - 32))
 
-struct __ec_align4 ec_response_get_features {
+struct ec_response_get_features {
 	uint32_t flags[2];
-};
-
-/*****************************************************************************/
-/* Get the board's SKU ID from EC */
-#define EC_CMD_GET_SKU_ID 0x000E
-
-/* Set SKU ID from AP */
-#define EC_CMD_SET_SKU_ID 0x000F
-
-struct __ec_align4 ec_sku_id_info {
-	uint32_t sku_id;
-};
+} __packed;
 
 /*****************************************************************************/
 /* Flash commands */
 
 /* Get flash info */
-#define EC_CMD_FLASH_INFO 0x0010
-#define EC_VER_FLASH_INFO 2
+#define EC_CMD_FLASH_INFO 0x10
 
 /**
  * struct ec_response_flash_info - Response to the flash info command.
@@ -1350,24 +915,17 @@ struct __ec_align4 ec_sku_id_info {
  *
  * Version 0 returns these fields.
  */
-struct __ec_align4 ec_response_flash_info {
+struct ec_response_flash_info {
 	uint32_t flash_size;
 	uint32_t write_block_size;
 	uint32_t erase_block_size;
 	uint32_t protect_block_size;
-};
+} __packed;
 
 /* Flags for version 1+ flash info command */
 /* EC flash erases bits to 0 instead of 1 */
 #define EC_FLASH_INFO_ERASE_TO_0 (1 << 0)
 
-/* Flash must be selected for read/write/erase operations to succeed.  This may
- * be necessary on a chip where write/erase can be corrupted by other board
- * activity, or where the chip needs to enable some sort of programming voltage,
- * or where the read/write/erase operations require cleanly suspending other
- * chip functionality. */
-#define EC_FLASH_INFO_SELECT_REQUIRED (1 << 1)
-
 /**
  * struct ec_response_flash_info_1 - Response to the flash info v1 command.
  * @flash_size: Usable flash size in bytes.
@@ -1388,16 +946,9 @@ struct __ec_align4 ec_response_flash_info {
  * fields following.
  *
  * gcc anonymous structs don't seem to get along with the __packed directive;
- * if they did we'd define the version 0 structure as a sub-structure of this
- * one.
- *
- * Version 2 supports flash banks of different sizes:
- * The caller specified the number of banks it has preallocated
- * (num_banks_desc)
- * The EC returns the number of banks describing the flash memory.
- * It adds banks descriptions up to num_banks_desc.
+ * if they did we'd define the version 0 struct as a sub-struct of this one.
  */
-struct __ec_align4 ec_response_flash_info_1 {
+struct ec_response_flash_info_1 {
 	/* Version 0 fields; see above for description */
 	uint32_t flash_size;
 	uint32_t write_block_size;
@@ -1407,63 +958,27 @@ struct __ec_align4 ec_response_flash_info_1 {
 	/* Version 1 adds these fields: */
 	uint32_t write_ideal_size;
 	uint32_t flags;
-};
-
-struct __ec_align4 ec_params_flash_info_2 {
-	/* Number of banks to describe */
-	uint16_t num_banks_desc;
-	/* Reserved; set 0; ignore on read */
-	uint8_t reserved[2];
-};
-
-struct ec_flash_bank {
-	/* Number of sector is in this bank. */
-	uint16_t count;
-	/* Size in power of 2 of each sector (8 --> 256 bytes) */
-	uint8_t size_exp;
-	/* Minimal write size for the sectors in this bank */
-	uint8_t write_size_exp;
-	/* Erase size for the sectors in this bank */
-	uint8_t erase_size_exp;
-	/* Size for write protection, usually identical to erase size. */
-	uint8_t protect_size_exp;
-	/* Reserved; set 0; ignore on read */
-	uint8_t reserved[2];
-};
-
-struct __ec_align4 ec_response_flash_info_2 {
-	/* Total flash in the EC. */
-	uint32_t flash_size;
-	/* Flags; see EC_FLASH_INFO_* */
-	uint32_t flags;
-	/* Maximum size to use to send data to write to the EC. */
-	uint32_t write_ideal_size;
-	/* Number of banks present in the EC. */
-	uint16_t num_banks_total;
-	/* Number of banks described in banks array. */
-	uint16_t num_banks_desc;
-	struct ec_flash_bank banks[0];
-};
+} __packed;
 
 /*
  * Read flash
  *
  * Response is params.size bytes of data.
  */
-#define EC_CMD_FLASH_READ 0x0011
+#define EC_CMD_FLASH_READ 0x11
 
 /**
  * struct ec_params_flash_read - Parameters for the flash read command.
  * @offset: Byte offset to read.
  * @size: Size to read in bytes.
  */
-struct __ec_align4 ec_params_flash_read {
+struct ec_params_flash_read {
 	uint32_t offset;
 	uint32_t size;
-};
+} __packed;
 
 /* Write flash */
-#define EC_CMD_FLASH_WRITE 0x0012
+#define EC_CMD_FLASH_WRITE 0x12
 #define EC_VER_FLASH_WRITE 1
 
 /* Version 0 of the flash command supported only 64 bytes of data */
@@ -1474,59 +989,24 @@ struct __ec_align4 ec_params_flash_read {
  * @offset: Byte offset to write.
  * @size: Size to write in bytes.
  */
-struct __ec_align4 ec_params_flash_write {
+struct ec_params_flash_write {
 	uint32_t offset;
 	uint32_t size;
 	/* Followed by data to write */
-};
+} __packed;
 
 /* Erase flash */
-#define EC_CMD_FLASH_ERASE 0x0013
+#define EC_CMD_FLASH_ERASE 0x13
 
 /**
- * struct ec_params_flash_erase - Parameters for the flash erase command, v0.
+ * struct ec_params_flash_erase - Parameters for the flash erase command.
  * @offset: Byte offset to erase.
  * @size: Size to erase in bytes.
  */
-struct __ec_align4 ec_params_flash_erase {
+struct ec_params_flash_erase {
 	uint32_t offset;
 	uint32_t size;
-};
-
-
-#define EC_VER_FLASH_WRITE 1
-/* v1 add async erase:
- * subcommands can returns:
- * EC_RES_SUCCESS : erased (see ERASE_SECTOR_ASYNC case below).
- * EC_RES_INVALID_PARAM : offset/size are not aligned on a erase boundary.
- * EC_RES_ERROR : other errors.
- * EC_RES_BUSY : an existing erase operation is in progress.
- * EC_RES_ACCESS_DENIED: Trying to erase running image.
- *
- * When ERASE_SECTOR_ASYNC returns EC_RES_SUCCESS, the operation is just
- * properly queued. The user must call ERASE_GET_RESULT subcommand to get
- * the proper result.
- * When ERASE_GET_RESULT returns EC_RES_BUSY, the caller must wait and send
- * ERASE_GET_RESULT again to get the result of ERASE_SECTOR_ASYNC.
- * ERASE_GET_RESULT command may timeout on EC where flash access is not
- * permitted while erasing. (For instance, STM32F4).
- */
-enum ec_flash_erase_cmd {
-	FLASH_ERASE_SECTOR,     /* Erase and wait for result */
-	FLASH_ERASE_SECTOR_ASYNC,  /* Erase and return immediately. */
-	FLASH_ERASE_GET_RESULT,  /* Ask for last erase result */
-};
-
-struct __ec_align4 ec_params_flash_erase_v1 {
-	/* One of ec_flash_erase_cmd. */
-	uint8_t  cmd;
-	/* Pad byte; currently always contains 0 */
-	uint8_t  reserved;
-	/* No flags defined yet; set to 0 */
-	uint16_t flag;
-	/* Same as v0 parameters. */
-	struct ec_params_flash_erase params;
-};
+} __packed;
 
 /*
  * Get/set flash protection.
@@ -1538,7 +1018,7 @@ struct __ec_align4 ec_params_flash_erase_v1 {
  *
  * If mask=0, simply returns the current flags state.
  */
-#define EC_CMD_FLASH_PROTECT 0x0015
+#define EC_CMD_FLASH_PROTECT 0x15
 #define EC_VER_FLASH_PROTECT 1  /* Command version 1 */
 
 /* Flags for flash protection */
@@ -1561,27 +1041,18 @@ struct __ec_align4 ec_params_flash_erase_v1 {
  * re-requesting the desired flags, or by a hard reset if that fails.
  */
 #define EC_FLASH_PROTECT_ERROR_INCONSISTENT (1 << 5)
-/* Entire flash code protected when the EC boots */
+/* Entile flash code protected when the EC boots */
 #define EC_FLASH_PROTECT_ALL_AT_BOOT        (1 << 6)
-/* RW flash code protected when the EC boots */
-#define EC_FLASH_PROTECT_RW_AT_BOOT         (1 << 7)
-/* RW flash code protected now. */
-#define EC_FLASH_PROTECT_RW_NOW             (1 << 8)
-/* Rollback information flash region protected when the EC boots */
-#define EC_FLASH_PROTECT_ROLLBACK_AT_BOOT   (1 << 9)
-/* Rollback information flash region protected now */
-#define EC_FLASH_PROTECT_ROLLBACK_NOW       (1 << 10)
-
 
 /**
  * struct ec_params_flash_protect - Parameters for the flash protect command.
  * @mask: Bits in flags to apply.
  * @flags: New flags to apply.
  */
-struct __ec_align4 ec_params_flash_protect {
+struct ec_params_flash_protect {
 	uint32_t mask;
 	uint32_t flags;
-};
+} __packed;
 
 /**
  * struct ec_response_flash_protect - Response to the flash protect command.
@@ -1592,11 +1063,11 @@ struct __ec_align4 ec_params_flash_protect {
  * @writable_flags: Flags which can be changed given the current protection
  *                  state.
  */
-struct __ec_align4 ec_response_flash_protect {
+struct ec_response_flash_protect {
 	uint32_t flags;
 	uint32_t valid_flags;
 	uint32_t writable_flags;
-};
+} __packed;
 
 /*
  * Note: commands 0x14 - 0x19 version 0 were old commands to get/set flash
@@ -1604,52 +1075,39 @@ struct __ec_align4 ec_response_flash_protect {
  */
 
 /* Get the region offset/size */
-#define EC_CMD_FLASH_REGION_INFO 0x0016
+#define EC_CMD_FLASH_REGION_INFO 0x16
 #define EC_VER_FLASH_REGION_INFO 1
 
 enum ec_flash_region {
 	/* Region which holds read-only EC image */
 	EC_FLASH_REGION_RO = 0,
-	/*
-	 * Region which holds active RW image. 'Active' is different from
-	 * 'running'. Active means 'scheduled-to-run'. Since RO image always
-	 * scheduled to run, active/non-active applies only to RW images (for
-	 * the same reason 'update' applies only to RW images. It's a state of
-	 * an image on a flash. Running image can be RO, RW_A, RW_B but active
-	 * image can only be RW_A or RW_B. In recovery mode, an active RW image
-	 * doesn't enter 'running' state but it's still active on a flash.
-	 */
-	EC_FLASH_REGION_ACTIVE,
+	/* Region which holds rewritable EC image */
+	EC_FLASH_REGION_RW,
 	/*
 	 * Region which should be write-protected in the factory (a superset of
 	 * EC_FLASH_REGION_RO)
 	 */
 	EC_FLASH_REGION_WP_RO,
-	/* Region which holds updatable (non-active) RW image */
-	EC_FLASH_REGION_UPDATE,
 	/* Number of regions */
 	EC_FLASH_REGION_COUNT,
 };
-/* 'RW' is vague if there are multiple RW images; we mean the active one,
- * so the old constant is deprecated */
-#define EC_FLASH_REGION_RW EC_FLASH_REGION_ACTIVE
 
 /**
  * struct ec_params_flash_region_info - Parameters for the flash region info
  *         command.
  * @region: Flash region; see EC_FLASH_REGION_*
  */
-struct __ec_align4 ec_params_flash_region_info {
+struct ec_params_flash_region_info {
 	uint32_t region;
-};
+} __packed;
 
-struct __ec_align4 ec_response_flash_region_info {
+struct ec_response_flash_region_info {
 	uint32_t offset;
 	uint32_t size;
-};
+} __packed;
 
 /* Read/write VbNvContext */
-#define EC_CMD_VBNV_CONTEXT 0x0017
+#define EC_CMD_VBNV_CONTEXT 0x17
 #define EC_VER_VBNV_CONTEXT 1
 #define EC_VBNV_BLOCK_SIZE 16
 
@@ -1658,99 +1116,55 @@ enum ec_vbnvcontext_op {
 	EC_VBNV_CONTEXT_OP_WRITE,
 };
 
-struct __ec_align4 ec_params_vbnvcontext {
+struct ec_params_vbnvcontext {
 	uint32_t op;
 	uint8_t block[EC_VBNV_BLOCK_SIZE];
-};
+} __packed;
 
-struct __ec_align4 ec_response_vbnvcontext {
+struct ec_response_vbnvcontext {
 	uint8_t block[EC_VBNV_BLOCK_SIZE];
-};
-
-
-/* Get SPI flash information */
-#define EC_CMD_FLASH_SPI_INFO 0x0018
-
-struct __ec_align1 ec_response_flash_spi_info {
-	/* JEDEC info from command 0x9F (manufacturer, memory type, size) */
-	uint8_t jedec[3];
-
-	/* Pad byte; currently always contains 0 */
-	uint8_t reserved0;
-
-	/* Manufacturer / device ID from command 0x90 */
-	uint8_t mfr_dev_id[2];
-
-	/* Status registers from command 0x05 and 0x35 */
-	uint8_t sr1, sr2;
-};
-
-
-/* Select flash during flash operations */
-#define EC_CMD_FLASH_SELECT 0x0019
-
-struct __ec_align4 ec_params_flash_select {
-	/* 1 to select flash, 0 to deselect flash */
-	uint8_t select;
-};
-
+} __packed;
 
 /*****************************************************************************/
 /* PWM commands */
 
 /* Get fan target RPM */
-#define EC_CMD_PWM_GET_FAN_TARGET_RPM 0x0020
+#define EC_CMD_PWM_GET_FAN_TARGET_RPM 0x20
 
-struct __ec_align4 ec_response_pwm_get_fan_rpm {
+struct ec_response_pwm_get_fan_rpm {
 	uint32_t rpm;
-};
+} __packed;
 
 /* Set target fan RPM */
-#define EC_CMD_PWM_SET_FAN_TARGET_RPM 0x0021
-
-/* Version 0 of input params */
-struct __ec_align4 ec_params_pwm_set_fan_target_rpm_v0 {
-	uint32_t rpm;
-};
+#define EC_CMD_PWM_SET_FAN_TARGET_RPM 0x21
 
-/* Version 1 of input params */
-struct __ec_align_size1 ec_params_pwm_set_fan_target_rpm_v1 {
+struct ec_params_pwm_set_fan_target_rpm {
 	uint32_t rpm;
-	uint8_t fan_idx;
-};
+} __packed;
 
 /* Get keyboard backlight */
-/* OBSOLETE - Use EC_CMD_PWM_SET_DUTY */
-#define EC_CMD_PWM_GET_KEYBOARD_BACKLIGHT 0x0022
+#define EC_CMD_PWM_GET_KEYBOARD_BACKLIGHT 0x22
 
-struct __ec_align1 ec_response_pwm_get_keyboard_backlight {
+struct ec_response_pwm_get_keyboard_backlight {
 	uint8_t percent;
 	uint8_t enabled;
-};
+} __packed;
 
 /* Set keyboard backlight */
-/* OBSOLETE - Use EC_CMD_PWM_SET_DUTY */
-#define EC_CMD_PWM_SET_KEYBOARD_BACKLIGHT 0x0023
+#define EC_CMD_PWM_SET_KEYBOARD_BACKLIGHT 0x23
 
-struct __ec_align1 ec_params_pwm_set_keyboard_backlight {
+struct ec_params_pwm_set_keyboard_backlight {
 	uint8_t percent;
-};
+} __packed;
 
 /* Set target fan PWM duty cycle */
-#define EC_CMD_PWM_SET_FAN_DUTY 0x0024
-
-/* Version 0 of input params */
-struct __ec_align4 ec_params_pwm_set_fan_duty_v0 {
-	uint32_t percent;
-};
+#define EC_CMD_PWM_SET_FAN_DUTY 0x24
 
-/* Version 1 of input params */
-struct __ec_align_size1 ec_params_pwm_set_fan_duty_v1 {
+struct ec_params_pwm_set_fan_duty {
 	uint32_t percent;
-	uint8_t fan_idx;
-};
+} __packed;
 
-#define EC_CMD_PWM_SET_DUTY 0x0025
+#define EC_CMD_PWM_SET_DUTY 0x25
 /* 16 bit duty cycle, 0xffff = 100% */
 #define EC_PWM_MAX_DUTY 0xffff
 
@@ -1764,22 +1178,22 @@ enum ec_pwm_type {
 	EC_PWM_TYPE_COUNT,
 };
 
-struct __ec_align4 ec_params_pwm_set_duty {
+struct ec_params_pwm_set_duty {
 	uint16_t duty;     /* Duty cycle, EC_PWM_MAX_DUTY = 100% */
 	uint8_t pwm_type;  /* ec_pwm_type */
 	uint8_t index;     /* Type-specific index, or 0 if unique */
-};
+} __packed;
 
-#define EC_CMD_PWM_GET_DUTY 0x0026
+#define EC_CMD_PWM_GET_DUTY 0x26
 
-struct __ec_align1 ec_params_pwm_get_duty {
+struct ec_params_pwm_get_duty {
 	uint8_t pwm_type;  /* ec_pwm_type */
 	uint8_t index;     /* Type-specific index, or 0 if unique */
-};
+} __packed;
 
-struct __ec_align2 ec_response_pwm_get_duty {
+struct ec_response_pwm_get_duty {
 	uint16_t duty;     /* Duty cycle, EC_PWM_MAX_DUTY = 100% */
-};
+} __packed;
 
 /*****************************************************************************/
 /*
@@ -1788,9 +1202,9 @@ struct __ec_align2 ec_response_pwm_get_duty {
  * into a subcommand. We'll make separate structs for subcommands with
  * different input args, so that we know how much to expect.
  */
-#define EC_CMD_LIGHTBAR_CMD 0x0028
+#define EC_CMD_LIGHTBAR_CMD 0x28
 
-struct __ec_todo_unpacked rgb_s {
+struct rgb_s {
 	uint8_t r, g, b;
 };
 
@@ -1800,7 +1214,7 @@ struct __ec_todo_unpacked rgb_s {
  * List of tweakable parameters. NOTE: It's __packed so it can be sent in a
  * host command, but the alignment is the same regardless. Keep it that way.
  */
-struct __ec_todo_packed lightbar_params_v0 {
+struct lightbar_params_v0 {
 	/* Timing */
 	int32_t google_ramp_up;
 	int32_t google_ramp_down;
@@ -1832,67 +1246,9 @@ struct __ec_todo_packed lightbar_params_v0 {
 
 	/* Color palette */
 	struct rgb_s color[8];			/* 0-3 are Google colors */
-};
-
-struct __ec_todo_packed lightbar_params_v1 {
-	/* Timing */
-	int32_t google_ramp_up;
-	int32_t google_ramp_down;
-	int32_t s3s0_ramp_up;
-	int32_t s0_tick_delay[2];		/* AC=0/1 */
-	int32_t s0a_tick_delay[2];		/* AC=0/1 */
-	int32_t s0s3_ramp_down;
-	int32_t s3_sleep_for;
-	int32_t s3_ramp_up;
-	int32_t s3_ramp_down;
-	int32_t s5_ramp_up;
-	int32_t s5_ramp_down;
-	int32_t tap_tick_delay;
-	int32_t tap_gate_delay;
-	int32_t tap_display_time;
-
-	/* Tap-for-battery params */
-	uint8_t tap_pct_red;
-	uint8_t tap_pct_green;
-	uint8_t tap_seg_min_on;
-	uint8_t tap_seg_max_on;
-	uint8_t tap_seg_osc;
-	uint8_t tap_idx[3];
-
-	/* Oscillation */
-	uint8_t osc_min[2];			/* AC=0/1 */
-	uint8_t osc_max[2];			/* AC=0/1 */
-	uint8_t w_ofs[2];			/* AC=0/1 */
-
-	/* Brightness limits based on the backlight and AC. */
-	uint8_t bright_bl_off_fixed[2];		/* AC=0/1 */
-	uint8_t bright_bl_on_min[2];		/* AC=0/1 */
-	uint8_t bright_bl_on_max[2];		/* AC=0/1 */
-
-	/* Battery level thresholds */
-	uint8_t battery_threshold[LB_BATTERY_LEVELS - 1];
-
-	/* Map [AC][battery_level] to color index */
-	uint8_t s0_idx[2][LB_BATTERY_LEVELS];	/* AP is running */
-	uint8_t s3_idx[2][LB_BATTERY_LEVELS];	/* AP is sleeping */
-
-	/* s5: single color pulse on inhibited power-up */
-	uint8_t s5_idx;
-
-	/* Color palette */
-	struct rgb_s color[8];			/* 0-3 are Google colors */
-};
-
-/* Lightbar command params v2
- * crbug.com/467716
- *
- * lightbar_parms_v1 was too big for i2c, therefore in v2, we split them up by
- * logical groups to make it more manageable ( < 120 bytes).
- *
- * NOTE: Each of these groups must be less than 120 bytes.
- */
+} __packed;
 
-struct __ec_todo_packed lightbar_params_v2_timing {
+struct lightbar_params_v1 {
 	/* Timing */
 	int32_t google_ramp_up;
 	int32_t google_ramp_down;
@@ -1903,14 +1259,9 @@ struct __ec_todo_packed lightbar_params_v2_timing {
 	int32_t s3_sleep_for;
 	int32_t s3_ramp_up;
 	int32_t s3_ramp_down;
-	int32_t s5_ramp_up;
-	int32_t s5_ramp_down;
 	int32_t tap_tick_delay;
-	int32_t tap_gate_delay;
 	int32_t tap_display_time;
-};
 
-struct __ec_todo_packed lightbar_params_v2_tap {
 	/* Tap-for-battery params */
 	uint8_t tap_pct_red;
 	uint8_t tap_pct_green;
@@ -1918,140 +1269,102 @@ struct __ec_todo_packed lightbar_params_v2_tap {
 	uint8_t tap_seg_max_on;
 	uint8_t tap_seg_osc;
 	uint8_t tap_idx[3];
-};
 
-struct __ec_todo_packed lightbar_params_v2_oscillation {
 	/* Oscillation */
 	uint8_t osc_min[2];			/* AC=0/1 */
 	uint8_t osc_max[2];			/* AC=0/1 */
 	uint8_t w_ofs[2];			/* AC=0/1 */
-};
 
-struct __ec_todo_packed lightbar_params_v2_brightness {
 	/* Brightness limits based on the backlight and AC. */
 	uint8_t bright_bl_off_fixed[2];		/* AC=0/1 */
 	uint8_t bright_bl_on_min[2];		/* AC=0/1 */
 	uint8_t bright_bl_on_max[2];		/* AC=0/1 */
-};
 
-struct __ec_todo_packed lightbar_params_v2_thresholds {
 	/* Battery level thresholds */
 	uint8_t battery_threshold[LB_BATTERY_LEVELS - 1];
-};
 
-struct __ec_todo_packed lightbar_params_v2_colors {
 	/* Map [AC][battery_level] to color index */
 	uint8_t s0_idx[2][LB_BATTERY_LEVELS];	/* AP is running */
 	uint8_t s3_idx[2][LB_BATTERY_LEVELS];	/* AP is sleeping */
 
-	/* s5: single color pulse on inhibited power-up */
-	uint8_t s5_idx;
-
 	/* Color palette */
 	struct rgb_s color[8];			/* 0-3 are Google colors */
-};
+} __packed;
 
-/* Lightbyte program. */
+/* Lightbar program */
 #define EC_LB_PROG_LEN 192
-struct __ec_todo_unpacked lightbar_program {
+struct lightbar_program {
 	uint8_t size;
 	uint8_t data[EC_LB_PROG_LEN];
 };
 
-struct __ec_todo_packed ec_params_lightbar {
+struct ec_params_lightbar {
 	uint8_t cmd;		      /* Command (see enum lightbar_command) */
 	union {
-		/*
-		 * The following commands have no args:
-		 *
-		 * dump, off, on, init, get_seq, get_params_v0, get_params_v1,
-		 * version, get_brightness, get_demo, suspend, resume,
-		 * get_params_v2_timing, get_params_v2_tap, get_params_v2_osc,
-		 * get_params_v2_bright, get_params_v2_thlds,
-		 * get_params_v2_colors
-		 *
-		 * Don't use an empty struct, because C++ hates that.
-		 */
+		struct {
+			/* no args */
+		} dump, off, on, init, get_seq, get_params_v0, get_params_v1,
+			version, get_brightness, get_demo, suspend, resume;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t num;
 		} set_brightness, seq, demo;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t ctrl, reg, value;
 		} reg;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t led, red, green, blue;
 		} set_rgb;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t led;
 		} get_rgb;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t enable;
 		} manual_suspend_ctrl;
 
 		struct lightbar_params_v0 set_params_v0;
 		struct lightbar_params_v1 set_params_v1;
-
-		struct lightbar_params_v2_timing set_v2par_timing;
-		struct lightbar_params_v2_tap set_v2par_tap;
-		struct lightbar_params_v2_oscillation set_v2par_osc;
-		struct lightbar_params_v2_brightness set_v2par_bright;
-		struct lightbar_params_v2_thresholds set_v2par_thlds;
-		struct lightbar_params_v2_colors set_v2par_colors;
-
 		struct lightbar_program set_program;
 	};
-};
+} __packed;
 
-struct __ec_todo_packed ec_response_lightbar {
+struct ec_response_lightbar {
 	union {
-		struct __ec_todo_unpacked {
-			struct __ec_todo_unpacked {
+		struct {
+			struct {
 				uint8_t reg;
 				uint8_t ic0;
 				uint8_t ic1;
 			} vals[23];
 		} dump;
 
-		struct __ec_todo_unpacked {
+		struct  {
 			uint8_t num;
 		} get_seq, get_brightness, get_demo;
 
 		struct lightbar_params_v0 get_params_v0;
 		struct lightbar_params_v1 get_params_v1;
 
-
-		struct lightbar_params_v2_timing get_params_v2_timing;
-		struct lightbar_params_v2_tap get_params_v2_tap;
-		struct lightbar_params_v2_oscillation get_params_v2_osc;
-		struct lightbar_params_v2_brightness get_params_v2_bright;
-		struct lightbar_params_v2_thresholds get_params_v2_thlds;
-		struct lightbar_params_v2_colors get_params_v2_colors;
-
-		struct __ec_todo_unpacked {
+		struct {
 			uint32_t num;
 			uint32_t flags;
 		} version;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t red, green, blue;
 		} get_rgb;
 
-		/*
-		 * The following commands have no response:
-		 *
-		 * off, on, init, set_brightness, seq, reg, set_rgb, demo,
-		 * set_params_v0, set_params_v1, set_program,
-		 * manual_suspend_ctrl, suspend, resume, set_v2par_timing,
-		 * set_v2par_tap, set_v2par_osc, set_v2par_bright,
-		 * set_v2par_thlds, set_v2par_colors
-		 */
+		struct {
+			/* no return params */
+		} off, on, init, set_brightness, seq, reg, set_rgb,
+			demo, set_params_v0, set_params_v1,
+			set_program, manual_suspend_ctrl, suspend, resume;
 	};
-};
+} __packed;
 
 /* Lightbar commands */
 enum lightbar_command {
@@ -2077,25 +1390,13 @@ enum lightbar_command {
 	LIGHTBAR_CMD_MANUAL_SUSPEND_CTRL = 19,
 	LIGHTBAR_CMD_SUSPEND = 20,
 	LIGHTBAR_CMD_RESUME = 21,
-	LIGHTBAR_CMD_GET_PARAMS_V2_TIMING = 22,
-	LIGHTBAR_CMD_SET_PARAMS_V2_TIMING = 23,
-	LIGHTBAR_CMD_GET_PARAMS_V2_TAP = 24,
-	LIGHTBAR_CMD_SET_PARAMS_V2_TAP = 25,
-	LIGHTBAR_CMD_GET_PARAMS_V2_OSCILLATION = 26,
-	LIGHTBAR_CMD_SET_PARAMS_V2_OSCILLATION = 27,
-	LIGHTBAR_CMD_GET_PARAMS_V2_BRIGHTNESS = 28,
-	LIGHTBAR_CMD_SET_PARAMS_V2_BRIGHTNESS = 29,
-	LIGHTBAR_CMD_GET_PARAMS_V2_THRESHOLDS = 30,
-	LIGHTBAR_CMD_SET_PARAMS_V2_THRESHOLDS = 31,
-	LIGHTBAR_CMD_GET_PARAMS_V2_COLORS = 32,
-	LIGHTBAR_CMD_SET_PARAMS_V2_COLORS = 33,
 	LIGHTBAR_NUM_CMDS
 };
 
 /*****************************************************************************/
 /* LED control commands */
 
-#define EC_CMD_LED_CONTROL 0x0029
+#define EC_CMD_LED_CONTROL 0x29
 
 enum ec_led_id {
 	/* LED to indicate battery state of charge */
@@ -2107,14 +1408,6 @@ enum ec_led_id {
 	EC_LED_ID_POWER_LED,
 	/* LED on power adapter or its plug */
 	EC_LED_ID_ADAPTER_LED,
-	/* LED to indicate left side */
-	EC_LED_ID_LEFT_LED,
-	/* LED to indicate right side */
-	EC_LED_ID_RIGHT_LED,
-	/* LED to indicate recovery mode with HW_REINIT */
-	EC_LED_ID_RECOVERY_HW_REINIT_LED,
-	/* LED to indicate sysrq debug mode. */
-	EC_LED_ID_SYSRQ_DEBUG_LED,
 
 	EC_LED_ID_COUNT
 };
@@ -2129,19 +1422,18 @@ enum ec_led_colors {
 	EC_LED_COLOR_BLUE,
 	EC_LED_COLOR_YELLOW,
 	EC_LED_COLOR_WHITE,
-	EC_LED_COLOR_AMBER,
 
 	EC_LED_COLOR_COUNT
 };
 
-struct __ec_align1 ec_params_led_control {
+struct ec_params_led_control {
 	uint8_t led_id;     /* Which LED to control */
 	uint8_t flags;      /* Control flags */
 
 	uint8_t brightness[EC_LED_COLOR_COUNT];
-};
+} __packed;
 
-struct __ec_align1 ec_response_led_control {
+struct ec_response_led_control {
 	/*
 	 * Available brightness value range.
 	 *
@@ -2150,7 +1442,7 @@ struct __ec_align1 ec_response_led_control {
 	 * Other values means the LED is control by PWM.
 	 */
 	uint8_t brightness_range[EC_LED_COLOR_COUNT];
-};
+} __packed;
 
 /*****************************************************************************/
 /* Verified boot commands */
@@ -2161,9 +1453,9 @@ struct __ec_align1 ec_response_led_control {
  */
 
 /* Verified boot hash command */
-#define EC_CMD_VBOOT_HASH 0x002A
+#define EC_CMD_VBOOT_HASH 0x2A
 
-struct __ec_align4 ec_params_vboot_hash {
+struct ec_params_vboot_hash {
 	uint8_t cmd;             /* enum ec_vboot_hash_cmd */
 	uint8_t hash_type;       /* enum ec_vboot_hash_type */
 	uint8_t nonce_size;      /* Nonce size; may be 0 */
@@ -2171,9 +1463,9 @@ struct __ec_align4 ec_params_vboot_hash {
 	uint32_t offset;         /* Offset in flash to hash */
 	uint32_t size;           /* Number of bytes to hash */
 	uint8_t nonce_data[64];  /* Nonce data; ignored if nonce_size=0 */
-};
+} __packed;
 
-struct __ec_align4 ec_response_vboot_hash {
+struct ec_response_vboot_hash {
 	uint8_t status;          /* enum ec_vboot_hash_status */
 	uint8_t hash_type;       /* enum ec_vboot_hash_type */
 	uint8_t digest_size;     /* Size of hash digest in bytes */
@@ -2181,7 +1473,7 @@ struct __ec_align4 ec_response_vboot_hash {
 	uint32_t offset;         /* Offset in flash which was hashed */
 	uint32_t size;           /* Number of bytes hashed */
 	uint8_t hash_digest[64]; /* Hash digest data */
-};
+} __packed;
 
 enum ec_vboot_hash_cmd {
 	EC_VBOOT_HASH_GET = 0,       /* Get current hash status */
@@ -2205,20 +1497,15 @@ enum ec_vboot_hash_status {
  * If one of these is specified, the EC will automatically update offset and
  * size to the correct values for the specified image (RO or RW).
  */
-#define EC_VBOOT_HASH_OFFSET_RO		0xfffffffe
-#define EC_VBOOT_HASH_OFFSET_ACTIVE	0xfffffffd
-#define EC_VBOOT_HASH_OFFSET_UPDATE	0xfffffffc
-
-/* 'RW' is vague if there are multiple RW images; we mean the active one,
- * so the old constant is deprecated */
-#define EC_VBOOT_HASH_OFFSET_RW EC_VBOOT_HASH_OFFSET_ACTIVE
+#define EC_VBOOT_HASH_OFFSET_RO 0xfffffffe
+#define EC_VBOOT_HASH_OFFSET_RW 0xfffffffd
 
 /*****************************************************************************/
 /*
  * Motion sense commands. We'll make separate structs for sub-commands with
  * different input args, so that we know how much to expect.
  */
-#define EC_CMD_MOTION_SENSE_CMD 0x002B
+#define EC_CMD_MOTION_SENSE_CMD 0x2B
 
 /* Motion sense commands */
 enum motionsense_command {
@@ -2237,13 +1524,7 @@ enum motionsense_command {
 
 	/*
 	 * EC Rate command is a setter/getter command for the EC sampling rate
-	 * in milliseconds.
-	 * It is per sensor, the EC run sample task  at the minimum of all
-	 * sensors EC_RATE.
-	 * For sensors without hardware FIFO, EC_RATE should be equals to 1/ODR
-	 * to collect all the sensor samples.
-	 * For sensor with hardware FIFO, EC_RATE is used as the maximal delay
-	 * to process of all motion sensors in milliseconds.
+	 * of all motion sensors in milliseconds.
 	 */
 	MOTIONSENSE_CMD_EC_RATE = 2,
 
@@ -2274,67 +1555,32 @@ enum motionsense_command {
 	MOTIONSENSE_CMD_DATA = 6,
 
 	/*
-	 * Return sensor fifo info.
-	 */
-	MOTIONSENSE_CMD_FIFO_INFO = 7,
-
-	/*
-	 * Insert a flush element in the fifo and return sensor fifo info.
-	 * The host can use that element to synchronize its operation.
-	 */
-	MOTIONSENSE_CMD_FIFO_FLUSH = 8,
-
-	/*
-	 * Return a portion of the fifo.
-	 */
-	MOTIONSENSE_CMD_FIFO_READ = 9,
-
-	/*
-	 * Perform low level calibration.
-	 * On sensors that support it, ask to do offset calibration.
+	 * Perform low level calibration.. On sensors that support it, ask to
+	 * do offset calibration.
 	 */
 	MOTIONSENSE_CMD_PERFORM_CALIB = 10,
 
 	/*
-	 * Sensor Offset command is a setter/getter command for the offset
-	 * used for calibration.
-	 * The offsets can be calculated by the host, or via
+	 * Sensor Offset command is a setter/getter command for the offset used
+	 * for calibration. The offsets can be calculated by the host, or via
 	 * PERFORM_CALIB command.
 	 */
 	MOTIONSENSE_CMD_SENSOR_OFFSET = 11,
 
-	/*
-	 * List available activities for a MOTION sensor.
-	 * Indicates if they are enabled or disabled.
-	 */
-	MOTIONSENSE_CMD_LIST_ACTIVITIES = 12,
-
-	/*
-	 * Activity management
-	 * Enable/Disable activity recognition.
-	 */
-	MOTIONSENSE_CMD_SET_ACTIVITY = 13,
-
-	/*
-	 * Lid Angle
-	 */
-	MOTIONSENSE_CMD_LID_ANGLE = 14,
+	/* Number of motionsense sub-commands. */
+	MOTIONSENSE_NUM_CMDS
+};
 
-	/*
-	 * Allow the FIFO to trigger interrupt via MKBP events.
-	 * By default the FIFO does not send interrupt to process the FIFO
-	 * until the AP is ready or it is coming from a wakeup sensor.
-	 */
-	MOTIONSENSE_CMD_FIFO_INT_ENABLE = 15,
+enum motionsensor_id {
+	EC_MOTION_SENSOR_ACCEL_BASE = 0,
+	EC_MOTION_SENSOR_ACCEL_LID = 1,
+	EC_MOTION_SENSOR_GYRO = 2,
 
 	/*
-	 * Spoof the readings of the sensors.  The spoofed readings can be set
-	 * to arbitrary values, or will lock to the last read actual values.
+	 * Note, if more sensors are added and this count changes, the padding
+	 * in ec_response_motion_sense dump command must be modified.
 	 */
-	MOTIONSENSE_CMD_SPOOF = 16,
-
-	/* Number of motionsense sub-commands. */
-	MOTIONSENSE_NUM_CMDS
+	EC_MOTION_SENSOR_COUNT = 3
 };
 
 /* List of motion sensor types. */
@@ -2346,7 +1592,6 @@ enum motionsensor_type {
 	MOTIONSENSE_TYPE_LIGHT = 4,
 	MOTIONSENSE_TYPE_ACTIVITY = 5,
 	MOTIONSENSE_TYPE_BARO = 6,
-	MOTIONSENSE_TYPE_SYNC = 7,
 	MOTIONSENSE_TYPE_MAX,
 };
 
@@ -2354,89 +1599,12 @@ enum motionsensor_type {
 enum motionsensor_location {
 	MOTIONSENSE_LOC_BASE = 0,
 	MOTIONSENSE_LOC_LID = 1,
-	MOTIONSENSE_LOC_CAMERA = 2,
 	MOTIONSENSE_LOC_MAX,
 };
 
 /* List of motion sensor chips. */
 enum motionsensor_chip {
 	MOTIONSENSE_CHIP_KXCJ9 = 0,
-	MOTIONSENSE_CHIP_LSM6DS0 = 1,
-	MOTIONSENSE_CHIP_BMI160 = 2,
-	MOTIONSENSE_CHIP_SI1141 = 3,
-	MOTIONSENSE_CHIP_SI1142 = 4,
-	MOTIONSENSE_CHIP_SI1143 = 5,
-	MOTIONSENSE_CHIP_KX022 = 6,
-	MOTIONSENSE_CHIP_L3GD20H = 7,
-	MOTIONSENSE_CHIP_BMA255 = 8,
-	MOTIONSENSE_CHIP_BMP280 = 9,
-	MOTIONSENSE_CHIP_OPT3001 = 10,
-	MOTIONSENSE_CHIP_BH1730 = 11,
-	MOTIONSENSE_CHIP_GPIO = 12,
-};
-
-/* List of orientation positions */
-enum motionsensor_orientation {
-	MOTIONSENSE_ORIENTATION_LANDSCAPE = 0,
-	MOTIONSENSE_ORIENTATION_PORTRAIT = 1,
-	MOTIONSENSE_ORIENTATION_UPSIDE_DOWN_PORTRAIT = 2,
-	MOTIONSENSE_ORIENTATION_UPSIDE_DOWN_LANDSCAPE = 3,
-	MOTIONSENSE_ORIENTATION_UNKNOWN = 4,
-};
-
-struct __ec_todo_packed ec_response_motion_sensor_data {
-	/* Flags for each sensor. */
-	uint8_t flags;
-	/* sensor number the data comes from */
-	uint8_t sensor_num;
-	/* Each sensor is up to 3-axis. */
-	union {
-		int16_t             data[3];
-		struct __ec_todo_packed {
-			uint16_t    reserved;
-			uint32_t    timestamp;
-		};
-		struct __ec_todo_unpacked {
-			uint8_t     activity; /* motionsensor_activity */
-			uint8_t     state;
-			int16_t     add_info[2];
-		};
-	};
-};
-
-/* Note: used in ec_response_get_next_data */
-struct __ec_todo_packed ec_response_motion_sense_fifo_info {
-	/* Size of the fifo */
-	uint16_t size;
-	/* Amount of space used in the fifo */
-	uint16_t count;
-	/* Timestamp recorded in us */
-	uint32_t timestamp;
-	/* Total amount of vector lost */
-	uint16_t total_lost;
-	/* Lost events since the last fifo_info, per sensors */
-	uint16_t lost[0];
-};
-
-struct __ec_todo_packed ec_response_motion_sense_fifo_data {
-	uint32_t number_data;
-	struct ec_response_motion_sensor_data data[0];
-};
-
-/* List supported activity recognition */
-enum motionsensor_activity {
-	MOTIONSENSE_ACTIVITY_RESERVED = 0,
-	MOTIONSENSE_ACTIVITY_SIG_MOTION = 1,
-	MOTIONSENSE_ACTIVITY_DOUBLE_TAP = 2,
-	MOTIONSENSE_ACTIVITY_ORIENTATION = 3,
-};
-
-struct __ec_todo_unpacked ec_motion_sense_activity {
-	uint8_t sensor_num;
-	uint8_t activity; /* one of enum motionsensor_activity */
-	uint8_t enable;   /* 1: enable, 0: disable */
-	uint8_t reserved;
-	uint16_t parameters[3]; /* activity dependent parameters */
 };
 
 /* Module flag masks used for the dump sub-command. */
@@ -2445,16 +1613,6 @@ struct __ec_todo_unpacked ec_motion_sense_activity {
 /* Sensor flag masks used for the dump sub-command. */
 #define MOTIONSENSE_SENSOR_FLAG_PRESENT (1<<0)
 
-/*
- * Flush entry for synchronization.
- * data contains time stamp
- */
-#define MOTIONSENSE_SENSOR_FLAG_FLUSH (1<<0)
-#define MOTIONSENSE_SENSOR_FLAG_TIMESTAMP (1<<1)
-#define MOTIONSENSE_SENSOR_FLAG_WAKEUP (1<<2)
-#define MOTIONSENSE_SENSOR_FLAG_TABLET_MODE (1<<3)
-#define MOTIONSENSE_SENSOR_FLAG_ODR (1<<4)
-
 /*
  * Send this value for the data element to only perform a read. If you
  * send any other value, the EC will interpret it as data to set and will
@@ -2464,74 +1622,48 @@ struct __ec_todo_unpacked ec_motion_sense_activity {
 
 #define EC_MOTION_SENSE_INVALID_CALIB_TEMP 0x8000
 
-/* MOTIONSENSE_CMD_SENSOR_OFFSET subcommand flag */
 /* Set Calibration information */
-#define MOTION_SENSE_SET_OFFSET 1
-
-#define LID_ANGLE_UNRELIABLE 500
-
-enum motionsense_spoof_mode {
-	/* Disable spoof mode. */
-	MOTIONSENSE_SPOOF_MODE_DISABLE = 0,
-
-	/* Enable spoof mode, but use provided component values. */
-	MOTIONSENSE_SPOOF_MODE_CUSTOM,
+#define MOTION_SENSE_SET_OFFSET	1
 
-	/* Enable spoof mode, but use the current sensor values. */
-	MOTIONSENSE_SPOOF_MODE_LOCK_CURRENT,
-
-	/* Query the current spoof mode status for the sensor. */
-	MOTIONSENSE_SPOOF_MODE_QUERY,
-};
+struct ec_response_motion_sensor_data {
+	/* Flags for each sensor. */
+	uint8_t flags;
+	/* Sensor number the data comes from */
+	uint8_t sensor_num;
+	/* Each sensor is up to 3-axis. */
+	union {
+		int16_t             data[3];
+		struct {
+			uint16_t    rsvd;
+			uint32_t    timestamp;
+		} __packed;
+		struct {
+			uint8_t     activity; /* motionsensor_activity */
+			uint8_t     state;
+			int16_t     add_info[2];
+		};
+	};
+} __packed;
 
-struct __ec_todo_packed ec_params_motion_sense {
+struct ec_params_motion_sense {
 	uint8_t cmd;
 	union {
-		/* Used for MOTIONSENSE_CMD_DUMP */
-		struct __ec_todo_unpacked {
-			/*
-			 * Maximal number of sensor the host is expecting.
-			 * 0 means the host is only interested in the number
-			 * of sensors controlled by the EC.
-			 */
-			uint8_t max_sensor_count;
+		/* Used for MOTIONSENSE_CMD_DUMP. */
+		struct {
+			/* no args */
 		} dump;
 
 		/*
-		 * Used for MOTIONSENSE_CMD_KB_WAKE_ANGLE.
+		 * Used for MOTIONSENSE_CMD_EC_RATE and
+		 * MOTIONSENSE_CMD_KB_WAKE_ANGLE.
 		 */
-		struct __ec_todo_unpacked {
-			/* Data to set or EC_MOTION_SENSE_NO_VALUE to read.
-			 * kb_wake_angle: angle to wakup AP.
-			 */
-			int16_t data;
-		} kb_wake_angle;
-
-		/* Used for MOTIONSENSE_CMD_INFO, MOTIONSENSE_CMD_DATA
-		 * and MOTIONSENSE_CMD_PERFORM_CALIB. */
-		struct __ec_todo_unpacked {
-			uint8_t sensor_num;
-		} info, info_3, data, fifo_flush, perform_calib,
-				list_activities;
-
-		/*
-		 * Used for MOTIONSENSE_CMD_EC_RATE, MOTIONSENSE_CMD_SENSOR_ODR
-		 * and MOTIONSENSE_CMD_SENSOR_RANGE.
-		 */
-		struct __ec_todo_unpacked {
-			uint8_t sensor_num;
-
-			/* Rounding flag, true for round-up, false for down. */
-			uint8_t roundup;
-
-			uint16_t reserved;
-
+		struct {
 			/* Data to set or EC_MOTION_SENSE_NO_VALUE to read. */
-			int32_t data;
-		} ec_rate, sensor_odr, sensor_range;
+			int16_t data;
+		} ec_rate, kb_wake_angle;
 
 		/* Used for MOTIONSENSE_CMD_SENSOR_OFFSET */
-		struct __ec_todo_packed {
+		struct {
 			uint8_t sensor_num;
 
 			/*
@@ -2557,69 +1689,51 @@ struct __ec_todo_packed ec_params_motion_sense {
 			 * Compass:       1/16 uT
 			 */
 			int16_t offset[3];
-		} sensor_offset;
-
-		/* Used for MOTIONSENSE_CMD_FIFO_INFO */
-		/* (no params) */
-
-		/* Used for MOTIONSENSE_CMD_FIFO_READ */
-		struct __ec_todo_unpacked {
-			/*
-			 * Number of expected vector to return.
-			 * EC may return less or 0 if none available.
-			 */
-			uint32_t max_data_vector;
-		} fifo_read;
-
-		struct ec_motion_sense_activity set_activity;
-
-		/* Used for MOTIONSENSE_CMD_LID_ANGLE */
-		/* (no params) */
+		} __packed sensor_offset;
 
-		/* Used for MOTIONSENSE_CMD_FIFO_INT_ENABLE */
-		struct __ec_todo_unpacked {
-			/*
-			 * 1: enable, 0 disable fifo,
-			 * EC_MOTION_SENSE_NO_VALUE return value.
-			 */
-			int8_t enable;
-		} fifo_int_enable;
+		/* Used for MOTIONSENSE_CMD_INFO. */
+		struct {
+			uint8_t sensor_num;
+		} info;
 
-		/* Used for MOTIONSENSE_CMD_SPOOF */
-		struct __ec_todo_packed {
-			uint8_t sensor_id;
+		/*
+		 * Used for MOTIONSENSE_CMD_SENSOR_ODR and
+		 * MOTIONSENSE_CMD_SENSOR_RANGE.
+		 */
+		struct {
+			/* Should be element of enum motionsensor_id. */
+			uint8_t sensor_num;
 
-			/* See enum motionsense_spoof_mode. */
-			uint8_t spoof_enable;
+			/* Rounding flag, true for round-up, false for down. */
+			uint8_t roundup;
 
-			/* Ignored, used for alignment. */
-			uint8_t reserved;
+			uint16_t reserved;
 
-			/* Individual component values to spoof. */
-			int16_t components[3];
-		} spoof;
+			/* Data to set or EC_MOTION_SENSE_NO_VALUE to read. */
+			int32_t data;
+		} sensor_odr, sensor_range;
 	};
-};
+} __packed;
 
-struct __ec_todo_packed ec_response_motion_sense {
+struct ec_response_motion_sense {
 	union {
-		/* Used for MOTIONSENSE_CMD_DUMP */
-		struct __ec_todo_unpacked {
+		/* Used for MOTIONSENSE_CMD_DUMP. */
+		struct {
 			/* Flags representing the motion sensor module. */
 			uint8_t module_flags;
 
-			/* Number of sensors managed directly by the EC */
+			/* Number of sensors managed directly by the EC. */
 			uint8_t sensor_count;
 
 			/*
-			 * sensor data is truncated if response_max is too small
+			 * Sensor data is truncated if response_max is too small
 			 * for holding all the data.
 			 */
 			struct ec_response_motion_sensor_data sensor[0];
 		} dump;
 
 		/* Used for MOTIONSENSE_CMD_INFO. */
-		struct __ec_todo_unpacked {
+		struct {
 			/* Should be element of enum motionsensor_type. */
 			uint8_t type;
 
@@ -2630,106 +1744,37 @@ struct __ec_todo_packed ec_response_motion_sense {
 			uint8_t chip;
 		} info;
 
-		/* Used for MOTIONSENSE_CMD_INFO version 3 */
-		struct __ec_todo_unpacked {
-			/* Should be element of enum motionsensor_type. */
-			uint8_t type;
-
-			/* Should be element of enum motionsensor_location. */
-			uint8_t location;
-
-			/* Should be element of enum motionsensor_chip. */
-			uint8_t chip;
-
-			/* Minimum sensor sampling frequency */
-			uint32_t min_frequency;
-
-			/* Maximum sensor sampling frequency */
-			uint32_t max_frequency;
-
-			/* Max number of sensor events that could be in fifo */
-			uint32_t fifo_max_event_count;
-		} info_3;
-
 		/* Used for MOTIONSENSE_CMD_DATA */
 		struct ec_response_motion_sensor_data data;
 
 		/*
 		 * Used for MOTIONSENSE_CMD_EC_RATE, MOTIONSENSE_CMD_SENSOR_ODR,
-		 * MOTIONSENSE_CMD_SENSOR_RANGE,
-		 * MOTIONSENSE_CMD_KB_WAKE_ANGLE,
-		 * MOTIONSENSE_CMD_FIFO_INT_ENABLE and
-		 * MOTIONSENSE_CMD_SPOOF.
+		 * MOTIONSENSE_CMD_SENSOR_RANGE, and
+		 * MOTIONSENSE_CMD_KB_WAKE_ANGLE.
 		 */
-		struct __ec_todo_unpacked {
+		struct {
 			/* Current value of the parameter queried. */
 			int32_t ret;
-		} ec_rate, sensor_odr, sensor_range, kb_wake_angle,
-		  fifo_int_enable, spoof;
+		} ec_rate, sensor_odr, sensor_range, kb_wake_angle;
 
 		/* Used for MOTIONSENSE_CMD_SENSOR_OFFSET */
-		struct __ec_todo_unpacked  {
+		struct {
 			int16_t temp;
 			int16_t offset[3];
 		} sensor_offset, perform_calib;
-
-		struct ec_response_motion_sense_fifo_info fifo_info, fifo_flush;
-
-		struct ec_response_motion_sense_fifo_data fifo_read;
-
-		struct __ec_todo_packed {
-			uint16_t reserved;
-			uint32_t enabled;
-			uint32_t disabled;
-		} list_activities;
-
-		/* No params for set activity */
-
-		/* Used for MOTIONSENSE_CMD_LID_ANGLE */
-		struct __ec_todo_unpacked {
-			/*
-			 * Angle between 0 and 360 degree if available,
-			 * LID_ANGLE_UNRELIABLE otherwise.
-			 */
-			uint16_t value;
-		} lid_angle;
 	};
-};
-
-/*****************************************************************************/
-/* Force lid open command */
-
-/* Make lid event always open */
-#define EC_CMD_FORCE_LID_OPEN 0x002C
-
-struct __ec_align1 ec_params_force_lid_open {
-	uint8_t enabled;
-};
-
-/*****************************************************************************/
-/* Configure the behavior of the power button */
-#define EC_CMD_CONFIG_POWER_BUTTON 0x002D
-
-enum ec_config_power_button_flags {
-	/* Enable/Disable power button pulses for x86 devices */
-	EC_POWER_BUTTON_ENABLE_PULSE = (1 << 0),
-};
-
-struct __ec_align1 ec_params_config_power_button {
-	/* See enum ec_config_power_button_flags */
-	uint8_t flags;
-};
+} __packed;
 
 /*****************************************************************************/
 /* USB charging control commands */
 
 /* Set USB port charging mode */
-#define EC_CMD_USB_CHARGE_SET_MODE 0x0030
+#define EC_CMD_USB_CHARGE_SET_MODE 0x30
 
-struct __ec_align1 ec_params_usb_charge_set_mode {
+struct ec_params_usb_charge_set_mode {
 	uint8_t usb_port_id;
 	uint8_t mode;
-};
+} __packed;
 
 /*****************************************************************************/
 /* Persistent storage for host */
@@ -2738,57 +1783,57 @@ struct __ec_align1 ec_params_usb_charge_set_mode {
 #define EC_PSTORE_SIZE_MAX 64
 
 /* Get persistent storage info */
-#define EC_CMD_PSTORE_INFO 0x0040
+#define EC_CMD_PSTORE_INFO 0x40
 
-struct __ec_align4 ec_response_pstore_info {
+struct ec_response_pstore_info {
 	/* Persistent storage size, in bytes */
 	uint32_t pstore_size;
 	/* Access size; read/write offset and size must be a multiple of this */
 	uint32_t access_size;
-};
+} __packed;
 
 /*
  * Read persistent storage
  *
  * Response is params.size bytes of data.
  */
-#define EC_CMD_PSTORE_READ 0x0041
+#define EC_CMD_PSTORE_READ 0x41
 
-struct __ec_align4 ec_params_pstore_read {
+struct ec_params_pstore_read {
 	uint32_t offset;   /* Byte offset to read */
 	uint32_t size;     /* Size to read in bytes */
-};
+} __packed;
 
 /* Write persistent storage */
-#define EC_CMD_PSTORE_WRITE 0x0042
+#define EC_CMD_PSTORE_WRITE 0x42
 
-struct __ec_align4 ec_params_pstore_write {
+struct ec_params_pstore_write {
 	uint32_t offset;   /* Byte offset to write */
 	uint32_t size;     /* Size to write in bytes */
 	uint8_t data[EC_PSTORE_SIZE_MAX];
-};
+} __packed;
 
 /*****************************************************************************/
 /* Real-time clock */
 
 /* RTC params and response structures */
-struct __ec_align4 ec_params_rtc {
+struct ec_params_rtc {
 	uint32_t time;
-};
+} __packed;
 
-struct __ec_align4 ec_response_rtc {
+struct ec_response_rtc {
 	uint32_t time;
-};
+} __packed;
 
 /* These use ec_response_rtc */
-#define EC_CMD_RTC_GET_VALUE 0x0044
-#define EC_CMD_RTC_GET_ALARM 0x0045
+#define EC_CMD_RTC_GET_VALUE 0x44
+#define EC_CMD_RTC_GET_ALARM 0x45
 
 /* These all use ec_params_rtc */
-#define EC_CMD_RTC_SET_VALUE 0x0046
-#define EC_CMD_RTC_SET_ALARM 0x0047
+#define EC_CMD_RTC_SET_VALUE 0x46
+#define EC_CMD_RTC_SET_ALARM 0x47
 
-/* Pass as time param to SET_ALARM to clear the current alarm */
+/* Pass as param to SET_ALARM to clear the current alarm */
 #define EC_RTC_ALARM_CLEAR 0
 
 /*****************************************************************************/
@@ -2798,83 +1843,40 @@ struct __ec_align4 ec_response_rtc {
 #define EC_PORT80_SIZE_MAX 32
 
 /* Get last port80 code from previous boot */
-#define EC_CMD_PORT80_LAST_BOOT 0x0048
-#define EC_CMD_PORT80_READ 0x0048
+#define EC_CMD_PORT80_LAST_BOOT 0x48
+#define EC_CMD_PORT80_READ 0x48
 
 enum ec_port80_subcmd {
 	EC_PORT80_GET_INFO = 0,
 	EC_PORT80_READ_BUFFER,
 };
 
-struct __ec_todo_packed ec_params_port80_read {
+struct ec_params_port80_read {
 	uint16_t subcmd;
 	union {
-		struct __ec_todo_unpacked {
+		struct {
 			uint32_t offset;
 			uint32_t num_entries;
 		} read_buffer;
 	};
-};
+} __packed;
 
-struct __ec_todo_packed ec_response_port80_read {
+struct ec_response_port80_read {
 	union {
-		struct __ec_todo_unpacked {
+		struct {
 			uint32_t writes;
 			uint32_t history_size;
 			uint32_t last_boot;
 		} get_info;
-		struct __ec_todo_unpacked {
+		struct {
 			uint16_t codes[EC_PORT80_SIZE_MAX];
 		} data;
 	};
-};
+} __packed;
 
-struct __ec_align2 ec_response_port80_last_boot {
+struct ec_response_port80_last_boot {
 	uint16_t code;
-};
-
-/*****************************************************************************/
-/* Temporary secure storage for host verified boot use */
-
-/* Number of bytes in a vstore slot */
-#define EC_VSTORE_SLOT_SIZE 64
-
-/* Maximum number of vstore slots */
-#define EC_VSTORE_SLOT_MAX 32
-
-/* Get persistent storage info */
-#define EC_CMD_VSTORE_INFO 0x0049
-struct __ec_align_size1 ec_response_vstore_info {
-	/* Indicates which slots are locked */
-	uint32_t slot_locked;
-	/* Total number of slots available */
-	uint8_t slot_count;
-};
-
-/*
- * Read temporary secure storage
- *
- * Response is EC_VSTORE_SLOT_SIZE bytes of data.
- */
-#define EC_CMD_VSTORE_READ 0x004A
-
-struct __ec_align1 ec_params_vstore_read {
-	uint8_t slot; /* Slot to read from */
-};
-
-struct __ec_align1 ec_response_vstore_read {
-	uint8_t data[EC_VSTORE_SLOT_SIZE];
-};
-
-/*
- * Write temporary secure storage and lock it.
- */
-#define EC_CMD_VSTORE_WRITE 0x004B
-
-struct __ec_align1 ec_params_vstore_write {
-	uint8_t slot; /* Slot to write to */
-	uint8_t data[EC_VSTORE_SLOT_SIZE];
-};
+} __packed;
 
 /*****************************************************************************/
 /* Thermal engine commands. Note that there are two implementations. We'll
@@ -2883,29 +1885,29 @@ struct __ec_align1 ec_params_vstore_write {
  * Version 1 separates the CPU thermal limits from the fan control.
  */
 
-#define EC_CMD_THERMAL_SET_THRESHOLD 0x0050
-#define EC_CMD_THERMAL_GET_THRESHOLD 0x0051
+#define EC_CMD_THERMAL_SET_THRESHOLD 0x50
+#define EC_CMD_THERMAL_GET_THRESHOLD 0x51
 
 /* The version 0 structs are opaque. You have to know what they are for
  * the get/set commands to make any sense.
  */
 
 /* Version 0 - set */
-struct __ec_align2 ec_params_thermal_set_threshold {
+struct ec_params_thermal_set_threshold {
 	uint8_t sensor_type;
 	uint8_t threshold_id;
 	uint16_t value;
-};
+} __packed;
 
 /* Version 0 - get */
-struct __ec_align1 ec_params_thermal_get_threshold {
+struct ec_params_thermal_get_threshold {
 	uint8_t sensor_type;
 	uint8_t threshold_id;
-};
+} __packed;
 
-struct __ec_align2 ec_response_thermal_get_threshold {
+struct ec_response_thermal_get_threshold {
 	uint16_t value;
-};
+} __packed;
 
 
 /* The version 1 structs are visible. */
@@ -2917,119 +1919,68 @@ enum ec_temp_thresholds {
 	EC_TEMP_THRESH_COUNT
 };
 
-/*
- * Thermal configuration for one temperature sensor. Temps are in degrees K.
+/* Thermal configuration for one temperature sensor. Temps are in degrees K.
  * Zero values will be silently ignored by the thermal task.
- *
- * Set 'temp_host' value allows thermal task to trigger some event with 1 degree
- * hysteresis.
- * For example,
- *	temp_host[EC_TEMP_THRESH_HIGH] = 300 K
- *	temp_host_release[EC_TEMP_THRESH_HIGH] = 0 K
- * EC will throttle ap when temperature >= 301 K, and release throttling when
- * temperature <= 299 K.
- *
- * Set 'temp_host_release' value allows thermal task has a custom hysteresis.
- * For example,
- *	temp_host[EC_TEMP_THRESH_HIGH] = 300 K
- *	temp_host_release[EC_TEMP_THRESH_HIGH] = 295 K
- * EC will throttle ap when temperature >= 301 K, and release throttling when
- * temperature <= 294 K.
- *
- * Note that this structure is a sub-structure of
- * ec_params_thermal_set_threshold_v1, but maintains its alignment there.
  */
-struct __ec_align4 ec_thermal_config {
+struct ec_thermal_config {
 	uint32_t temp_host[EC_TEMP_THRESH_COUNT]; /* levels of hotness */
-	uint32_t temp_host_release[EC_TEMP_THRESH_COUNT]; /* release levels */
 	uint32_t temp_fan_off;		/* no active cooling needed */
 	uint32_t temp_fan_max;		/* max active cooling needed */
-};
+} __packed;
 
 /* Version 1 - get config for one sensor. */
-struct __ec_align4 ec_params_thermal_get_threshold_v1 {
+struct ec_params_thermal_get_threshold_v1 {
 	uint32_t sensor_num;
-};
+} __packed;
 /* This returns a struct ec_thermal_config */
 
 /* Version 1 - set config for one sensor.
  * Use read-modify-write for best results! */
-struct __ec_align4 ec_params_thermal_set_threshold_v1 {
+struct ec_params_thermal_set_threshold_v1 {
 	uint32_t sensor_num;
 	struct ec_thermal_config cfg;
-};
+} __packed;
 /* This returns no data */
 
 /****************************************************************************/
 
 /* Toggle automatic fan control */
-#define EC_CMD_THERMAL_AUTO_FAN_CTRL 0x0052
-
-/* Version 1 of input params */
-struct __ec_align1 ec_params_auto_fan_ctrl_v1 {
-	uint8_t fan_idx;
-};
-
-/* Get/Set TMP006 calibration data */
-#define EC_CMD_TMP006_GET_CALIBRATION 0x0053
-#define EC_CMD_TMP006_SET_CALIBRATION 0x0054
+#define EC_CMD_THERMAL_AUTO_FAN_CTRL 0x52
 
-/*
- * The original TMP006 calibration only needed four params, but now we need
- * more. Since the algorithm is nothing but magic numbers anyway, we'll leave
- * the params opaque. The v1 "get" response will include the algorithm number
- * and how many params it requires. That way we can change the EC code without
- * needing to update this file. We can also use a different algorithm on each
- * sensor.
- */
+/* Get TMP006 calibration data */
+#define EC_CMD_TMP006_GET_CALIBRATION 0x53
 
-/* This is the same struct for both v0 and v1. */
-struct __ec_align1 ec_params_tmp006_get_calibration {
+struct ec_params_tmp006_get_calibration {
 	uint8_t index;
-};
+} __packed;
 
-/* Version 0 */
-struct __ec_align4 ec_response_tmp006_get_calibration_v0 {
+struct ec_response_tmp006_get_calibration {
 	float s0;
 	float b0;
 	float b1;
 	float b2;
-};
+} __packed;
 
-struct __ec_align4 ec_params_tmp006_set_calibration_v0 {
+/* Set TMP006 calibration data */
+#define EC_CMD_TMP006_SET_CALIBRATION 0x54
+
+struct ec_params_tmp006_set_calibration {
 	uint8_t index;
-	uint8_t reserved[3];
+	uint8_t reserved[3];  /* Reserved; set 0 */
 	float s0;
 	float b0;
 	float b1;
 	float b2;
-};
-
-/* Version 1 */
-struct __ec_align4 ec_response_tmp006_get_calibration_v1 {
-	uint8_t algorithm;
-	uint8_t num_params;
-	uint8_t reserved[2];
-	float val[0];
-};
-
-struct __ec_align4 ec_params_tmp006_set_calibration_v1 {
-	uint8_t index;
-	uint8_t algorithm;
-	uint8_t num_params;
-	uint8_t reserved;
-	float val[0];
-};
-
+} __packed;
 
 /* Read raw TMP006 data */
-#define EC_CMD_TMP006_GET_RAW 0x0055
+#define EC_CMD_TMP006_GET_RAW 0x55
 
-struct __ec_align1 ec_params_tmp006_get_raw {
+struct ec_params_tmp006_get_raw {
 	uint8_t index;
-};
+} __packed;
 
-struct __ec_align4 ec_response_tmp006_get_raw {
+struct ec_response_tmp006_get_raw {
 	int32_t t;  /* In 1/100 K */
 	int32_t v;  /* In nV */
 };
@@ -3047,24 +1998,24 @@ struct __ec_align4 ec_response_tmp006_get_raw {
  * to obtain the instantaneous state, use EC_CMD_MKBP_INFO with the type
  * EC_MKBP_INFO_CURRENT and event EC_MKBP_EVENT_KEY_MATRIX.
  */
-#define EC_CMD_MKBP_STATE 0x0060
+#define EC_CMD_MKBP_STATE 0x60
 
 /*
  * Provide information about various MKBP things.  See enum ec_mkbp_info_type.
  */
-#define EC_CMD_MKBP_INFO 0x0061
+#define EC_CMD_MKBP_INFO 0x61
 
-struct __ec_align_size1 ec_response_mkbp_info {
+struct ec_response_mkbp_info {
 	uint32_t rows;
 	uint32_t cols;
 	/* Formerly "switches", which was 0. */
 	uint8_t reserved;
-};
+} __packed;
 
-struct __ec_align1 ec_params_mkbp_info {
+struct ec_params_mkbp_info {
 	uint8_t info_type;
 	uint8_t event_type;
-};
+} __packed;
 
 enum ec_mkbp_info_type {
 	/*
@@ -3106,17 +2057,17 @@ enum ec_mkbp_info_type {
 };
 
 /* Simulate key press */
-#define EC_CMD_MKBP_SIMULATE_KEY 0x0062
+#define EC_CMD_MKBP_SIMULATE_KEY 0x62
 
-struct __ec_align1 ec_params_mkbp_simulate_key {
+struct ec_params_mkbp_simulate_key {
 	uint8_t col;
 	uint8_t row;
 	uint8_t pressed;
-};
+} __packed;
 
 /* Configure keyboard scanning */
-#define EC_CMD_MKBP_SET_CONFIG 0x0064
-#define EC_CMD_MKBP_GET_CONFIG 0x0065
+#define EC_CMD_MKBP_SET_CONFIG 0x64
+#define EC_CMD_MKBP_GET_CONFIG 0x65
 
 /* flags */
 enum mkbp_config_flags {
@@ -3133,13 +2084,8 @@ enum mkbp_config_valid {
 	EC_MKBP_VALID_FIFO_MAX_DEPTH		= 1 << 7,
 };
 
-/*
- * Configuration for our key scanning algorithm.
- *
- * Note that this is used as a sub-structure of
- * ec_{params/response}_mkbp_get_config.
- */
-struct __ec_align_size1 ec_mkbp_config {
+/* Configuration for our key scanning algorithm */
+struct ec_mkbp_config {
 	uint32_t valid_mask;		/* valid fields */
 	uint8_t flags;		/* some flags (enum mkbp_config_flags) */
 	uint8_t valid_flags;		/* which flags are valid */
@@ -3158,18 +2104,18 @@ struct __ec_align_size1 ec_mkbp_config {
 	uint16_t debounce_up_us;	/* time for debounce on key up */
 	/* maximum depth to allow for fifo (0 = no keyscan output) */
 	uint8_t fifo_max_depth;
-};
+} __packed;
 
-struct __ec_align_size1 ec_params_mkbp_set_config {
+struct ec_params_mkbp_set_config {
 	struct ec_mkbp_config config;
-};
+} __packed;
 
-struct __ec_align_size1 ec_response_mkbp_get_config {
+struct ec_response_mkbp_get_config {
 	struct ec_mkbp_config config;
-};
+} __packed;
 
 /* Run the key scan emulation */
-#define EC_CMD_KEYSCAN_SEQ_CTRL 0x0066
+#define EC_CMD_KEYSCAN_SEQ_CTRL 0x66
 
 enum ec_keyscan_seq_cmd {
 	EC_KEYSCAN_SEQ_STATUS = 0,	/* Get status information */
@@ -3187,20 +2133,20 @@ enum ec_collect_flags {
 	EC_KEYSCAN_SEQ_FLAG_DONE	= 1 << 0,
 };
 
-struct __ec_align1 ec_collect_item {
+struct ec_collect_item {
 	uint8_t flags;		/* some flags (enum ec_collect_flags) */
 };
 
-struct __ec_todo_packed ec_params_keyscan_seq_ctrl {
+struct ec_params_keyscan_seq_ctrl {
 	uint8_t cmd;	/* Command to send (enum ec_keyscan_seq_cmd) */
 	union {
-		struct __ec_align1 {
+		struct {
 			uint8_t active;		/* still active */
 			uint8_t num_items;	/* number of items */
 			/* Current item being presented */
 			uint8_t cur_item;
 		} status;
-		struct __ec_todo_unpacked {
+		struct {
 			/*
 			 * Absolute time for this scan, measured from the
 			 * start of the sequence.
@@ -3208,37 +2154,29 @@ struct __ec_todo_packed ec_params_keyscan_seq_ctrl {
 			uint32_t time_us;
 			uint8_t scan[0];	/* keyscan data */
 		} add;
-		struct __ec_align1 {
+		struct {
 			uint8_t start_item;	/* First item to return */
 			uint8_t num_items;	/* Number of items to return */
 		} collect;
 	};
-};
+} __packed;
 
-struct __ec_todo_packed ec_result_keyscan_seq_ctrl {
+struct ec_result_keyscan_seq_ctrl {
 	union {
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t num_items;	/* Number of items */
 			/* Data for each item */
 			struct ec_collect_item item[0];
 		} collect;
 	};
-};
+} __packed;
 
 /*
- * Get the next pending MKBP event.
+ * Command for retrieving the next pending MKBP event from the EC device
  *
- * Returns EC_RES_UNAVAILABLE if there is no event pending.
+ * The device replies with UNAVAILABLE if there aren't any pending events.
  */
-#define EC_CMD_GET_NEXT_EVENT 0x0067
-
-#define EC_MKBP_HAS_MORE_EVENTS_SHIFT 7
-
-/* EC can provide more MKBP events to host */
-#define EC_MKBP_HAS_MORE_EVENTS (1 << EC_MKBP_HAS_MORE_EVENTS_SHIFT)
-
-/* The mask to apply to get the raw event type */
-#define EC_MKBP_EVENT_TYPE_MASK ((1 << EC_MKBP_HAS_MORE_EVENTS_SHIFT) - 1)
+#define EC_CMD_GET_NEXT_EVENT 0x67
 
 enum ec_mkbp_event {
 	/* Keyboard matrix changed. The event data is the new matrix state. */
@@ -3256,21 +2194,9 @@ enum ec_mkbp_event {
 	/* The state of the switches have changed. */
 	EC_MKBP_EVENT_SWITCH = 4,
 
-	/* New Fingerprint sensor event, the event data is fp_events bitmap. */
-	EC_MKBP_EVENT_FINGERPRINT = 5,
-
-	/*
-	 * Sysrq event: send emulated sysrq. The event data is sysrq,
-	 * corresponding to the key to be pressed.
-	 */
+	/* EC sent a sysrq command */
 	EC_MKBP_EVENT_SYSRQ = 6,
 
-	/*
-	 * New 64-bit host event.
-	 * The event data is 8 bytes of host event flags.
-	 */
-	EC_MKBP_EVENT_HOST_EVENT64 = 7,
-
 	/* Notify the AP that something happened on CEC */
 	EC_MKBP_EVENT_CEC_EVENT = 8,
 
@@ -3279,98 +2205,66 @@ enum ec_mkbp_event {
 
 	/* Number of MKBP events */
 	EC_MKBP_EVENT_COUNT,
-
-	/*
-	 * Maximum possible event type
-	 * The most significant bit of event type is used to indicate that
-	 * the EC has multiple events for the AP to serve
-	 */
-	EC_MKBP_EVENT_MAX_TYPE = EC_MKBP_EVENT_TYPE_MASK,
 };
 
-union __ec_align_offset1 ec_response_get_next_data {
-	uint8_t key_matrix[13];
+union ec_response_get_next_data {
+	uint8_t   key_matrix[13];
 
 	/* Unaligned */
-	uint32_t host_event;
-	uint64_t host_event64;
+	uint32_t  host_event;
 
 	uint32_t   buttons;
 	uint32_t   switches;
 	uint32_t   sysrq;
-};
+} __packed;
 
-union __ec_align_offset1 ec_response_get_next_data_v1 {
+union ec_response_get_next_data_v1 {
 	uint8_t key_matrix[16];
 	uint32_t host_event;
-
-	struct __ec_todo_unpacked {
-		/* For aligning the fifo_info */
-		uint8_t reserved[3];
-		struct ec_response_motion_sense_fifo_info info;
-	} sensor_fifo;
-
 	uint32_t buttons;
-
 	uint32_t switches;
-
-	uint32_t fp_events;
-
 	uint32_t sysrq;
 	uint32_t cec_events;
 	uint8_t cec_message[16];
-};
+} __packed;
 
-struct __ec_align1 ec_response_get_next_event {
+struct ec_response_get_next_event {
 	uint8_t event_type;
 	/* Followed by event data if any */
 	union ec_response_get_next_data data;
-};
+} __packed;
 
-struct __ec_align1 ec_response_get_next_event_v1 {
+struct ec_response_get_next_event_v1 {
 	uint8_t event_type;
 	/* Followed by event data if any */
 	union ec_response_get_next_data_v1 data;
-};
+} __packed;
 
 /* Bit indices for buttons and switches.*/
 /* Buttons */
 #define EC_MKBP_POWER_BUTTON	0
 #define EC_MKBP_VOL_UP		1
 #define EC_MKBP_VOL_DOWN	2
-#define EC_MKBP_RECOVERY	3
 
 /* Switches */
 #define EC_MKBP_LID_OPEN	0
 #define EC_MKBP_TABLET_MODE	1
-
-/* Run keyboard factory test scanning */
-#define EC_CMD_KEYBOARD_FACTORY_TEST 0x0068
-
-struct __ec_align2 ec_response_keyboard_factory_test {
-	uint16_t shorted;	/* Keyboard pins are shorted */
-};
-
-/* Fingerprint events in 'fp_events' for EC_MKBP_EVENT_FINGERPRINT */
-#define EC_MKBP_FP_RAW_EVENT(fp_events) ((fp_events) & 0x00FFFFFF)
-#define EC_MKBP_FP_FINGER_DOWN          (1 << 29)
-#define EC_MKBP_FP_FINGER_UP            (1 << 30)
-#define EC_MKBP_FP_IMAGE_READY          (1 << 31)
+#define EC_MKBP_BASE_ATTACHED	2
 
 /*****************************************************************************/
 /* Temperature sensor commands */
 
 /* Read temperature sensor info */
-#define EC_CMD_TEMP_SENSOR_GET_INFO 0x0070
+#define EC_CMD_TEMP_SENSOR_GET_INFO 0x70
 
-struct __ec_align1 ec_params_temp_sensor_get_info {
+struct ec_params_temp_sensor_get_info {
 	uint8_t id;
-};
+} __packed;
 
-struct __ec_align1 ec_response_temp_sensor_get_info {
+struct ec_response_temp_sensor_get_info {
 	char sensor_name[32];
 	uint8_t sensor_type;
-};
+} __packed;
 
 /*****************************************************************************/
 
@@ -3383,208 +2277,125 @@ struct __ec_align1 ec_response_temp_sensor_get_info {
 /*****************************************************************************/
 /* Host event commands */
 
-
-/* Obsolete. New implementation should use EC_CMD_HOST_EVENT instead */
 /*
  * Host event mask params and response structures, shared by all of the host
  * event commands below.
  */
-struct __ec_align4 ec_params_host_event_mask {
+struct ec_params_host_event_mask {
 	uint32_t mask;
-};
+} __packed;
 
-struct __ec_align4 ec_response_host_event_mask {
+struct ec_response_host_event_mask {
 	uint32_t mask;
-};
+} __packed;
 
 /* These all use ec_response_host_event_mask */
-#define EC_CMD_HOST_EVENT_GET_B         0x0087
-#define EC_CMD_HOST_EVENT_GET_SMI_MASK  0x0088
-#define EC_CMD_HOST_EVENT_GET_SCI_MASK  0x0089
-#define EC_CMD_HOST_EVENT_GET_WAKE_MASK 0x008D
+#define EC_CMD_HOST_EVENT_GET_B         0x87
+#define EC_CMD_HOST_EVENT_GET_SMI_MASK  0x88
+#define EC_CMD_HOST_EVENT_GET_SCI_MASK  0x89
+#define EC_CMD_HOST_EVENT_GET_WAKE_MASK 0x8d
 
 /* These all use ec_params_host_event_mask */
-#define EC_CMD_HOST_EVENT_SET_SMI_MASK  0x008A
-#define EC_CMD_HOST_EVENT_SET_SCI_MASK  0x008B
-#define EC_CMD_HOST_EVENT_CLEAR         0x008C
-#define EC_CMD_HOST_EVENT_SET_WAKE_MASK 0x008E
-#define EC_CMD_HOST_EVENT_CLEAR_B       0x008F
-
-/*
- * Unified host event programming interface - Should be used by newer versions
- * of BIOS/OS to program host events and masks
- */
-
-struct __ec_align4 ec_params_host_event {
+#define EC_CMD_HOST_EVENT_SET_SMI_MASK  0x8a
+#define EC_CMD_HOST_EVENT_SET_SCI_MASK  0x8b
+#define EC_CMD_HOST_EVENT_CLEAR         0x8c
+#define EC_CMD_HOST_EVENT_SET_WAKE_MASK 0x8e
+#define EC_CMD_HOST_EVENT_CLEAR_B       0x8f
 
-	/* Action requested by host - one of enum ec_host_event_action. */
-	uint8_t action;
+/*****************************************************************************/
+/* Switch commands */
 
-	/*
-	 * Mask type that the host requested the action on - one of
-	 * enum ec_host_event_mask_type.
-	 */
-	uint8_t mask_type;
+/* Enable/disable LCD backlight */
+#define EC_CMD_SWITCH_ENABLE_BKLIGHT 0x90
 
-	/* Set to 0, ignore on read */
-	uint16_t reserved;
+struct ec_params_switch_enable_backlight {
+	uint8_t enabled;
+} __packed;
 
-	/* Value to be used in case of set operations. */
-	uint64_t value;
-};
+/* Enable/disable WLAN/Bluetooth */
+#define EC_CMD_SWITCH_ENABLE_WIRELESS 0x91
+#define EC_VER_SWITCH_ENABLE_WIRELESS 1
 
-/*
- * Response structure returned by EC_CMD_HOST_EVENT.
- * Update the value on a GET request. Set to 0 on GET/CLEAR
- */
+/* Version 0 params; no response */
+struct ec_params_switch_enable_wireless_v0 {
+	uint8_t enabled;
+} __packed;
 
-struct __ec_align4 ec_response_host_event {
+/* Version 1 params */
+struct ec_params_switch_enable_wireless_v1 {
+	/* Flags to enable now */
+	uint8_t now_flags;
 
-	/* Mask value in case of get operation */
-	uint64_t value;
-};
+	/* Which flags to copy from now_flags */
+	uint8_t now_mask;
 
-enum ec_host_event_action {
 	/*
-	 * params.value is ignored. Value of mask_type populated
-	 * in response.value
+	 * Flags to leave enabled in S3, if they're on at the S0->S3
+	 * transition.  (Other flags will be disabled by the S0->S3
+	 * transition.)
 	 */
-	EC_HOST_EVENT_GET,
-
-	/* Bits in params.value are set */
-	EC_HOST_EVENT_SET,
-
-	/* Bits in params.value are cleared */
-	EC_HOST_EVENT_CLEAR,
-};
+	uint8_t suspend_flags;
 
-enum ec_host_event_mask_type {
-
-	/* Main host event copy */
-	EC_HOST_EVENT_MAIN,
-
-	/* Copy B of host events */
-	EC_HOST_EVENT_B,
-
-	/* SCI Mask */
-	EC_HOST_EVENT_SCI_MASK,
-
-	/* SMI Mask */
-	EC_HOST_EVENT_SMI_MASK,
-
-	/* Mask of events that should be always reported in hostevents */
-	EC_HOST_EVENT_ALWAYS_REPORT_MASK,
-
-	/* Active wake mask */
-	EC_HOST_EVENT_ACTIVE_WAKE_MASK,
-
-	/* Lazy wake mask for S0ix */
-	EC_HOST_EVENT_LAZY_WAKE_MASK_S0IX,
-
-	/* Lazy wake mask for S3 */
-	EC_HOST_EVENT_LAZY_WAKE_MASK_S3,
-
-	/* Lazy wake mask for S5 */
-	EC_HOST_EVENT_LAZY_WAKE_MASK_S5,
-};
-
-#define EC_CMD_HOST_EVENT       0x00A4
-
-/*****************************************************************************/
-/* Switch commands */
-
-/* Enable/disable LCD backlight */
-#define EC_CMD_SWITCH_ENABLE_BKLIGHT 0x0090
-
-struct __ec_align1 ec_params_switch_enable_backlight {
-	uint8_t enabled;
-};
-
-/* Enable/disable WLAN/Bluetooth */
-#define EC_CMD_SWITCH_ENABLE_WIRELESS 0x0091
-#define EC_VER_SWITCH_ENABLE_WIRELESS 1
-
-/* Version 0 params; no response */
-struct __ec_align1 ec_params_switch_enable_wireless_v0 {
-	uint8_t enabled;
-};
-
-/* Version 1 params */
-struct __ec_align1 ec_params_switch_enable_wireless_v1 {
-	/* Flags to enable now */
-	uint8_t now_flags;
-
-	/* Which flags to copy from now_flags */
-	uint8_t now_mask;
-
-	/*
-	 * Flags to leave enabled in S3, if they're on at the S0->S3
-	 * transition.  (Other flags will be disabled by the S0->S3
-	 * transition.)
-	 */
-	uint8_t suspend_flags;
-
-	/* Which flags to copy from suspend_flags */
-	uint8_t suspend_mask;
-};
+	/* Which flags to copy from suspend_flags */
+	uint8_t suspend_mask;
+} __packed;
 
 /* Version 1 response */
-struct __ec_align1 ec_response_switch_enable_wireless_v1 {
+struct ec_response_switch_enable_wireless_v1 {
 	/* Flags to enable now */
 	uint8_t now_flags;
 
 	/* Flags to leave enabled in S3 */
 	uint8_t suspend_flags;
-};
+} __packed;
 
 /*****************************************************************************/
 /* GPIO commands. Only available on EC if write protect has been disabled. */
 
 /* Set GPIO output value */
-#define EC_CMD_GPIO_SET 0x0092
+#define EC_CMD_GPIO_SET 0x92
 
-struct __ec_align1 ec_params_gpio_set {
+struct ec_params_gpio_set {
 	char name[32];
 	uint8_t val;
-};
+} __packed;
 
 /* Get GPIO value */
-#define EC_CMD_GPIO_GET 0x0093
+#define EC_CMD_GPIO_GET 0x93
 
 /* Version 0 of input params and response */
-struct __ec_align1 ec_params_gpio_get {
+struct ec_params_gpio_get {
 	char name[32];
-};
-
-struct __ec_align1 ec_response_gpio_get {
+} __packed;
+struct ec_response_gpio_get {
 	uint8_t val;
-};
+} __packed;
 
 /* Version 1 of input params and response */
-struct __ec_align1 ec_params_gpio_get_v1 {
+struct ec_params_gpio_get_v1 {
 	uint8_t subcmd;
 	union {
-		struct __ec_align1 {
+		struct {
 			char name[32];
 		} get_value_by_name;
-		struct __ec_align1 {
+		struct {
 			uint8_t index;
 		} get_info;
 	};
-};
+} __packed;
 
-struct __ec_todo_packed ec_response_gpio_get_v1 {
+struct ec_response_gpio_get_v1 {
 	union {
-		struct __ec_align1 {
+		struct {
 			uint8_t val;
 		} get_value_by_name, get_count;
-		struct __ec_todo_unpacked {
+		struct {
 			uint8_t val;
 			char name[32];
 			uint32_t flags;
 		} get_info;
 	};
-};
+} __packed;
 
 enum gpio_get_subcmd {
 	EC_GPIO_GET_BY_NAME = 0,
@@ -3596,36 +2407,33 @@ enum gpio_get_subcmd {
 /* I2C commands. Only available when flash write protect is unlocked. */
 
 /*
- * CAUTION: These commands are deprecated, and are not supported anymore in EC
- * builds >= 8398.0.0 (see crosbug.com/p/23570).
- *
- * Use EC_CMD_I2C_PASSTHRU instead.
+ * TODO(crosbug.com/p/23570): These commands are deprecated, and will be
+ * removed soon.  Use EC_CMD_I2C_XFER instead.
  */
 
 /* Read I2C bus */
-#define EC_CMD_I2C_READ 0x0094
+#define EC_CMD_I2C_READ 0x94
 
-struct __ec_align_size1 ec_params_i2c_read {
+struct ec_params_i2c_read {
 	uint16_t addr; /* 8-bit address (7-bit shifted << 1) */
 	uint8_t read_size; /* Either 8 or 16. */
 	uint8_t port;
 	uint8_t offset;
-};
-
-struct __ec_align2 ec_response_i2c_read {
+} __packed;
+struct ec_response_i2c_read {
 	uint16_t data;
-};
+} __packed;
 
 /* Write I2C bus */
-#define EC_CMD_I2C_WRITE 0x0095
+#define EC_CMD_I2C_WRITE 0x95
 
-struct __ec_align_size1 ec_params_i2c_write {
+struct ec_params_i2c_write {
 	uint16_t data;
 	uint16_t addr; /* 8-bit address (7-bit shifted << 1) */
 	uint8_t write_size; /* Either 8 or 16. */
 	uint8_t port;
 	uint8_t offset;
-};
+} __packed;
 
 /*****************************************************************************/
 /* Charge state commands. Only available when flash write protect unlocked. */
@@ -3633,7 +2441,7 @@ struct __ec_align_size1 ec_params_i2c_write {
 /* Force charge state machine to stop charging the battery or force it to
  * discharge the battery.
  */
-#define EC_CMD_CHARGE_CONTROL 0x0096
+#define EC_CMD_CHARGE_CONTROL 0x96
 #define EC_VER_CHARGE_CONTROL 1
 
 enum ec_charge_control_mode {
@@ -3642,15 +2450,15 @@ enum ec_charge_control_mode {
 	CHARGE_CONTROL_DISCHARGE,
 };
 
-struct __ec_align4 ec_params_charge_control {
+struct ec_params_charge_control {
 	uint32_t mode;  /* enum charge_control_mode */
-};
+} __packed;
 
 /*****************************************************************************/
 /* Console commands. Only available when flash write protect is unlocked. */
 
 /* Snapshot console output buffer for use by EC_CMD_CONSOLE_READ. */
-#define EC_CMD_CONSOLE_SNAPSHOT 0x0097
+#define EC_CMD_CONSOLE_SNAPSHOT 0x97
 
 /*
  * Read data from the saved snapshot. If the subcmd parameter is
@@ -3664,16 +2472,16 @@ struct __ec_align4 ec_params_charge_control {
  * Response is null-terminated string.  Empty string, if there is no more
  * remaining output.
  */
-#define EC_CMD_CONSOLE_READ 0x0098
+#define EC_CMD_CONSOLE_READ 0x98
 
 enum ec_console_read_subcmd {
 	CONSOLE_READ_NEXT = 0,
 	CONSOLE_READ_RECENT
 };
 
-struct __ec_align1 ec_params_console_read_v1 {
+struct ec_params_console_read_v1 {
 	uint8_t subcmd; /* enum ec_console_read_subcmd */
-};
+} __packed;
 
 /*****************************************************************************/
 
@@ -3684,13 +2492,14 @@ struct __ec_align1 ec_params_console_read_v1 {
  *	  EC_RES_SUCCESS if the command was successful.
  *	  EC_RES_ERROR if the cut off command failed.
  */
-#define EC_CMD_BATTERY_CUT_OFF 0x0099
+
+#define EC_CMD_BATTERY_CUT_OFF 0x99
 
 #define EC_BATTERY_CUTOFF_FLAG_AT_SHUTDOWN	(1 << 0)
 
-struct __ec_align1 ec_params_battery_cutoff {
+struct ec_params_battery_cutoff {
 	uint8_t flags;
-};
+} __packed;
 
 /*****************************************************************************/
 /* USB port mux control. */
@@ -3698,11 +2507,11 @@ struct __ec_align1 ec_params_battery_cutoff {
 /*
  * Switch USB mux or return to automatic switching.
  */
-#define EC_CMD_USB_MUX 0x009A
+#define EC_CMD_USB_MUX 0x9a
 
-struct __ec_align1 ec_params_usb_mux {
+struct ec_params_usb_mux {
 	uint8_t mux;
-};
+} __packed;
 
 /*****************************************************************************/
 /* LDOs / FETs control. */
@@ -3715,25 +2524,25 @@ enum ec_ldo_state {
 /*
  * Switch on/off a LDO.
  */
-#define EC_CMD_LDO_SET 0x009B
+#define EC_CMD_LDO_SET 0x9b
 
-struct __ec_align1 ec_params_ldo_set {
+struct ec_params_ldo_set {
 	uint8_t index;
 	uint8_t state;
-};
+} __packed;
 
 /*
  * Get LDO state.
  */
-#define EC_CMD_LDO_GET 0x009C
+#define EC_CMD_LDO_GET 0x9c
 
-struct __ec_align1 ec_params_ldo_get {
+struct ec_params_ldo_get {
 	uint8_t index;
-};
+} __packed;
 
-struct __ec_align1 ec_response_ldo_get {
+struct ec_response_ldo_get {
 	uint8_t state;
-};
+} __packed;
 
 /*****************************************************************************/
 /* Power info. */
@@ -3741,20 +2550,20 @@ struct __ec_align1 ec_response_ldo_get {
 /*
  * Get power info.
  */
-#define EC_CMD_POWER_INFO 0x009D
+#define EC_CMD_POWER_INFO 0x9d
 
-struct __ec_align4 ec_response_power_info {
+struct ec_response_power_info {
 	uint32_t usb_dev_type;
 	uint16_t voltage_ac;
 	uint16_t voltage_system;
 	uint16_t current_system;
 	uint16_t usb_current_limit;
-};
+} __packed;
 
 /*****************************************************************************/
 /* I2C passthru command */
 
-#define EC_CMD_I2C_PASSTHRU 0x009E
+#define EC_CMD_I2C_PASSTHRU 0x9e
 
 /* Read data; if not present, message is a write */
 #define EC_I2C_FLAG_READ	(1 << 15)
@@ -3768,28 +2577,28 @@ struct __ec_align4 ec_response_power_info {
 /* Any error */
 #define EC_I2C_STATUS_ERROR	(EC_I2C_STATUS_NAK | EC_I2C_STATUS_TIMEOUT)
 
-struct __ec_align2 ec_params_i2c_passthru_msg {
+struct ec_params_i2c_passthru_msg {
 	uint16_t addr_flags;	/* I2C slave address (7 or 10 bits) and flags */
 	uint16_t len;		/* Number of bytes to read or write */
-};
+} __packed;
 
-struct __ec_align2 ec_params_i2c_passthru {
+struct ec_params_i2c_passthru {
 	uint8_t port;		/* I2C port number */
 	uint8_t num_msgs;	/* Number of messages */
 	struct ec_params_i2c_passthru_msg msg[];
 	/* Data to write for all messages is concatenated here */
-};
+} __packed;
 
-struct __ec_align1 ec_response_i2c_passthru {
+struct ec_response_i2c_passthru {
 	uint8_t i2c_status;	/* Status flags (EC_I2C_STATUS_...) */
 	uint8_t num_msgs;	/* Number of messages processed */
 	uint8_t data[];		/* Data read by messages concatenated here */
-};
+} __packed;
 
 /*****************************************************************************/
 /* Power button hang detect */
 
-#define EC_CMD_HANG_DETECT 0x009F
+#define EC_CMD_HANG_DETECT 0x9f
 
 /* Reasons to start hang detection timer */
 /* Power button pressed */
@@ -3830,7 +2639,7 @@ struct __ec_align1 ec_response_i2c_passthru {
  */
 #define EC_HANG_STOP_NOW              (1 << 31)
 
-struct __ec_align4 ec_params_hang_detect {
+struct ec_params_hang_detect {
 	/* Flags; see EC_HANG_* */
 	uint32_t flags;
 
@@ -3839,7 +2648,7 @@ struct __ec_align4 ec_params_hang_detect {
 
 	/* Timeout in msec before generating warm reboot, if enabled */
 	uint16_t warm_reboot_timeout_msec;
-};
+} __packed;
 
 /*****************************************************************************/
 /* Commands for battery charging */
@@ -3848,7 +2657,7 @@ struct __ec_align4 ec_params_hang_detect {
  * This is the single catch-all host command to exchange data regarding the
  * charge state machine (v2 and up).
  */
-#define EC_CMD_CHARGE_STATE 0x00A0
+#define EC_CMD_CHARGE_STATE 0xa0
 
 /* Subcommands for this host command */
 enum charge_state_command {
@@ -3868,11 +2677,6 @@ enum charge_state_params {
 	CS_PARAM_CHG_INPUT_CURRENT,   /* charger input current limit */
 	CS_PARAM_CHG_STATUS,	      /* charger-specific status */
 	CS_PARAM_CHG_OPTION,	      /* charger-specific options */
-	CS_PARAM_LIMIT_POWER,	      /*
-				       * Check if power is limited due to
-				       * low battery and / or a weak external
-				       * charger. READ ONLY.
-				       */
 	/* How many so far? */
 	CS_NUM_BASE_PARAMS,
 
@@ -3880,37 +2684,30 @@ enum charge_state_params {
 	CS_PARAM_CUSTOM_PROFILE_MIN = 0x10000,
 	CS_PARAM_CUSTOM_PROFILE_MAX = 0x1ffff,
 
-	/* Range for CONFIG_CHARGE_STATE_DEBUG params */
-	CS_PARAM_DEBUG_MIN = 0x20000,
-	CS_PARAM_DEBUG_CTL_MODE = 0x20000,
-	CS_PARAM_DEBUG_MANUAL_MODE,
-	CS_PARAM_DEBUG_SEEMS_DEAD,
-	CS_PARAM_DEBUG_SEEMS_DISCONNECTED,
-	CS_PARAM_DEBUG_BATT_REMOVED,
-	CS_PARAM_DEBUG_MAX = 0x2ffff,
-
 	/* Other custom param ranges go here... */
 };
 
-struct __ec_todo_packed ec_params_charge_state {
+struct ec_params_charge_state {
 	uint8_t cmd;				/* enum charge_state_command */
 	union {
-		/* get_state has no args */
+		struct {
+			/* no args */
+		} get_state;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint32_t param;		/* enum charge_state_param */
 		} get_param;
 
-		struct __ec_todo_unpacked {
+		struct {
 			uint32_t param;		/* param to set */
 			uint32_t value;		/* value to set */
 		} set_param;
 	};
-};
+} __packed;
 
-struct __ec_align4 ec_response_charge_state {
+struct ec_response_charge_state {
 	union {
-		struct __ec_align4 {
+		struct {
 			int ac;
 			int chg_voltage;
 			int chg_current;
@@ -3918,23 +2715,24 @@ struct __ec_align4 ec_response_charge_state {
 			int batt_state_of_charge;
 		} get_state;
 
-		struct __ec_align4 {
+		struct {
 			uint32_t value;
 		} get_param;
-
-		/* set_param returns no args */
+		struct {
+			/* no return values */
+		} set_param;
 	};
-};
+} __packed;
 
 
 /*
  * Set maximum battery charging current.
  */
-#define EC_CMD_CHARGE_CURRENT_LIMIT 0x00A1
+#define EC_CMD_CHARGE_CURRENT_LIMIT 0xa1
 
-struct __ec_align4 ec_params_current_limit {
+struct ec_params_current_limit {
 	uint32_t limit; /* in mA */
-};
+} __packed;
 
 /*
  * Set maximum external voltage / current.
@@ -3942,102 +2740,26 @@ struct __ec_align4 ec_params_current_limit {
 #define EC_CMD_EXTERNAL_POWER_LIMIT 0x00A2
 
 /* Command v0 is used only on Spring and is obsolete + unsupported */
-struct __ec_align2 ec_params_external_power_limit_v1 {
+struct ec_params_external_power_limit_v1 {
 	uint16_t current_lim; /* in mA, or EC_POWER_LIMIT_NONE to clear limit */
 	uint16_t voltage_lim; /* in mV, or EC_POWER_LIMIT_NONE to clear limit */
-};
+} __packed;
 
 #define EC_POWER_LIMIT_NONE 0xffff
 
-/*
- * Set maximum voltage & current of a dedicated charge port
- */
-#define EC_CMD_OVERRIDE_DEDICATED_CHARGER_LIMIT 0x00A3
-
-struct __ec_align2 ec_params_dedicated_charger_limit {
-	uint16_t current_lim; /* in mA */
-	uint16_t voltage_lim; /* in mV */
-};
-
-/*****************************************************************************/
-/* Hibernate/Deep Sleep Commands */
-
-/* Set the delay before going into hibernation. */
-#define EC_CMD_HIBERNATION_DELAY 0x00A8
-
-struct __ec_align4 ec_params_hibernation_delay {
-	/*
-	 * Seconds to wait in G3 before hibernate.  Pass in 0 to read the
-	 * current settings without changing them.
-	 */
-	uint32_t seconds;
-};
-
-struct __ec_align4 ec_response_hibernation_delay {
-	/*
-	 * The current time in seconds in which the system has been in the G3
-	 * state.  This value is reset if the EC transitions out of G3.
-	 */
-	uint32_t time_g3;
-
-	/*
-	 * The current time remaining in seconds until the EC should hibernate.
-	 * This value is also reset if the EC transitions out of G3.
-	 */
-	uint32_t time_remaining;
-
-	/*
-	 * The current time in seconds that the EC should wait in G3 before
-	 * hibernating.
-	 */
-	uint32_t hibernate_delay;
-};
-
 /* Inform the EC when entering a sleep state */
-#define EC_CMD_HOST_SLEEP_EVENT 0x00A9
+#define EC_CMD_HOST_SLEEP_EVENT 0xa9
 
 enum host_sleep_event {
 	HOST_SLEEP_EVENT_S3_SUSPEND   = 1,
 	HOST_SLEEP_EVENT_S3_RESUME    = 2,
 	HOST_SLEEP_EVENT_S0IX_SUSPEND = 3,
-	HOST_SLEEP_EVENT_S0IX_RESUME  = 4,
-	/* S3 suspend with additional enabled wake sources */
-	HOST_SLEEP_EVENT_S3_WAKEABLE_SUSPEND = 5,
+	HOST_SLEEP_EVENT_S0IX_RESUME  = 4
 };
 
-struct __ec_align1 ec_params_host_sleep_event {
+struct ec_params_host_sleep_event {
 	uint8_t sleep_event;
-};
-
-/*****************************************************************************/
-/* Device events */
-#define EC_CMD_DEVICE_EVENT 0x00AA
-
-enum ec_device_event {
-	EC_DEVICE_EVENT_TRACKPAD,
-	EC_DEVICE_EVENT_DSP,
-	EC_DEVICE_EVENT_WIFI,
-};
-
-enum ec_device_event_param {
-	/* Get and clear pending device events */
-	EC_DEVICE_EVENT_PARAM_GET_CURRENT_EVENTS,
-	/* Get device event mask */
-	EC_DEVICE_EVENT_PARAM_GET_ENABLED_EVENTS,
-	/* Set device event mask */
-	EC_DEVICE_EVENT_PARAM_SET_ENABLED_EVENTS,
-};
-
-#define EC_DEVICE_EVENT_MASK(event_code) (1UL << (event_code % 32))
-
-struct __ec_align_size1 ec_params_device_event {
-	uint32_t event_mask;
-	uint8_t param;
-};
-
-struct __ec_align4 ec_response_device_event {
-	uint32_t event_mask;
-};
+} __packed;
 
 /*
  * Use a default timeout value (CONFIG_SLEEP_TIMEOUT_MS) for detecting sleep
@@ -4100,36 +2822,36 @@ struct ec_response_host_sleep_event_v1 {
 /* Smart battery pass-through */
 
 /* Get / Set 16-bit smart battery registers */
-#define EC_CMD_SB_READ_WORD   0x00B0
-#define EC_CMD_SB_WRITE_WORD  0x00B1
+#define EC_CMD_SB_READ_WORD   0xb0
+#define EC_CMD_SB_WRITE_WORD  0xb1
 
 /* Get / Set string smart battery parameters
  * formatted as SMBUS "block".
  */
-#define EC_CMD_SB_READ_BLOCK  0x00B2
-#define EC_CMD_SB_WRITE_BLOCK 0x00B3
+#define EC_CMD_SB_READ_BLOCK  0xb2
+#define EC_CMD_SB_WRITE_BLOCK 0xb3
 
-struct __ec_align1 ec_params_sb_rd {
+struct ec_params_sb_rd {
 	uint8_t reg;
-};
+} __packed;
 
-struct __ec_align2 ec_response_sb_rd_word {
+struct ec_response_sb_rd_word {
 	uint16_t value;
-};
+} __packed;
 
-struct __ec_align1 ec_params_sb_wr_word {
+struct ec_params_sb_wr_word {
 	uint8_t reg;
 	uint16_t value;
-};
+} __packed;
 
-struct __ec_align1 ec_response_sb_rd_block {
+struct ec_response_sb_rd_block {
 	uint8_t data[32];
-};
+} __packed;
 
-struct __ec_align1 ec_params_sb_wr_block {
+struct ec_params_sb_wr_block {
 	uint8_t reg;
 	uint16_t data[32];
-};
+} __packed;
 
 /*****************************************************************************/
 /* Battery vendor parameters
@@ -4140,116 +2862,22 @@ struct __ec_align1 ec_params_sb_wr_block {
  * requested value.
  */
 
-#define EC_CMD_BATTERY_VENDOR_PARAM 0x00B4
+#define EC_CMD_BATTERY_VENDOR_PARAM 0xb4
 
 enum ec_battery_vendor_param_mode {
 	BATTERY_VENDOR_PARAM_MODE_GET = 0,
 	BATTERY_VENDOR_PARAM_MODE_SET,
 };
 
-struct __ec_align_size1 ec_params_battery_vendor_param {
+struct ec_params_battery_vendor_param {
 	uint32_t param;
 	uint32_t value;
 	uint8_t mode;
-};
+} __packed;
 
-struct __ec_align4 ec_response_battery_vendor_param {
+struct ec_response_battery_vendor_param {
 	uint32_t value;
-};
-
-/*****************************************************************************/
-/*
- * Smart Battery Firmware Update Commands
- */
-#define EC_CMD_SB_FW_UPDATE 0x00B5
-
-enum ec_sb_fw_update_subcmd {
-	EC_SB_FW_UPDATE_PREPARE  = 0x0,
-	EC_SB_FW_UPDATE_INFO     = 0x1, /*query sb info */
-	EC_SB_FW_UPDATE_BEGIN    = 0x2, /*check if protected */
-	EC_SB_FW_UPDATE_WRITE    = 0x3, /*check if protected */
-	EC_SB_FW_UPDATE_END      = 0x4,
-	EC_SB_FW_UPDATE_STATUS   = 0x5,
-	EC_SB_FW_UPDATE_PROTECT  = 0x6,
-	EC_SB_FW_UPDATE_MAX      = 0x7,
-};
-
-#define SB_FW_UPDATE_CMD_WRITE_BLOCK_SIZE 32
-#define SB_FW_UPDATE_CMD_STATUS_SIZE 2
-#define SB_FW_UPDATE_CMD_INFO_SIZE 8
-
-struct __ec_align4 ec_sb_fw_update_header {
-	uint16_t subcmd;  /* enum ec_sb_fw_update_subcmd */
-	uint16_t fw_id;   /* firmware id */
-};
-
-struct __ec_align4 ec_params_sb_fw_update {
-	struct ec_sb_fw_update_header hdr;
-	union {
-		/* EC_SB_FW_UPDATE_PREPARE  = 0x0 */
-		/* EC_SB_FW_UPDATE_INFO     = 0x1 */
-		/* EC_SB_FW_UPDATE_BEGIN    = 0x2 */
-		/* EC_SB_FW_UPDATE_END      = 0x4 */
-		/* EC_SB_FW_UPDATE_STATUS   = 0x5 */
-		/* EC_SB_FW_UPDATE_PROTECT  = 0x6 */
-		/* Those have no args */
-
-		/* EC_SB_FW_UPDATE_WRITE    = 0x3 */
-		struct __ec_align4 {
-			uint8_t  data[SB_FW_UPDATE_CMD_WRITE_BLOCK_SIZE];
-		} write;
-	};
-};
-
-struct __ec_align1 ec_response_sb_fw_update {
-	union {
-		/* EC_SB_FW_UPDATE_INFO     = 0x1 */
-		struct __ec_align1 {
-			uint8_t data[SB_FW_UPDATE_CMD_INFO_SIZE];
-		} info;
-
-		/* EC_SB_FW_UPDATE_STATUS   = 0x5 */
-		struct __ec_align1 {
-			uint8_t data[SB_FW_UPDATE_CMD_STATUS_SIZE];
-		} status;
-	};
-};
-
-/*
- * Entering Verified Boot Mode Command
- * Default mode is VBOOT_MODE_NORMAL if EC did not receive this command.
- * Valid Modes are: normal, developer, and recovery.
- */
-#define EC_CMD_ENTERING_MODE 0x00B6
-
-struct __ec_align4 ec_params_entering_mode {
-	int vboot_mode;
-};
-
-#define VBOOT_MODE_NORMAL    0
-#define VBOOT_MODE_DEVELOPER 1
-#define VBOOT_MODE_RECOVERY  2
-
-/*****************************************************************************/
-/*
- * I2C passthru protection command: Protects I2C tunnels against access on
- * certain addresses (board-specific).
- */
-#define EC_CMD_I2C_PASSTHRU_PROTECT 0x00B7
-
-enum ec_i2c_passthru_protect_subcmd {
-	EC_CMD_I2C_PASSTHRU_PROTECT_STATUS = 0x0,
-	EC_CMD_I2C_PASSTHRU_PROTECT_ENABLE = 0x1,
-};
-
-struct __ec_align1 ec_params_i2c_passthru_protect {
-	uint8_t subcmd;
-	uint8_t port;		/* I2C port number */
-};
-
-struct __ec_align1 ec_response_i2c_passthru_protect {
-	uint8_t status;		/* Status flags (0: unlocked, 1: locked) */
-};
+} __packed;
 
 /*****************************************************************************/
 /* Commands for I2S recording on audio codec. */
@@ -4352,29 +2980,27 @@ struct ec_response_codec_gain {
  * TODO(crosbug.com/p/23747): This is a confusing name, since it doesn't
  * necessarily reboot the EC.  Rename to "image" or something similar?
  */
-#define EC_CMD_REBOOT_EC 0x00D2
+#define EC_CMD_REBOOT_EC 0xd2
 
 /* Command */
 enum ec_reboot_cmd {
 	EC_REBOOT_CANCEL = 0,        /* Cancel a pending reboot */
 	EC_REBOOT_JUMP_RO = 1,       /* Jump to RO without rebooting */
-	EC_REBOOT_JUMP_RW = 2,       /* Jump to active RW without rebooting */
+	EC_REBOOT_JUMP_RW = 2,       /* Jump to RW without rebooting */
 	/* (command 3 was jump to RW-B) */
 	EC_REBOOT_COLD = 4,          /* Cold-reboot */
 	EC_REBOOT_DISABLE_JUMP = 5,  /* Disable jump until next reboot */
-	EC_REBOOT_HIBERNATE = 6,     /* Hibernate EC */
-	EC_REBOOT_HIBERNATE_CLEAR_AP_OFF = 7, /* and clears AP_OFF flag */
+	EC_REBOOT_HIBERNATE = 6      /* Hibernate EC */
 };
 
 /* Flags for ec_params_reboot_ec.reboot_flags */
 #define EC_REBOOT_FLAG_RESERVED0      (1 << 0)  /* Was recovery request */
 #define EC_REBOOT_FLAG_ON_AP_SHUTDOWN (1 << 1)  /* Reboot after AP shutdown */
-#define EC_REBOOT_FLAG_SWITCH_RW_SLOT (1 << 2)  /* Switch RW slot */
 
-struct __ec_align1 ec_params_reboot_ec {
+struct ec_params_reboot_ec {
 	uint8_t cmd;           /* enum ec_reboot_cmd */
 	uint8_t flags;         /* See EC_REBOOT_FLAG_* */
-};
+} __packed;
 
 /*
  * Get information on last EC panic.
@@ -4382,7 +3008,123 @@ struct __ec_align1 ec_params_reboot_ec {
  * Returns variable-length platform-dependent panic information.  See panic.h
  * for details.
  */
-#define EC_CMD_GET_PANIC_INFO 0x00D3
+#define EC_CMD_GET_PANIC_INFO 0xd3
+
+/*****************************************************************************/
+/*
+ * ACPI commands
+ *
+ * These are valid ONLY on the ACPI command/data port.
+ */
+
+/*
+ * ACPI Read Embedded Controller
+ *
+ * This reads from ACPI memory space on the EC (EC_ACPI_MEM_*).
+ *
+ * Use the following sequence:
+ *
+ *    - Write EC_CMD_ACPI_READ to EC_LPC_ADDR_ACPI_CMD
+ *    - Wait for EC_LPC_CMDR_PENDING bit to clear
+ *    - Write address to EC_LPC_ADDR_ACPI_DATA
+ *    - Wait for EC_LPC_CMDR_DATA bit to set
+ *    - Read value from EC_LPC_ADDR_ACPI_DATA
+ */
+#define EC_CMD_ACPI_READ 0x80
+
+/*
+ * ACPI Write Embedded Controller
+ *
+ * This reads from ACPI memory space on the EC (EC_ACPI_MEM_*).
+ *
+ * Use the following sequence:
+ *
+ *    - Write EC_CMD_ACPI_WRITE to EC_LPC_ADDR_ACPI_CMD
+ *    - Wait for EC_LPC_CMDR_PENDING bit to clear
+ *    - Write address to EC_LPC_ADDR_ACPI_DATA
+ *    - Wait for EC_LPC_CMDR_PENDING bit to clear
+ *    - Write value to EC_LPC_ADDR_ACPI_DATA
+ */
+#define EC_CMD_ACPI_WRITE 0x81
+
+/*
+ * ACPI Query Embedded Controller
+ *
+ * This clears the lowest-order bit in the currently pending host events, and
+ * sets the result code to the 1-based index of the bit (event 0x00000001 = 1,
+ * event 0x80000000 = 32), or 0 if no event was pending.
+ */
+#define EC_CMD_ACPI_QUERY_EVENT 0x84
+
+/* Valid addresses in ACPI memory space, for read/write commands */
+
+/* Memory space version; set to EC_ACPI_MEM_VERSION_CURRENT */
+#define EC_ACPI_MEM_VERSION            0x00
+/*
+ * Test location; writing value here updates test compliment byte to (0xff -
+ * value).
+ */
+#define EC_ACPI_MEM_TEST               0x01
+/* Test compliment; writes here are ignored. */
+#define EC_ACPI_MEM_TEST_COMPLIMENT    0x02
+
+/* Keyboard backlight brightness percent (0 - 100) */
+#define EC_ACPI_MEM_KEYBOARD_BACKLIGHT 0x03
+/* DPTF Target Fan Duty (0-100, 0xff for auto/none) */
+#define EC_ACPI_MEM_FAN_DUTY           0x04
+
+/*
+ * DPTF temp thresholds. Any of the EC's temp sensors can have up to two
+ * independent thresholds attached to them. The current value of the ID
+ * register determines which sensor is affected by the THRESHOLD and COMMIT
+ * registers. The THRESHOLD register uses the same EC_TEMP_SENSOR_OFFSET scheme
+ * as the memory-mapped sensors. The COMMIT register applies those settings.
+ *
+ * The spec does not mandate any way to read back the threshold settings
+ * themselves, but when a threshold is crossed the AP needs a way to determine
+ * which sensor(s) are responsible. Each reading of the ID register clears and
+ * returns one sensor ID that has crossed one of its threshold (in either
+ * direction) since the last read. A value of 0xFF means "no new thresholds
+ * have tripped". Setting or enabling the thresholds for a sensor will clear
+ * the unread event count for that sensor.
+ */
+#define EC_ACPI_MEM_TEMP_ID            0x05
+#define EC_ACPI_MEM_TEMP_THRESHOLD     0x06
+#define EC_ACPI_MEM_TEMP_COMMIT        0x07
+/*
+ * Here are the bits for the COMMIT register:
+ *   bit 0 selects the threshold index for the chosen sensor (0/1)
+ *   bit 1 enables/disables the selected threshold (0 = off, 1 = on)
+ * Each write to the commit register affects one threshold.
+ */
+#define EC_ACPI_MEM_TEMP_COMMIT_SELECT_MASK (1 << 0)
+#define EC_ACPI_MEM_TEMP_COMMIT_ENABLE_MASK (1 << 1)
+/*
+ * Example:
+ *
+ * Set the thresholds for sensor 2 to 50 C and 60 C:
+ *   write 2 to [0x05]      --  select temp sensor 2
+ *   write 0x7b to [0x06]   --  C_TO_K(50) - EC_TEMP_SENSOR_OFFSET
+ *   write 0x2 to [0x07]    --  enable threshold 0 with this value
+ *   write 0x85 to [0x06]   --  C_TO_K(60) - EC_TEMP_SENSOR_OFFSET
+ *   write 0x3 to [0x07]    --  enable threshold 1 with this value
+ *
+ * Disable the 60 C threshold, leaving the 50 C threshold unchanged:
+ *   write 2 to [0x05]      --  select temp sensor 2
+ *   write 0x1 to [0x07]    --  disable threshold 1
+ */
+
+/* DPTF battery charging current limit */
+#define EC_ACPI_MEM_CHARGING_LIMIT     0x08
+
+/* Charging limit is specified in 64 mA steps */
+#define EC_ACPI_MEM_CHARGING_LIMIT_STEP_MA   64
+/* Value to disable DPTF battery charging limit */
+#define EC_ACPI_MEM_CHARGING_LIMIT_DISABLED  0xff
+
+/* Current version of ACPI memory address space */
+#define EC_ACPI_MEM_VERSION_CURRENT 1
+
 
 /*****************************************************************************/
 /*
@@ -4474,7 +3216,7 @@ enum mkbp_cec_event {
  *
  * Use EC_CMD_REBOOT_EC to reboot the EC more politely.
  */
-#define EC_CMD_REBOOT 0x00D1  /* Think "die" */
+#define EC_CMD_REBOOT 0xd1  /* Think "die" */
 
 /*
  * Resend last response (not supported on LPC).
@@ -4483,7 +3225,7 @@ enum mkbp_cec_event {
  * there was no previous command, or the previous command's response was too
  * big to save.
  */
-#define EC_CMD_RESEND_RESPONSE 0x00DB
+#define EC_CMD_RESEND_RESPONSE 0xdb
 
 /*
  * This header byte on a command indicate version 0. Any header byte less
@@ -4495,7 +3237,9 @@ enum mkbp_cec_event {
  *
  * The old EC interface must not use commands 0xdc or higher.
  */
-#define EC_CMD_VERSION0 0x00DC
+#define EC_CMD_VERSION0 0xdc
+
+#endif  /* !__ACPI__ */
 
 /*****************************************************************************/
 /*
@@ -4505,44 +3249,21 @@ enum mkbp_cec_event {
  */
 
 /* EC to PD MCU exchange status command */
-#define EC_CMD_PD_EXCHANGE_STATUS 0x0100
-#define EC_VER_PD_EXCHANGE_STATUS 2
-
-enum pd_charge_state {
-	PD_CHARGE_NO_CHANGE = 0, /* Don't change charge state */
-	PD_CHARGE_NONE,          /* No charging allowed */
-	PD_CHARGE_5V,            /* 5V charging only */
-	PD_CHARGE_MAX            /* Charge at max voltage */
-};
+#define EC_CMD_PD_EXCHANGE_STATUS 0x100
 
 /* Status of EC being sent to PD */
-#define EC_STATUS_HIBERNATING	(1 << 0)
-
-struct __ec_align1 ec_params_pd_status {
-	uint8_t status;       /* EC status */
-	int8_t batt_soc;      /* battery state of charge */
-	uint8_t charge_state; /* charging state (from enum pd_charge_state) */
-};
+struct ec_params_pd_status {
+	int8_t batt_soc; /* battery state of charge */
+} __packed;
 
 /* Status of PD being sent back to EC */
-#define PD_STATUS_HOST_EVENT      (1 << 0) /* Forward host event to AP */
-#define PD_STATUS_IN_RW           (1 << 1) /* Running RW image */
-#define PD_STATUS_JUMPED_TO_IMAGE (1 << 2) /* Current image was jumped to */
-#define PD_STATUS_TCPC_ALERT_0    (1 << 3) /* Alert active in port 0 TCPC */
-#define PD_STATUS_TCPC_ALERT_1    (1 << 4) /* Alert active in port 1 TCPC */
-#define PD_STATUS_TCPC_ALERT_2    (1 << 5) /* Alert active in port 2 TCPC */
-#define PD_STATUS_TCPC_ALERT_3    (1 << 6) /* Alert active in port 3 TCPC */
-#define PD_STATUS_EC_INT_ACTIVE  (PD_STATUS_TCPC_ALERT_0 | \
-				      PD_STATUS_TCPC_ALERT_1 | \
-				      PD_STATUS_HOST_EVENT)
-struct __ec_align_size1 ec_response_pd_status {
-	uint32_t curr_lim_ma;       /* input current limit */
-	uint16_t status;            /* PD MCU status */
-	int8_t active_charge_port;  /* active charging port */
-};
+struct ec_response_pd_status {
+	int8_t status;        /* PD MCU status */
+	uint32_t curr_lim_ma; /* input current limit */
+} __packed;
 
 /* Set USB type-C port role and muxes */
-#define EC_CMD_USB_PD_CONTROL 0x0101
+#define EC_CMD_USB_PD_CONTROL 0x101
 
 enum usb_pd_control_role {
 	USB_PD_CTRL_ROLE_NO_CHANGE = 0,
@@ -4550,8 +3271,6 @@ enum usb_pd_control_role {
 	USB_PD_CTRL_ROLE_TOGGLE_OFF = 2,
 	USB_PD_CTRL_ROLE_FORCE_SINK = 3,
 	USB_PD_CTRL_ROLE_FORCE_SOURCE = 4,
-	USB_PD_CTRL_ROLE_FREEZE = 5,
-	USB_PD_CTRL_ROLE_COUNT
 };
 
 enum usb_pd_control_mux {
@@ -4561,7 +3280,6 @@ enum usb_pd_control_mux {
 	USB_PD_CTRL_MUX_DP = 3,
 	USB_PD_CTRL_MUX_DOCK = 4,
 	USB_PD_CTRL_MUX_AUTO = 5,
-	USB_PD_CTRL_MUX_COUNT
 };
 
 enum usb_pd_control_swap {
@@ -4572,12 +3290,12 @@ enum usb_pd_control_swap {
 	USB_PD_CTRL_SWAP_COUNT
 };
 
-struct __ec_align1 ec_params_usb_pd_control {
+struct ec_params_usb_pd_control {
 	uint8_t port;
 	uint8_t role;
 	uint8_t mux;
 	uint8_t swap;
-};
+} __packed;
 
 #define PD_CTRL_RESP_ENABLED_COMMS      (1 << 0) /* Communication enabled */
 #define PD_CTRL_RESP_ENABLED_CONNECTED  (1 << 1) /* Device connected */
@@ -4591,28 +3309,28 @@ struct __ec_align1 ec_params_usb_pd_control {
 #define PD_CTRL_RESP_ROLE_USB_COMM      BIT(5) /* Partner USB comm capable */
 #define PD_CTRL_RESP_ROLE_EXT_POWERED   BIT(6) /* Partner externally powerd */
 
-struct __ec_align1 ec_response_usb_pd_control_v1 {
+struct ec_response_usb_pd_control_v1 {
 	uint8_t enabled;
 	uint8_t role;
 	uint8_t polarity;
 	char state[32];
-};
+} __packed;
 
-#define EC_CMD_USB_PD_PORTS 0x0102
+#define EC_CMD_USB_PD_PORTS 0x102
 
 /* Maximum number of PD ports on a device, num_ports will be <= this */
 #define EC_USB_PD_MAX_PORTS 8
 
-struct __ec_align1 ec_response_usb_pd_ports {
+struct ec_response_usb_pd_ports {
 	uint8_t num_ports;
-};
+} __packed;
 
-#define EC_CMD_USB_PD_POWER_INFO 0x0103
+#define EC_CMD_USB_PD_POWER_INFO 0x103
 
 #define PD_POWER_CHARGING_PORT 0xff
-struct __ec_align1 ec_params_usb_pd_power_info {
+struct ec_params_usb_pd_power_info {
 	uint8_t port;
-};
+} __packed;
 
 enum usb_chg_type {
 	USB_CHG_TYPE_NONE,
@@ -4625,7 +3343,6 @@ enum usb_chg_type {
 	USB_CHG_TYPE_OTHER,
 	USB_CHG_TYPE_VBUS,
 	USB_CHG_TYPE_UNKNOWN,
-	USB_CHG_TYPE_DEDICATED,
 };
 enum usb_power_roles {
 	USB_PD_PORT_POWER_DISCONNECTED,
@@ -4634,79 +3351,43 @@ enum usb_power_roles {
 	USB_PD_PORT_POWER_SINK_NOT_CHARGING,
 };
 
-struct __ec_align2 usb_chg_measures {
+struct usb_chg_measures {
 	uint16_t voltage_max;
 	uint16_t voltage_now;
 	uint16_t current_max;
 	uint16_t current_lim;
-};
+} __packed;
 
-struct __ec_align4 ec_response_usb_pd_power_info {
+struct ec_response_usb_pd_power_info {
 	uint8_t role;
 	uint8_t type;
 	uint8_t dualrole;
 	uint8_t reserved1;
 	struct usb_chg_measures meas;
 	uint32_t max_power;
-};
-
-/* AP to PD MCU host event status command, cleared on read */
-#define EC_CMD_PD_HOST_EVENT_STATUS 0x0104
-
-/* PD MCU host event status bits */
-#define PD_EVENT_UPDATE_DEVICE     (1 << 0)
-#define PD_EVENT_POWER_CHANGE      (1 << 1)
-#define PD_EVENT_IDENTITY_RECEIVED (1 << 2)
-#define PD_EVENT_DATA_SWAP         (1 << 3)
-struct __ec_align4 ec_response_host_event_status {
-	uint32_t status;      /* PD MCU host event status */
-};
-
-/* Write USB-PD device FW */
-#define EC_CMD_USB_PD_FW_UPDATE 0x0110
-
-enum usb_pd_fw_update_cmds {
-	USB_PD_FW_REBOOT,
-	USB_PD_FW_FLASH_ERASE,
-	USB_PD_FW_FLASH_WRITE,
-	USB_PD_FW_ERASE_SIG,
-};
+} __packed;
 
-struct __ec_align4 ec_params_usb_pd_fw_update {
-	uint16_t dev_id;
-	uint8_t cmd;
+struct ec_params_usb_pd_info_request {
 	uint8_t port;
-	uint32_t size;     /* Size to write in bytes */
-	/* Followed by data to write */
-};
-
-/* Write USB-PD Accessory RW_HASH table entry */
-#define EC_CMD_USB_PD_RW_HASH_ENTRY 0x0111
-/* RW hash is first 20 bytes of SHA-256 of RW section */
-#define PD_RW_HASH_SIZE 20
-struct __ec_align1 ec_params_usb_pd_rw_hash_entry {
-	uint16_t dev_id;
-	uint8_t dev_rw_hash[PD_RW_HASH_SIZE];
-	uint8_t reserved;        /* For alignment of current_image
-				  * TODO(rspangler) but it's not aligned!
-				  * Should have been reserved[2]. */
-	uint32_t current_image;  /* One of ec_current_image */
-};
-
-/* Read USB-PD Accessory info */
-#define EC_CMD_USB_PD_DEV_INFO 0x0112
+} __packed;
 
-struct __ec_align1 ec_params_usb_pd_info_request {
-	uint8_t port;
-};
+/*
+ * This command will return the number of USB PD charge port + the number
+ * of dedicated port present.
+ * EC_CMD_USB_PD_PORTS does NOT include the dedicated ports
+ */
+#define EC_CMD_CHARGE_PORT_COUNT 0x0105
+struct ec_response_charge_port_count {
+	uint8_t port_count;
+} __packed;
 
 /* Read USB-PD Device discovery info */
 #define EC_CMD_USB_PD_DISCOVERY 0x0113
-struct __ec_align_size1 ec_params_usb_pd_discovery_entry {
+struct ec_params_usb_pd_discovery_entry {
 	uint16_t vid;  /* USB-IF VID */
 	uint16_t pid;  /* USB-IF PID */
 	uint8_t ptype; /* product type (hub,periph,cable,ama) */
-};
+} __packed;
 
 /* Override default charge behavior */
 #define EC_CMD_PD_CHARGE_PORT_OVERRIDE 0x0114
@@ -4718,24 +3399,20 @@ enum usb_pd_override_ports {
 	/* [0, CONFIG_USB_PD_PORT_COUNT): Port# */
 };
 
-struct __ec_align2 ec_params_charge_port_override {
+struct ec_params_charge_port_override {
 	int16_t override_port; /* Override port# */
-};
+} __packed;
 
-/*
- * Read (and delete) one entry of PD event log.
- * TODO(crbug.com/751742): Make this host command more generic to accommodate
- * future non-PD logs that use the same internal EC event_log.
- */
+/* Read (and delete) one entry of PD event log */
 #define EC_CMD_PD_GET_LOG_ENTRY 0x0115
 
-struct __ec_align4 ec_response_pd_log {
+struct ec_response_pd_log {
 	uint32_t timestamp; /* relative timestamp in milliseconds */
 	uint8_t type;       /* event type : see PD_EVENT_xx below */
 	uint8_t size_port;  /* [7:5] port number [4:0] payload size in bytes */
 	uint16_t data;      /* type-defined data payload */
 	uint8_t payload[0]; /* optional additional data payload: 0..16 bytes */
-};
+} __packed;
 
 /* The timestamp is the microsecond counter shifted to get about a ms. */
 #define PD_LOG_TIMESTAMP_SHIFT 10 /* 1 LSB = 1024us */
@@ -4797,83 +3474,29 @@ struct __ec_align4 ec_response_pd_log {
 /*
  * PD_EVENT_VIDEO_CODEC payload is "struct mcdp_info".
  */
-struct __ec_align4 mcdp_version {
+struct mcdp_version {
 	uint8_t major;
 	uint8_t minor;
 	uint16_t build;
-};
+} __packed;
 
-struct __ec_align4 mcdp_info {
+struct mcdp_info {
 	uint8_t family[2];
 	uint8_t chipid[2];
 	struct mcdp_version irom;
 	struct mcdp_version fw;
-};
+} __packed;
 
 /* struct mcdp_info field decoding */
 #define MCDP_CHIPID(chipid) ((chipid[0] << 8) | chipid[1])
 #define MCDP_FAMILY(family) ((family[0] << 8) | family[1])
 
-/* Get/Set USB-PD Alternate mode info */
-#define EC_CMD_USB_PD_GET_AMODE 0x0116
-struct __ec_align_size1 ec_params_usb_pd_get_mode_request {
-	uint16_t svid_idx; /* SVID index to get */
-	uint8_t port;      /* port */
-};
-
-struct __ec_align4 ec_params_usb_pd_get_mode_response {
-	uint16_t svid;   /* SVID */
-	uint16_t opos;    /* Object Position */
-	uint32_t vdo[6]; /* Mode VDOs */
-};
-
-#define EC_CMD_USB_PD_SET_AMODE 0x0117
-
-enum pd_mode_cmd {
-	PD_EXIT_MODE = 0,
-	PD_ENTER_MODE = 1,
-	/* Not a command.  Do NOT remove. */
-	PD_MODE_CMD_COUNT,
-};
-
-struct __ec_align4 ec_params_usb_pd_set_mode_request {
-	uint32_t cmd;  /* enum pd_mode_cmd */
-	uint16_t svid; /* SVID to set */
-	uint8_t opos;  /* Object Position */
-	uint8_t port;  /* port */
-};
-
-/* Ask the PD MCU to record a log of a requested type */
-#define EC_CMD_PD_WRITE_LOG_ENTRY 0x0118
-
-struct __ec_align1 ec_params_pd_write_log_entry {
-	uint8_t type; /* event type : see PD_EVENT_xx above */
-	uint8_t port; /* port#, or 0 for events unrelated to a given port */
-};
-
-
-/* Control USB-PD chip */
-#define EC_CMD_PD_CONTROL 0x0119
-
-enum ec_pd_control_cmd {
-	PD_SUSPEND = 0,      /* Suspend the PD chip (EC: stop talking to PD) */
-	PD_RESUME,           /* Resume the PD chip (EC: start talking to PD) */
-	PD_RESET,            /* Force reset the PD chip */
-	PD_CONTROL_DISABLE,  /* Disable further calls to this command */
-	PD_CHIP_ON,          /* Power on the PD chip */
-};
-
-struct __ec_align1 ec_params_pd_control {
-	uint8_t chip;         /* chip id (should be 0) */
-	uint8_t subcmd;
-};
-
 /* Get info about USB-C SS muxes */
-#define EC_CMD_USB_PD_MUX_INFO 0x011A
+#define EC_CMD_USB_PD_MUX_INFO 0x11a
 
-struct __ec_align1 ec_params_usb_pd_mux_info {
+struct ec_params_usb_pd_mux_info {
 	uint8_t port; /* USB-C port number */
-};
+} __packed;
 
 /* Flags representing mux state */
 #define USB_PD_MUX_USB_ENABLED       (1 << 0)
@@ -4881,262 +3504,9 @@ struct __ec_align1 ec_params_usb_pd_mux_info {
 #define USB_PD_MUX_POLARITY_INVERTED (1 << 2)
 #define USB_PD_MUX_HPD_IRQ           (1 << 3)
 
-struct __ec_align1 ec_response_usb_pd_mux_info {
+struct ec_response_usb_pd_mux_info {
 	uint8_t flags; /* USB_PD_MUX_*-encoded USB mux state */
-};
-
-#define EC_CMD_PD_CHIP_INFO		0x011B
-
-struct __ec_align1 ec_params_pd_chip_info {
-	uint8_t port;	/* USB-C port number */
-	uint8_t renew;	/* Force renewal */
-};
-
-struct __ec_align2 ec_response_pd_chip_info {
-	uint16_t vendor_id;
-	uint16_t product_id;
-	uint16_t device_id;
-	union {
-		uint8_t fw_version_string[8];
-		uint64_t fw_version_number;
-	};
-};
-
-/* Run RW signature verification and get status */
-#define EC_CMD_RWSIG_CHECK_STATUS	0x011C
-
-struct __ec_align4 ec_response_rwsig_check_status {
-	uint32_t status;
-};
-
-/* For controlling RWSIG task */
-#define EC_CMD_RWSIG_ACTION	0x011D
-
-enum rwsig_action {
-	RWSIG_ACTION_ABORT = 0,		/* Abort RWSIG and prevent jumping */
-	RWSIG_ACTION_CONTINUE = 1,	/* Jump to RW immediately */
-};
-
-struct __ec_align4 ec_params_rwsig_action {
-	uint32_t action;
-};
-
-/*****************************************************************************/
-/* The command range 0x200-0x2FF is reserved for Rotor. */
-
-/*****************************************************************************/
-/*
- * Reserve a range of host commands for the CR51 firmware.
- */
-#define EC_CMD_CR51_BASE 0x0300
-#define EC_CMD_CR51_LAST 0x03FF
-
-/*****************************************************************************/
-/* Fingerprint MCU commands: range 0x0400-0x040x */
-
-/* Fingerprint SPI sensor passthru command: prototyping ONLY */
-#define EC_CMD_FP_PASSTHRU 0x0400
-
-#define EC_FP_FLAG_NOT_COMPLETE 0x1
-
-struct __ec_align2 ec_params_fp_passthru {
-	uint16_t len;		/* Number of bytes to write then read */
-	uint16_t flags;		/* EC_FP_FLAG_xxx */
-	uint8_t data[];		/* Data to send */
-};
-
-/* Fingerprint sensor configuration command: prototyping ONLY */
-#define EC_CMD_FP_SENSOR_CONFIG 0x0401
-
-#define EC_FP_SENSOR_CONFIG_MAX_REGS 16
-
-struct __ec_align2 ec_params_fp_sensor_config {
-	uint8_t count;		/* Number of setup registers */
-	/*
-	 * the value to send to each of the 'count' setup registers
-	 * is stored in the 'data' array for 'len' bytes just after
-	 * the previous one.
-	 */
-	uint8_t len[EC_FP_SENSOR_CONFIG_MAX_REGS];
-	uint8_t data[];
-};
-
-/* Configure the Fingerprint MCU behavior */
-#define EC_CMD_FP_MODE 0x0402
-
-/* Put the sensor in its lowest power mode */
-#define FP_MODE_DEEPSLEEP     (1<<0)
-/* Wait to see a finger on the sensor */
-#define FP_MODE_FINGER_DOWN   (1<<1)
-/* Poll until the finger has left the sensor */
-#define FP_MODE_FINGER_UP     (1<<2)
-/* Capture the current finger image */
-#define FP_MODE_CAPTURE       (1<<3)
-/* special value: don't change anything just read back current mode */
-#define FP_MODE_DONT_CHANGE   (1<<31)
-
-struct __ec_align4 ec_params_fp_mode {
-	uint32_t mode; /* as defined by FP_MODE_ constants */
-	/* TBD */
-};
-
-struct __ec_align4 ec_response_fp_mode {
-	uint32_t mode; /* as defined by FP_MODE_ constants */
-	/* TBD */
-};
-
-/* Retrieve Fingerprint sensor information */
-#define EC_CMD_FP_INFO 0x0403
-
-struct __ec_align2 ec_response_fp_info {
-	/* Sensor identification */
-	uint32_t vendor_id;
-	uint32_t product_id;
-	uint32_t model_id;
-	uint32_t version;
-	/* Image frame characteristics */
-	uint32_t frame_size;
-	uint32_t pixel_format; /* using V4L2_PIX_FMT_ */
-	uint16_t width;
-	uint16_t height;
-	uint16_t bpp;
-};
-
-/* Get the last captured finger frame: TODO: will be AES-encrypted */
-#define EC_CMD_FP_FRAME 0x0404
-
-struct __ec_align4 ec_params_fp_frame {
-	uint32_t offset;
-	uint32_t size;
-};
-
-/*****************************************************************************/
-/* Touchpad MCU commands: range 0x0500-0x05FF */
-
-/* Perform touchpad self test */
-#define EC_CMD_TP_SELF_TEST 0x0500
-
-/* Get number of frame types, and the size of each type */
-#define EC_CMD_TP_FRAME_INFO 0x0501
-
-struct __ec_align4 ec_response_tp_frame_info {
-	uint32_t n_frames;
-	uint32_t frame_sizes[0];
-};
-
-/* Create a snapshot of current frame readings */
-#define EC_CMD_TP_FRAME_SNAPSHOT 0x0502
-
-/* Read the frame */
-#define EC_CMD_TP_FRAME_GET 0x0503
-
-struct __ec_align4 ec_params_tp_frame_get {
-	uint32_t frame_index;
-	uint32_t offset;
-	uint32_t size;
-};
-
-/*****************************************************************************/
-/* EC-EC communication commands: range 0x0600-0x06FF */
-
-#define EC_COMM_TEXT_MAX 8
-
-/*
- * Get battery static information, i.e. information that never changes, or
- * very infrequently.
- */
-#define EC_CMD_BATTERY_GET_STATIC 0x0600
-
-struct __ec_align_size1 ec_params_battery_static_info {
-	uint8_t index; /* Battery index. */
-};
-
-struct __ec_align4 ec_response_battery_static_info {
-	uint16_t design_capacity; /* Battery Design Capacity (mAh) */
-	uint16_t design_voltage; /* Battery Design Voltage (mV) */
-	char manufacturer[EC_COMM_TEXT_MAX]; /* Battery Manufacturer String */
-	char model[EC_COMM_TEXT_MAX]; /* Battery Model Number String */
-	char serial[EC_COMM_TEXT_MAX]; /* Battery Serial Number String */
-	char type[EC_COMM_TEXT_MAX]; /* Battery Type String */
-	/* TODO(crbug.com/795991): Consider moving to dynamic structure. */
-	uint32_t cycle_count; /* Battery Cycle Count */
-};
-
-/*
- * Get battery dynamic information, i.e. information that is likely to change
- * every time it is read.
- */
-#define EC_CMD_BATTERY_GET_DYNAMIC 0x0601
-
-struct __ec_align_size1 ec_params_battery_dynamic_info {
-	uint8_t index; /* Battery index. */
-};
-
-struct __ec_align2 ec_response_battery_dynamic_info {
-	int16_t actual_voltage; /* Battery voltage (mV) */
-	int16_t actual_current; /* Battery current (mA); negative=discharging */
-	int16_t remaining_capacity; /* Remaining capacity (mAh) */
-	int16_t full_capacity; /* Capacity (mAh, might change occasionally) */
-	int16_t flags; /* Flags, see BATT_FLAG_* in battery.h */
-	int16_t desired_voltage; /* Charging voltage desired by battery (mV) */
-	int16_t desired_current; /* Charging current desired by battery (mA) */
-};
-
-/*
- * Control charger chip. Used to control charger chip on the slave.
- */
-#define EC_CMD_CHARGER_CONTROL 0x0602
-
-struct __ec_align_size1 ec_params_charger_control {
-	/*
-	 * Charger current (mA). Positive to allow base to draw up to
-	 * max_current and (possibly) charge battery, negative to request
-	 * current from base (OTG).
-	 */
-	int16_t max_current;
-
-	/* Voltage (mV) to use in OTG mode, ignored if max_current is >= 0. */
-	uint16_t otg_voltage;
-
-	/* Allow base battery charging (only makes sense if max_current > 0). */
-	uint8_t allow_charging;
-};
-
-/*****************************************************************************/
-/*
- * Reserve a range of host commands for board-specific, experimental, or
- * special purpose features. These can be (re)used without updating this file.
- *
- * CAUTION: Don't go nuts with this. Shipping products should document ALL
- * their EC commands for easier development, testing, debugging, and support.
- *
- * All commands MUST be #defined to be 4-digit UPPER CASE hex values
- * (e.g., 0x00AB, not 0xab) for CONFIG_HOSTCMD_SECTION_SORTED to work.
- *
- * In your experimental code, you may want to do something like this:
- *
- *   #define EC_CMD_MAGIC_FOO 0x0000
- *   #define EC_CMD_MAGIC_BAR 0x0001
- *   #define EC_CMD_MAGIC_HEY 0x0002
- *
- *   DECLARE_PRIVATE_HOST_COMMAND(EC_CMD_MAGIC_FOO, magic_foo_handler,
- *      EC_VER_MASK(0);
- *
- *   DECLARE_PRIVATE_HOST_COMMAND(EC_CMD_MAGIC_BAR, magic_bar_handler,
- *      EC_VER_MASK(0);
- *
- *   DECLARE_PRIVATE_HOST_COMMAND(EC_CMD_MAGIC_HEY, magic_hey_handler,
- *      EC_VER_MASK(0);
- */
-#define EC_CMD_BOARD_SPECIFIC_BASE 0x3E00
-#define EC_CMD_BOARD_SPECIFIC_LAST 0x3FFF
-
-/*
- * Given the private host command offset, calculate the true private host
- * command value.
- */
-#define EC_PRIVATE_HOST_COMMAND_VALUE(command) \
-	(EC_CMD_BOARD_SPECIFIC_BASE + (command))
+} __packed;
 
 /*****************************************************************************/
 /*
@@ -5176,6 +3546,4 @@ struct __ec_align_size1 ec_params_charger_control {
 #define EC_LPC_ADDR_OLD_PARAM   EC_HOST_CMD_REGION1
 #define EC_OLD_PARAM_SIZE       EC_HOST_CMD_REGION_SIZE
 
-#endif  /* !__ACPI__ */
-
 #endif  /* __CROS_EC_COMMANDS_H */
-- 
2.23.0.187.g17f5b7556c-goog


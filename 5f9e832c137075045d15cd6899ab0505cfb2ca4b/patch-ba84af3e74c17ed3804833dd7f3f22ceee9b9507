From 337d2f55d7fbc4eb641df4d421d532765a966f1b Mon Sep 17 00:00:00 2001
From: Jett Rink <jettrink@chromium.org>
Date: Fri, 5 Apr 2019 13:45:14 -0600
Subject: [PATCH] CHROMIUM: cros_ec_istp loops until events are gone

The ISH FW supports a flags that allows the kernel to continue to
query for more MKBP events until they are all consumed. This is the
preferred method for consuming events after receiving a MKBP event.

Also record the timestamp as close to the hardware event as possible
without breaking encapsulation boundaries.

BRANCH=none
BUG=b:129159505
TEST=AP is honoring flag and calling to get more events if needed

Change-Id: Id8f433bc08ae5329502668b443da96eb26a8b099
Signed-off-by: Jett Rink <jettrink@chromium.org>
Reviewed-on: https://chromium-review.googlesource.com/1555219
Reviewed-by: Enrico Granata <egranata@chromium.org>
Reviewed-by: Mathew King <mathewk@chromium.org>

[rebase419(rrangel): Context conflict]
Signed-off-by: Raul E Rangel <rrangel@chromium.org>

[rebase52(rrangel): Context conflict]
Signed-off-by: Raul E Rangel <rrangel@chromium.org>
---
 drivers/mfd/cros_ec.c                   |  5 +++--
 drivers/platform/chrome/cros_ec_ishtp.c |  8 ++++----
 include/linux/mfd/cros_ec.h             | 12 ++++++++++++
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/drivers/mfd/cros_ec.c b/drivers/mfd/cros_ec.c
index bbc9c4f3e887..3636b0900e76 100644
--- a/drivers/mfd/cros_ec.c
+++ b/drivers/mfd/cros_ec.c
@@ -57,7 +57,7 @@ static irqreturn_t ec_irq_handler(int irq, void *data) {
 	return IRQ_WAKE_THREAD;
 }
 
-static bool ec_handle_event(struct cros_ec_device *ec_dev)
+bool cros_ec_handle_event(struct cros_ec_device *ec_dev)
 {
 	bool wake_event = true;
 	bool ec_has_more_events = false;
@@ -79,6 +79,7 @@ static bool ec_handle_event(struct cros_ec_device *ec_dev)
 	return ec_has_more_events;
 
 }
+EXPORT_SYMBOL(cros_ec_handle_event);
 
 static irqreturn_t ec_irq_thread(int irq, void *data)
 {
@@ -86,7 +87,7 @@ static irqreturn_t ec_irq_thread(int irq, void *data)
 	bool ec_has_more_events;
 
 	do {
-		ec_has_more_events = ec_handle_event(ec_dev);
+		ec_has_more_events = cros_ec_handle_event(ec_dev);
 	} while (ec_has_more_events);
 
 	return IRQ_HANDLED;
diff --git a/drivers/platform/chrome/cros_ec_ishtp.c b/drivers/platform/chrome/cros_ec_ishtp.c
index 430731cdf827..6ff1f4e8d40d 100644
--- a/drivers/platform/chrome/cros_ec_ishtp.c
+++ b/drivers/platform/chrome/cros_ec_ishtp.c
@@ -137,11 +137,11 @@ static void ish_evt_handler(struct work_struct *work)
 	struct ishtp_cl_data *client_data =
 		container_of(work, struct ishtp_cl_data, work_ec_evt);
 	struct cros_ec_device *ec_dev = client_data->ec_dev;
+	bool ec_has_more_events;
 
-	if (cros_ec_get_next_event(ec_dev, NULL) > 0) {
-		blocking_notifier_call_chain(&ec_dev->event_notifier,
-					     0, ec_dev);
-	}
+	do {
+		ec_has_more_events = cros_ec_handle_event(ec_dev);
+	} while (ec_has_more_events);
 }
 
 /**
diff --git a/include/linux/mfd/cros_ec.h b/include/linux/mfd/cros_ec.h
index 37139000d30d..e38439dcc4bd 100644
--- a/include/linux/mfd/cros_ec.h
+++ b/include/linux/mfd/cros_ec.h
@@ -364,4 +364,16 @@ u32 cros_ec_get_host_event(struct cros_ec_device *ec_dev);
  */
 s64 cros_ec_get_time_ns(void);
 
+
+/**
+ * cros_ec_handle_event - process and forward pending events on EC
+ *
+ * Call this function in a loop when the kernel is notified that the EC has
+ * pending events.
+ *
+ * Returns true if more events are still pending and this function should be
+ * called again.
+ */
+bool cros_ec_handle_event(struct cros_ec_device *ec_dev);
+
 #endif /* __LINUX_MFD_CROS_EC_H */
-- 
2.23.0.rc1.153.gdeed80330f-goog

